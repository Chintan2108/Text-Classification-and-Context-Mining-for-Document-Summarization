{{Skip to talk}}
{{Talk header}}
{{summary in|Language}}
{{ArticleHistory
|action1=FAC
|action1date=15:13, 21 June 2006
|action1link=Wikipedia:Featured article candidates/Programming language/archive1
|action1result=not promoted
|action1oldid=59740570
|action2=PR
|action2date=19:32, 28 June 2006
|action2link=Wikipedia:Peer review/Programming language/archive1
|action2result=reviewed
|action2oldid=61064581
|action3=GAN
|action3date=19:53, 8 July 2006
|action3result=listed
|action3oldid=62765910
|action3link=Talk:Programming language#Good Article

|action4=GAR
|action4link=Talk:Programming language/GA1
|action4date=17:54, 10 March 2009 (UTC)
|action4result=delisted
|action4oldid=276009986

|topic=Engtech
|currentstatus=DGA
}}
{{Vital article|level=4|topic=Technology|class=C}}
{{WikiProjectBannerShell|
{{WikiProject Computing |class=B |importance=High}}
{{WikiProject Computer science |class=B |importance=Top}}
{{WP1.0 |v0.5=pass |class=B |category=Engtech |importance=High}}}}
{{archives}}
{{todo}}
{{merged-from|Dialect (computing)|7 February 2018}}

== Article scope too limited: assuming machines and computers ==

Currently this article assumes that programming language is a phenomenon exclusive to machines in general, and computers in particular.

This assumption seems inappropriate, given that there is at least one widely-recognized counterexample: biological programming languages:

=== See e.g. ===

* http://news.mit.edu/2016/programming-language-living-cells-bacteria-0331
* http://reliawire.com/biological-programming-language/

[[User:Dreftymac|dr.ef.tymac]] ([[User talk:Dreftymac|talk]]) 18:13, 29 April 2017 (UTC)
:Did you read more about it? 
:Programming biological systems is a '''metaphor'''.
:The work you cite is not as recent as you think, it is part of an area called Synthetic Biology.
:Synthetic biology tries to apply real engineering principles to genetic engineering.
:Biological systems, however, are complex systems. They can not be programmed them in the same sense that computers are, because you can not program emergent properties just designing a DNA chain. Not even composing known biological pathways isolated and standardized as Biobricks, as synthetic biology works.
:There are however other computing forms, like quantum computing, there is an ongoing research on it. Even a DNA computing, which encodes problems in DNA chains and place them to evolve in a thermo-cycler for PCR and device a way to isolate the chain with the answer.  <!-- Template:Unsigned IP --><small class="autosigned">—&nbsp;Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[Special:Contributions/201.124.211.115|201.124.211.115]] ([[User talk:201.124.211.115#top|talk]]) 05:10, 11 June 2017 (UTC)</small> <!--Autosigned by SineBot-->

== Human communication? ==

The article prominently states the idea, in the first paragraph no less, that programming languages are used to communicate between humans. But then that idea is completely ignored in the rest of the article to the point that it never clarifies ''which'' forms of human communication are allowed by PLs. This imbalance should be addressed in the article body, or removed from the lead paragraph if it's not one of the main aspects of PLs. [[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 13:52, 28 October 2008 (UTC)

:The article does not talk about communication with computers, computations or some of the other general items mentioned in the introduction.  The introduction gives readers a quick, accurate overview of what a programming language is and what it is used for.  The rest of the article covers various issues that people have considered important and wanted to write more about.  This material is something of a mish-mash and has not been through the scrutiny that the introduction has.  [[User:Derek farn|Derek farn]] ([[User talk:Derek farn|talk]]) 14:16, 28 October 2008 (UTC)

::Well that's my point, I don't think "Programming languages can be used as a mode of human communication" is accurate. I don't understand what it means (i.e. what degree of communication is allowed), it can't be inferred from context, and it isn't explained in the article. One can only speculate what human communication has to do with programming languages. [[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 14:55, 28 October 2008 (UTC)
:::Perhaps we can have some sort of brief discussion of the many text books and college (and graduate) courses that utilize PLs as part of their means of communicating concepts (such as algorithms, mathematical relationships, etc).  I'm not sure how it might be woven in, but Knuth's use of MMIX in ''TAoCP'' is interesting: it's a PL that is used throughout a widely read text, but that AFIAK has never actually been implemented in a compiler/interpreter. Even if someone actually did create a means of running MMIX, Knuth's primary purpose is certainly to describe and discuss algorithms and techniques for his human readership. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 18:02, 28 October 2008 (UTC)

::::That would be a welcome addition. We could also elaborate on the concept of [[pseudocode]], which is strongly related to programming languages but is centered around the necessities of human communication instead of machine control. [[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 12:36, 4 November 2008 (UTC)

:::Where would a language such as [[Inform]] sit?  Is it intended to be used to communicate with humans, computers or both? [[User:Derek farn|Derek farn]] ([[User talk:Derek farn|talk]]) 13:02, 4 November 2008 (UTC)

::::That makes me think of [[literate programming]]. Although the final product of Inform and LP is to produce a functional program to be executed, the form in which it's created is important. [[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 14:19, 4 November 2008 (UTC)

Given that this issue still persists, I think that a paragraph on [[pseudocode]] should be added somewhere in the body. [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 11:09, 11 September 2009 (UTC)

I'm just a reader (and a programmer), not an expert, but I have never heard of programming languages being used as a serious form of human communication (i.e. not merely used for humor).  I think this needs a citation.  [[User:John lindgren|John lindgren]] ([[User talk:John lindgren|talk]]) 13:37, 15 June 2011 (UTC)

[[User:John lindgren|John lindgren]], programming languages are used to as a means of documenting an algorithm or protocol in books, papers and specifications.  When used in this way many details tend to get abstracted away, e.g., definitions of the variables.  A language usage that is closer to a form of 'normal' human communication is provided by the [[Inform]] language.[[User:Derek farn|Derek farn]] ([[User talk:Derek farn|talk]]) 14:52, 15 June 2011 (UTC)

I am also a reader and a programmer, but I can see how programming languages can be considered a means of communication. However, I would argue that it is a means of communication for a limited domain (primarily, instruction via examples). [[User:Jf1357|Jf1357]] ([[User talk:Jf1357|talk]]) 00:31, 22 July 2011 (UTC)

:Programming languages are designed for human communication. It was a primary driving consideration in developing high level programming language. Maintaining programs was and is an important factor in programming language design.

:There are criptic programming languages. Criptic languages are not generally used except for write once programs.

:ALGAL had a publication language specification and a machine executable programming language specification.

:To sum it up we have human readable for maintance and instruction examples. We have comments for human communacation. But not all programming languages are meant to be human readably. Machine language can only be read be a small number of programmers. Even when assembly languages was  common.[[User:Steamerandy|Steamerandy]] ([[User talk:Steamerandy|talk]]) 10:27, 22 June 2015 (UTC)

== Computer language is not equal to programming language. please not redirect it to here ==

Why is "[[Computer language]]" redirected to "[[Programming language]]"? Not all computer languages can do computation or I/O, exist many computer languages are not programming languages, like [[data structure format languages]], presentation languages (including [[style sheet languages]]), [[user interface languages]], grammar describing languages, i.e. [[YAML]], [[JSON]], [[OGDL]], [[CSS]], [[HTML]], [[XML]], [[BBCode]], [[XUL]], [[XAML]], [[Regular expression]], [[BNF]].--[[User:LungZeno|LungZeno]] ([[User talk:LungZeno|talk]]) 05:35, 15 November 2008 (UTC)
:Maybe you should write an article for "Computer language" that mentions, but does not redirect to, "Programming language". <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 06:29, 15 November 2008 (UTC)
: Actually it is a synonym, see the ref I [http://en.wikipedia.org/w/index.php?title=Programming_language&diff=311350769&oldid=311311109 just added]. The only sense in which a computer language is not a programming language is if "communicating with a computer" (2nd sense of computer language) does not equal/entail programming them. If you're willing to make this assumption, you're essentially assuming [[animism]], i.e. that computers have [[free will]]. [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 21:49, 1 September 2009 (UTC)
:: See also: [[Talk:Computer_language#Please_delete_this_article]]. [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 21:56, 1 September 2009 (UTC)

::Actually, it is not a synonym:
::# Computer languages do not necessarily express [[computation]]s (the application of operations to values within the framework of some computational model), while PLs are specifically designed to describe computations.
::: They express computations in the sense of [[computability]], i.e. they express something that a computer can do. (The def you give in parentheses above is ''not'' from our article on [[computation]], so it appears to be your [[WP:OR]].) [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 23:45, 1 September 2009 (UTC)
::::No, it is not my OR. It is a paraphrase of Definition 1.1 from Aaby's [http://burks.brighton.ac.uk/burks/pcinfo/progdocs/plbook/index.htm Introduction to Programming Languages]. One can find similar ideas in Felleisen's ''Programming Languages and Lambda Calculi'' ("In the same way that computation on physical machines can be described, ultimately, in terms of shuffling bits among memory locations, computation in the abstract can be described in terms of relations on text."), or in Abelson and Sussman's classic ''Structure and Interpretation of Computer Programs'' ("In programming, we deal with two kinds of elements: procedures and data. ... Informally, data is "stuff" that we want to manipulate, and procedures are descriptions of the rules for manipulating the data. "). --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 00:23, 2 September 2009 (UTC)
  
::# Your reference makes PLs sound like a subset of computer languages (which would be in line with my first point). 
::: Like I explained below using Turing machines, this is just a appearance; you cannot formally define a ''proper subset'' of "computer languages" which are ''just'' "programming languages". [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 23:45, 1 September 2009 (UTC)

::::These arguments ''do'' sound like [[WP:OR]] to me. Do you have references from the programming language literature that back up these ideas? --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 00:23, 2 September 2009 (UTC)

::# The viewpoint expressed in your reference is by no means a unanimous one, since programming languages do not necessarily have to involve computers (I have added a reference to that effect). 
::: The fact that you can define the syntax and semantics of semantics of programming languages mathematically has no bearing on this issue because computation can also be defined mathematically. So, there's no contradiction, i.e. the notion computation is not tied to a physical computer, and neither is the notion of a programming language. [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 00:03, 2 September 2009 (UTC)

::::You have missed my point, which is that programming languages are not inherently tied to computers. One can write programs in languages that are not ever executed on computers. So it's invalid to claim that "programming language" == "computer language" (you could perhaps claim that "programming language" == "computation language"). --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 00:42, 2 September 2009 (UTC)

::PLs are tools for specifying and communicating computations. Not all commmunication with computers involves the specification of a computation. In some cases what is communicated to a computer is just data (for example a table of names and addresses), which is processed in accordance with computational rules specified elsewhere. 
::--[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 22:59, 1 September 2009 (UTC)
: In terms of a [[Turing machine]] a "programming language" presumably means "just" the language in which the state transitions and head move instructions are expressed (transition function), whereas computer language could also describe how data is encoded. But this distinction is entirely artificial, due to  the existence of a [[universal Turing machine]]: it can "run" (that is simulate) any other Turing machine described on its tape. So any "programming language" for some machine is also a "computer language" for the universal Turing machine. Thus no clear distinction can be made between the two notions. [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 22:54, 1 September 2009 (UTC)

::A Turing machine is a mathematical model of computation, not a computer. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 00:56, 2 September 2009 (UTC)

::: The 1st sentence of this article reads "A programming language is an artificial language designed to express computations that ''can'' be performed by a machine, particularly a computer." So, now you're saying that a programming language ''must'' run a physical computer??? What happened to Ben Ari's idea that a PL can be defined mathematically. Is it false now? [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 01:43, 2 September 2009 (UTC)

::::No, I'm saying that a programming language does not have to run on a computer, so it is not valid to say that "programming language" == "computer language". The UTM is a model of computation, not a computer, so it's input language is not a "computer language". --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 01:55, 2 September 2009 (UTC)

=== Computation ===

The article this article links to defines it as "Computation is a general term for any type of information processing." So, a [[markup language]] does define a computation in that respect. [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 23:48, 1 September 2009 (UTC)

:A markup language defines structured data, not the processing done on that data. Also, I wouldn't exactly consider a loose informal definition in Wikipedia a reliable resource. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 00:46, 2 September 2009 (UTC)
:: Then don't link to [[computation]] if you don't agree with what it says in the context in which you use it; you've unliked [[artificial language]] for instance. [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 01:21, 2 September 2009 (UTC)

:::The remainder of the computation article elaborates on the definition, and makes it more clear what the term actually refers to. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 01:51, 2 September 2009 (UTC)

:: Also, your definition of markup language gives semantics (structured data) to a syntax (markup). Why is it not a programming language? Is the DDL from SQL not a programming language? [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 01:27, 2 September 2009 (UTC)

:::Does the semantics define a computation? No. It defines a structure. Just because something has semantics it is not automatically a programming language. The point of any language is to communicate some kind of meaning (semantics). A linked-list is a data structure. Its semantics is that of defining a sequence of data values. One can ascribe other semantics to the list (for example by interpreting the data values as computational instructions, and the list sequence as the sequence in which computational steps should be performed), but that does not make the semantics of linked-lists that of programs. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 01:51, 2 September 2009 (UTC)

=== Markup languages ===
The [[W3C]] definition of a [http://www.w3.org/WAI/lexicon/ markup language] is: "A markup language is a syntax and/or set of rules to manage content and structure of a document or object (for example, HTML , SVG , or MathML)." The first part clearly defines it as [[formal language]]; the 2nd is a bit more interpretable, but the "and/or" strongly suggests [[program semantics]] (not necessarily ''formal'' semantics as our redirect makes it). If something having syntax and semantics does not qualify as a programming language, then it is what? Just a computer language in some vague sense of communicating with a computer? The sense of this communication appears pretty concrete to me, and it coincides with that of programming language. [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 00:18, 2 September 2009 (UTC)

:You say ''"...the 2nd is a bit more interpretable..."'' and ''"...the "and/or" strongly suggests..."''. Statements like that tend to point towards [[WP:OR]]. Please see [http://www.cs.tut.fi/~jkorpela/prog.html here] for a concise discussion of the differences between markup languages and programming languages.  --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 00:48, 2 September 2009 (UTC)
:: Ha, ha, ha! That guy's site is more authoritative than W3C's? [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 01:12, 2 September 2009 (UTC)

:::No. But it already covers all of the arguments that I have no desire to repeat here. For example, as he points out: ''No HTML specification has ever called HTML a programming language, or anything like that.'' --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 01:43, 2 September 2009 (UTC)

::[[troff]] and [[LaTeX]] are markup languages that are sufficiently powerful that it is possible to perform all sorts of computation with them.  Of course they are not intended for this use and perhaps that is what differentiates them from being a programming language.  Markup languages are not intended to express general computations and nobody would use them for this purpose (unless it is part of some exercise or quiz), it just so happens that some have features that make this possible. [[User:Derek farn|Derek farn]] ([[User talk:Derek farn|talk]]) 01:48, 2 September 2009 (UTC)

=== Turing-completeness ===
{{hidden begin
|title = I see someone does define it this way and the non-agreement on this is already discussed in the article. [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 00:41, 2 September 2009 (UTC)
|titlestyle = background:pink; text-align:center;
}}
I did not see this issue raised, and we'd need a ref to make a claim like this, but it may be reasonable for some to avoid calling non-[[Turing-complete]] languages "programming languages". This isn't normally done though. Would SQL or the [[calculus of constructions]] not qualify as programming languages? Most people probably don't disqualify these as programming languages. [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 00:18, 2 September 2009 (UTC)
{{hidden end}}

=== Programming language and computer language intersection ===

The description here is inconsistent in not covering all programming languages. Some later described.

In the computer field for example binary code is a programming language. On the other hand a piano roll is a programming language. Industrial robotics programming. Various forms of programming languages exist. Programming a Dish network receiver for the recording of shows is a programming language.

High level computer programming languages were specificly developed to be human readable. Communicating both algorithms to a computer and between humans.

Programming languages are most commonly associated with computers. Supported by the many books on "programming languages" in their title being on computer programing.

Not all computer languages are programming languages. Computer communication usually involves massages that are computer lamguages. They have a defined syntax we call protocols.

While many computer languages are programming languages. Some ate not. Not all programming languages are computer languages.

Neither is a subset of the other. There is however a huge overlap of concepts.

They should be combined.

A programming language directs the operations of an automation.

A computer language being a less used term can refers to a computer programming language or a communication/network protocol language.

Is a flowchart a programming language?

I am seeing a problem with the wiki here. Like this one many topics have conceptually the same ideas in different contexts.
[[User:Steamerandy|Steamerandy]] ([[User talk:Steamerandy|talk]]) 17:17, 26 May 2015 (UTC)

: Hello!  Quite frankly, I'never heard or seen a communication protocol called a computer language.  Pretty much the same would apply to a programming language. &mdash;&nbsp;[[User:Dsimic|Dsimic]]&nbsp;([[User talk:Dsimic#nobold|talk]]&nbsp;|&nbsp;[[Special:Contributions/Dsimic|contribs]]) 19:29, 26 May 2015 (UTC)
: {{Reply to|Steamerandy}} Hello, it's a complicated question. A language is sometime called a proramming language only if it is a [[Turing complete]] language, which is imho restrictive as it does not include languages like [[coq]]. The issue is discussed a lot on the web <ref group="Turingcomplete">http://programmers.stackexchange.com/questions/172979/are-non-turing-complete-languages-considered-programming-languages-at-all</ref> <ref group="Turingcomplete">http://stackoverflow.com/questions/315340/practical-non-turing-complete-languages</ref> <ref group="Turingcomplete">http://www.quora.com/What-exactly-is-a-Programming-Language-How-exactly-does-one-create-a-programming-language</ref>[[User:TomT0m|TomT0m]] ([[User talk:TomT0m|talk]]) 18:44, 27 May 2015 (UTC)

<references group="Turingcomplete" />

== Syn tags ==

(I see that got [http://en.wikipedia.org/w/index.php?title=Programming_language&diff=311387475&oldid=311385647 removed], but here's my rationale for tagging it.) I think that some read too much in those dictionary definition(s). That dictionary is not a mathematical text, so inferring from two semi-techincal definitions that computer languages are a proper superclass of programming languages is [[WP:SYN|improper synthesis]] in my view. And so is interpreting Ben Ari's paragraph, which does not directly define a notion of "computer language" as opposed to programming language. [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 01:38, 2 September 2009 (UTC)

:Your dictionary reference gave two definitions: it defined "programming language" in a manner very close to the definition this article used; it defined "computer language" in a broad way, part of which might be construed as referring to a programming language (although those exact words weren't used). So who's synthesizing here? --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 02:58, 2 September 2009 (UTC)

== The bottom line: synonymy question ==

Besides [[User:Allan McInnes]] who quickly removed [http://en.wikipedia.org/w/index.php?title=Programming_language&diff=311350769&oldid=311311109 this change], which tried to claim that computer language ''may'' be synonymous with programming language, and replaced with [http://en.wikipedia.org/w/index.php?title=Programming_language&diff=311363758&oldid=311351082 this discussion] (which in turn got [http://en.wikipedia.org/w/index.php?title=Programming_language&diff=311387475&oldid=311385647 removed] by [[User:Lulu_of_the_Lotus-Eaters]] after I tagged it as synthesis) does everyone else agree that [[computer language]] is ''not'' commonly a synonym for [[programming language]]? Sure, computer language could ''also'' mean something else according to that dictionary, but that 2nd meaning is not incredibly relevant in this article. My point is that [[computer language]] is a synonym often enough for [[programming language]] ''for this fact to be mentioned in this article'', and we have a reasonable source for the claim. We do not really have to discuss ''all other'' possible meanings of [[computer language]] here. (Like I wrote in the sections above, I find that 2nd meaning of computer language ill defined, but it's not truly germane for ''this'' article). [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 02:07, 2 September 2009 (UTC)

Also, [[Programming_language#Usage]] uses "computer language" without ever defining it! So, if it's not a synonym of programming language, then why use it as one?!?  [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 02:07, 2 September 2009 (UTC)

:So why not just fix the poor use of terms in the usage section? --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 03:06, 2 September 2009 (UTC) 

Perhaps a formulation like "Programming languages are often called computer languages, although the latter term sometimes has a different meaning." satisfies everyone? [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 02:07, 2 September 2009 (UTC)

:: Do you actually have any references which state that "computer language" is used as a synonym for "programming language"? --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 03:06, 2 September 2009 (UTC) 

::: '''YES'''. If you really want a source that explicitly say that: Robert A. Edmunds, ''The Prentice-Hall standard glossary of computer terminology'', Prentice-Hall, 1985, p. 91 [http://books.google.com/books?id=qpJFAAAAYAAJ&q=%22computer+language%22+%22programming+language%22&dq=%22computer+language%22+%22programming+language%22&lr=]. [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 09:25, 2 September 2009 (UTC)

::: [http://books.google.com/books?id=3X2l-bBxioEC&pg=PA211&dq=%22Except+for+these+differences,+a+computer+language+is+in+fact+a+programming+language.%22#v=onepage&q=%22Except%20for%20these%20differences%2C%20a%20computer%20language%20is%20in%20fact%20a%20programming%20language.%22&f=false Another ref], which is more discriminating in the sense of Ben Ari (i.e. programming languages are a superset of computer languages, not the other way around because of the finiteness of all of our computers):

{{cquote|[...] the model [...] for computer languages differs from that [...] for programming languages in only two respects. In a computer language, there are only finitely many names--or registers--which can assume only finitely many values--or states--and these states are not further distinguished in terms of any other attributes. [author's footnote:] This may sound like a truism but its implications are far reaching. For example, it would imply that any model for programming languages, by fixing certain of its parameters or features, should be reducible in a natural way to a model for computer languages. }} 

::: The phrases I've omitted here for clarity [...] just give pointers to the sections of the paper where those models are defined in detail. In case the gbooks link doesn't work, the ref is: R. Narasimahan, ''Programming Languages and Computers: A Unified Metatheory'', pp. 189--247 in Franz Alt, Morris Rubinoff (eds.) ''Advances in computers, Volume 8'', Academic Press, 1994, ISBN 012012108, quote is from section 2.5, p. 211[[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 10:33, 2 September 2009 (UTC)

::: Also, the same paper stresses on p. 193 (section 1.3.2) "a complete specification of a programming language must, by definition, include a specification of a processor--idealized, if you will--for that language." An he cites many references in support of this, including Dijkstra. I think this is what Mr. McInnes is trying to stress in the "Computation" section above, i.e. syntax specification alone is not a complete specification of a programming language. But defining a processor appears sufficient according to this source, e.g. saying that "this tag make text appears bold on screen" is defining a processor. In the end, I have to conclude that what [[Benjamin C. Pierce]] [[Object-oriented programming#Main features|said about OOPL]] applies here too: discussions about what is a programming language and what isn't shed little light on the subject matter, and only serve to illustrate the cognitive biases of the participants. [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 10:33, 2 September 2009 (UTC)

=== SIGPLAN def ===

: Perhaps the sigplan quote we have in the article's footnotes says it best: "'''computer programming languages''' - languages that permit the specification of a variety of different computations, thereby providing the user with significant control (immediate or delayed) over the computer's operation." [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 02:31, 2 September 2009 (UTC)

::Note that what the sigplan quote describes are "computer ''programming languages''", i.e. programming languages ("languages that permit the specification of a variety of different computations") used to define the way computer should operate ("providing the user with significant control (immediate or delayed) over the computer's operation"). That's not the same as a "computer language". --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 03:06, 2 September 2009 (UTC)

=== Claim that computer languages superset programming languages ===

''Computer languages'' is definitely a broader category (a superset) than ''programming languages''.  Markup languages, grammar languages, and so on are also "computer languages".  The relationship is containment, not identity. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 06:55, 2 September 2009 (UTC)

:Pedantically speaking, it's perhaps more intersection than containment, since I think a case could be made that programming languages don't have to (although they often do) have anything to do with computers. For example, a lambda calculus program doesn't necessarily have to be written in a computer language. Typically if you want to run a lambda calculus program on a computer you end up having to encode the lambda expressions into some computer language that acts as the input language for the LC interpreter. 
:That said, I agree with your basic point. As I said, "I think a case could be made", but I've never seen anyone make that case. And I doubt it's really all that important to make such a distinction. The key point is, as you've stated, that there are computer languages which are not programming languages. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 07:32, 2 September 2009 (UTC)
: {{fact}} You need to produce an explicit reference arguing that  "computer language" is strict superset of "programming language", ''using this terminology''. I was able to find one author that explicitly considers the two synonymous. [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 09:30, 2 September 2009 (UTC)

:: I don't see that there's any need to establish that "computer language" is a strict superset. All that needs to be established is that there are computer languages which are not programming languages.
::Given that it's already been established via several references that markup languages ''are not'' programming languages, are you now arguing that HTML and XML are not computer languages? 

:: As for references:
::* [http://books.google.com/books?id=QMJE7qS7RE8C&q=%22computer+language%22+%22programming+language%22&dq=%22computer+language%22+%22programming+language%22&lr= Computer data management and data base technology by Harry Katzan], "A programming language is a form of computer language..."
::* [http://books.google.co.nz/books?id=4hpKj29LPuAC&pg=PA346&dq=%22computer+language%22+markup+programming&lr=#v=onepage&q=%22computer%20language%22%20markup%20programming&f=false Introduction To Computers And C Programming by S.K. Bajpai], "Markup languages are a special type of computer language... HTML is not really a programming language"
::* [http://www.loa-cnr.it/ICSOFT2007_final.pdf Towards a General Ontology of Computer Programs by Pascal Lando, Anne Lapujade, Gilles Kassel, and Frédéric Fürst] explicitly places "programming languages" as a strict subset of "computer languages" (see Figure 7).
::I will concede that a number of references seem to use "computer language" when they really mean "programming language". But that largely seems to be slightly imprecise terminology arising from the fact that the authors didn't consider things like markup languages (or really any languages that aren't Turing complete) to be computer languages. So if you would like to argue that non-Turing-complete languages are not computer languages... --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 11:46, 2 September 2009 (UTC)

::I leave it to someone else to decide whether or not it's worth discussing these terminological inconsistencies in the article. I would ask that if you do so, you place the discussion somewhere in the body of the article, rather than polluting the lead with pedantry. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 11:46, 2 September 2009 (UTC)

:I think the distinction is that the term Computer language is used when talking to non-computer literate people, it saves having to explain what programming is all about.  I have certainly learned to use it that way. [[User:Derek farn|Derek farn]] ([[User talk:Derek farn|talk]]) 09:50, 2 September 2009 (UTC)
:: I'm okay with including Derek's observation and Lulu's claim in this article, as long we can come with a reasonable source for these. The are a couple of sources (two sections above) that consider computer languages (using precisely this terminology) either synonymous or a [[finitary]] version of programming languages. So, the view that computer languages ''properly superset'' programming languages is certainly not universal, thus we need a reference for it. [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 10:40, 2 September 2009 (UTC)
:: The same request for citation applies to Mr. McInnes' view that computer languages ''properly intersect'' programming languages. [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 10:55, 2 September 2009 (UTC)

:::Please note that, as I specifically stated, while I think the case could be made for intersection, I've not seen anyone explicitly make it. Probably because no one thought it was actually all that important to do so. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 11:52, 2 September 2009 (UTC)
:::: Okay, given the nebulousness of what a "computer language" might mean, let's include in the article statements that can be [[WP:V|attributed to some source]]. It seems we should have no trouble finding some source that say that "computer languages include programming languages" to [[WP:NPOV|counterbalance]] the view that the inclusion is the other way around, for which I did find a good source (meaning published in reasonable venue and explains its reasoning in detail) two sections above. But despite the fact that many sources make definite statements "X is not a programming language", they don't say "instead X is a computer language". So, it's rather frustrating trying to find a source for Lulu's view. [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 14:57, 2 September 2009 (UTC)

Allen McInnes is probably right that ''strict superset'' is slightly too strong.  Obviously, usage of "computer language" varies a lot though, in any case (many writer use the superset meaning, but others just allow non-identity).  Derek farn is also correct that informally one might use "computer language" for laypersons who don't have a clear sense of "programming language"... I wouldn't object to a clause making that point, as long as it is in the body rather than the lead. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 20:37, 2 September 2009 (UTC)

=== Proposal then ===
::::: I see you did give some sources above (the non-linear editing of threads here is confusing to me). So, we can just say in the lead something like: "'''Computer language''' is sometimes used as a synonym for programming language, but opinions vary as to whether all computer languages are programming languages or the other way around." The details (just one paragraph can go in the body of the "Definition section") roughly along the lines of what you added yesterday, but this time we can cite sources that explicitly use "computer language". [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 15:13, 2 September 2009 (UTC)A programming language is an artificial language designed to communicate instructions to a machine, particularly a computer. Programming languages can be used to create programs that control the behavior of a machine and/or to express algorithms precisely.

The earliest programming languages predate the invention of the computer, and were used to direct the behavior of machines such as Jacquard looms and player pianos. Thousands of different programming languages have been created, mainly in the computer field, with many more being created every year. Most programming languages describe computation in an imperative style, i.e., as a sequence of commands, although some languages, such as those that support functional programming or logic programming, use alternative forms of description.

The description of a programming language is usually split into the two components of syntax (form) and semantics (meaning). Some languages are defined by a specification document (for example, the C programming language is specified by an ISO Standard), while other languages, such as Perl 5 and earlier, have a dominant implementation that is used as a reference.

== What kind of language is a programming language? ==

There's some dispute over linking to [[Constructed Language]] to illustrate the definition as an [[artificial language]] in the lead. In my opinion the definition of constructed language ("a language whose phonology, grammar, and/or vocabulary have been consciously devised by an individual or group, instead of having evolved naturally") fits perfectly for programming languages, so I think this is a valid link. The alternative is linking to [[formal language]] (the [[Language#Programming_languages]] describes programming languages as an "extreme case of a formal language"), but this was rejected here some time ago. Which term should be used to say what a programming language ''is'', and how we get sure that the term we use is properly defined? [[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 18:35, 2 September 2009 (UTC)
* [[Formal language]] is not a good link there because formal languages do not have semantics. I don't know enough linguistics to tell you if [[artificial language]] is a good link or not, but at least [[language]] should be linked because [http://books.google.com/books?q=%22it+is+a+language%2C+yes%22&btnG=Search+Books linguists do consider programming languages languages] (as I recently had to explain [[Wikipedia:SFD#.7B.7BPL-stub.7D.7D_.2F_.7B.7BProg-lang-stub.7D.7D|here]]). [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 19:19, 2 September 2009 (UTC)

:While [[Esperanto]] may have some oddball formal similarity to [[Pascal]], making that connection in this article (let alone in the lead) veers badly into [[WP:SYNTH]] territory.  In our lead we are simply using the words "artificial" and "language" in their vernacular and informal sense.  No link is needed, nor appropriate. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 20:41, 2 September 2009 (UTC)
:: I gave a ref above, so no SYNT or OR here in linking to language. [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 20:43, 2 September 2009 (UTC)

:::The link to [[Language]] looks OK to me, just none of that artificial/man-made/constructed stuff.  However, many of your recent edits, Pohta ce-am pohtit, are definitely skirting [[WP:OVERLINK]] if not crossing the line.  We really don't need to link ''every single word'' in the article, and we should especially watch that in the lead. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 20:49, 2 September 2009 (UTC)
::In the vernacular sense languages are naturally evolved, so the juxtaposition of the "artificial" and "language" ideas needs at least some clarification if we don't want it to be confusing. Specially given that Wikipedia itself has a precise meaning for [[artificial language]] that seems to be different from what is implied here. If not in the lead (given that there's no other Wikipedia article describing what is special about these languages to which we could link), at least the [[Programming_language#Design_and_implementation|Design and implementation]] section should address this concern. [[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 20:55, 2 September 2009 (UTC)
:::Well, not quite.  WP's link for "artificial language" is a redirect to "constructed language" (at least at this moment).  That seems slightly imperfect to me, but WP is a big place.  What we mean by the ordinary word "artificial" is definitely not what that links to. But y'know... we really, really, really don't need to have a link for every single word in the article.  We expect readers to read ordinary English. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 21:17, 2 September 2009 (UTC)
::::Yes, but when the ordinary English we write seems to produce contradictory meaning, readers should expect us to provide a clarification. [[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 21:30, 2 September 2009 (UTC)
:::That said, if you want to write a sentence ''outside the lead'' that explains the difference of PL's from natural languages, I'm fine with that. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 21:18, 2 September 2009 (UTC)
Does someone have access to [http://portal.acm.org/citation.cfm?doid=361227.361229 Programming Languages, Natural Languages, and Mathematics] by Peter Naur? It seems that it could prove a good reference to this topic, but I can't read articles from the ACM any longer in my current job. [[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 21:30, 2 September 2009 (UTC)
: Nothing particularly useful because (i) it was a keynote address at POPL75 republished in CACM, and (ii) despite the title it's mainly about comparing the ''social'' aspects of these related endeavors (this was his goal). If you want to read that Esperanto is like Cobol or Fortran, and that linguists squabbled in 1910 on how to construct Esperanto like ISO committees did half century later, it's an interesting read. Otherwise he mainly complains that programmers go for fads, so programming should be more like Math, and later he complains that programing languages should be more flexible like natural languages. Not particularly deep. I can send the paper to you if you want. [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 22:22, 2 September 2009 (UTC)
::I was expecting to find some good insight about language design from the man half-responsible for the [[Backus–Naur Form]]. The "programing languages should be more flexible like natural languages" certainly sounds exciting, could you send it to my gmail account? (user TuringT) Thanks [[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 22:35, 2 September 2009 (UTC)

I think the addition of a paragraph describing the similarities and differences between natural and programming languages is useful.  Thanks for adding that.  I tweaked a few words, but generally it seems to fit well where it occurs. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 01:08, 3 September 2009 (UTC)

: There are multiple statements spread throughout the article comparing natural and programing languages. Wouldn't a (sub)section be a better organization of this material? [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 09:28, 3 September 2009 (UTC)
::Probably yes. [[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 09:35, 3 September 2009 (UTC)

There is real confusion in the sentence near the beginning of the "Definitions" section that reads: "A computer programming language is a language[3] used to write computer programs." "Language" as used here is too general to mean much of anything, except the union of sets which includes programming languages and natural languages. The footnote goes to page 205 of Steven Roger Fischer's <i>History of Language</i>, but that entire book is devoted to understanding the nature of "natural" languages, and on that very page Fischer writes that "a programming language... is wholly different from all other forms of language known to humankind." At the very least the word "language" here should be deleted, the reference to Fischer made more nuanced (his entire section on programming languages is worth reading and relevant to this page and this particular topic). Since the "Definitions" section begins with "A programming language is a notation for writing programs, which are specifications of a computation or algorithm," more specific and more accurate, I'm not sure what good this sentence does in any case. [[User:Wichitalineman|Wichitalineman]] ([[User talk:Wichitalineman|talk]]) 22:28, 11 February 2013 (UTC)
:A programming language is actually a [[formal language]] that is equipped with some semantics. That Fischer reference made no sense. I think I fixed it. [[User talk:Hans Adler|Hans Adler]] 23:01, 11 February 2013 (UTC)
::My issue is with the phrase that remains, "a programming language is a language." If "language" is taken to mean "natural language," then this is wrong. This is an old debate in linguistics and programming language design and you'd be hard-pressed to find linguistic support for the phrase as it currently exists, not least because programming languages (and formal languages) are generally writing systems whereas natural languages are spoken first and foremost (many of the world's ~6000 natural languages have no writing systems at all). "Notation," in the preceding sentence, is better, since it means system of writing. I don't actually think removing Fischer was a good idea, as he tries to explain the issue, but what he says is not reflected here. [[User:Wichitalineman|Wichitalineman]] ([[User talk:Wichitalineman|talk]]) 21:32, 16 February 2013 (UTC)
:::I think in this context it may be best to think of the word language as used in a very loose sense that generalises both natural and formal languages, or even as a metapher. [[User talk:Hans Adler|Hans Adler]] 22:28, 16 February 2013 (UTC)
::::That's how it's being used, but that obscures rather than clarifies, and the goal of Wikipedia is clarity. To the general reader, it may imply "natural language," which would be false. [[User:Wichitalineman|Wichitalineman]] ([[User talk:Wichitalineman|talk]]) 21:19, 18 February 2013 (UTC)

=== Non-Procedural Programming Languages ===
This article seems to have a real bias toward procedural PLs, e.g. Fortran, PL/I, etc., and excludes non-procedural languages, which may satisfy all of your criteria of what constitutes a PL. 
The one in particular that I have in mind is IBM's CMS Pipelines, a/k/a Hartmann Pipelines.
I have personally use Pipelines to implement solutions to large and difficult problems on a computer.
What is there about Pipelines that makes it NOT a programming language?
And yet allows Prolog?
[[User:Dav4is|-dav4is]] ([[User talk:Dav4is|talk]]) 21:19, 6 May 2013 (UTC)
:It has a bias towards major languages, and CMS Pipelines is too obscure to be included with [[WP:DUE|due weight]] to the topic - the article can't just contain ALL languages that someone wants to mention, and that doesn't mean that they're not considered languages. Several non-procedural languages are included (Haskell, Prolog, arguably ML and APL) and they're recognized as languages just fine. A mention of CMS Pipelines would be more adequate at [[Dataflow programming]] than here. [[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 22:21, 6 May 2013 (UTC)

== Understandable by humans ==

The phrase "understandable by humans" is used by Pascal Lando, Anne Lapujade, Gilles Kassel, and Frédéric Fürst, ''Towards a General Ontology of Computer Programs''.  Having skimmed the article, I understand the hyper-technical classification they are trying to do in formal ontology (which BTW, means something related, but still quite different, in computational linguistics than it does in philosophy... I have a doctorate in the latter, and have had jobs in the former).  However, this one-off special meaning given in that article has very little, if anything, to do with the general usage of the terms "computer language" or "programming language".  Just as a citation, it's harmless (but probably not all that relevant), but we should definitely not include its oddball classification in the article text. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 19:59, 3 September 2009 (UTC)

:Just saying "X is a strict subset of Y" is meaningless in this context unless X and Y have some definition. So, for any cited declamations that "foo languages are bar languages" we need to detail (as briefly as possible, of course) what the cited authors understand by "foo languages" and "bar languages". There's no a priori common sense of foo and bar here. It was easy enough to explain concisely Narasimahan's paper: computer languages are finitary programming languages, where programming languages express computation on abstract machines -- I did not repeat/state the last part since it's exactly the same def as used in the paragraphs above it in the our article.

: Now, there's nothing deeply technical about the paper of Lando et al. Most ontology papers are full of fluff, and this one is no exception. The whole ontology of computer/programming languages is in half a column in section 3.3, and doesn't require any of the stuff in the rest of the paper to understand. They define:
:* Computer languages - those [[formal language]]s designed for interpretation by a computer (microprocessor)
:* General Purpose Computer Languages (GPCLs) - Turing-complete computer languages dedicated to the writing of all kinds of programs
:* Programming languages - all GPCLs that are understandable by humans
:The distinction between GPCLs and programming language is rather dubious, but it's not of much concern to us. If you read the ontology backwards, it gives "Programming languages are those Turing-complete computer languages dedicated to the writing of all kinds of programs, and which are understandable by humans." The purpose of programming languages appeared unnecessarily verbose to repeat, as it's not different in Lando et al. from that stated in the paragraphs of this wiki article that precede the citation. The novel(?) idea here is indeed the requirement that a programming language be something that humans understand. I don't see how this is outlandish. It is not that different from your view, just states what the [http://www.google.ro/search?hl=en&q=define%3Aspecific+difference specific difference] is. Without a specific difference, the statement that "programming languages are computer languages" conveys almost zero information, since the subset of computer languages called programming languages may well not be proper, and the reader is left guessing as to what the distinction between these notions is in Lando's view. If you can express the above in a concise manner that does not omit the specific difference, please do so.

: Sadly, Lando's paper is the only source produced by editors above to support that "programming languages are a strict subset of computer languages", and which defines the notions involved. The other source (Bajpai 2007, cited immediately after this one in the article) only says that markup languages are computer languages, and that they are not programming languages because they have a "different goal than creating a program". But this does not imply that programming languages are a subset of computer languages; they might as well just intersect them. It requires too much [[WP:SYNT]] to infer either case from Bajpai's declamations, plus this kind of book aimed at newbie programmers does not bother defining any of the concepts we care about in this context, like what Bajpai understands by computer or programming language.

:If you can find a better source... [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 23:27, 3 September 2009 (UTC)

== Perl "proofs" ==

I'm rather uncomfortable with those references, and the statement that the "grammar is Turing-complete" does not describe the problem well, because the actual issue is that the grammar can change! Those aren't exactly peer-reviewed papers, and the authors make unclear statements, which have been [http://lambda-the-ultimate.org/node/3564 pointed out on LtU]. The way that proof needs to be understood is that in perl the parsing rules (grammar productions) may be altered by the program being parsed. That's not the same thing as perl having an [[unrestricted grammar]], which is probably what was meant by "Turing-complete" here. So, parsing perl in the general case essentially entails executing the program just obtain the full grammar for particular perl program. That's my reading of the "consensus" on LtU on that "paper", but there are some that disagree with this interpretation.  This is pretty iffy material. Probably a ref on Lisp would be more adequate since it's easier to explain that macro expansion may not terminate in Lisp, so the compilation phase may not finish.{{fact}} [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 00:29, 6 September 2009 (UTC)

Probably the most coherent commentary [http://lambda-the-ultimate.org/node/3564#comment-50578 was]:
{{cquote|Although it is not made abundantly clear, presumably the decision problem here is the membership problem for Perl programs.

Unfortunately I too have very little idea about Perl, but I think the author is arguing that the syntax of a given Perl program depends on the execution of arbitrary Perl and, importantly, the execution of the Perl sometimes results in a syntactic construction that is a member of the class of Perl programs and sometimes results in a construction that is not. Hence, the membership problem for the class of Perl programs is undecidable.

Having some kind of additional construction in the parse tree, as suggested elsewhere in this thread, would be useful for static analysis, but it would not rescue the situation. It is impossible, if we believe this proof, to decide the validity of (the syntax of) a Perl program.}}
In his sense, the grammar of perl is indeed unrestricted. However, the claimed proof on perlmonks doesn't give code where the syntax may be invalid based on program input (or some random variable), only one where it differs (but is still valid) based on the outcome of some Turing machine. [http://www.modernperlbooks.com/mt/2009/08/on-parsing-perl-5.html This guy (chromatic)] gives however such an example using BEGIN to force execution of a snippet of code during compilation, which depending on a random variable may or may not give a syntax error later during the parsing of the rest of the code. [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 00:58, 6 September 2009 (UTC)
:You could give its placement in the [[Chomsky hierarchy]] instead. Not that I know where it would go. --[[User:Cybercobra|<b><font color="3773A5">Cyber</font></b><font color="FFB521">cobra</font>]] [[User talk:Cybercobra|(talk)]] 01:23, 6 September 2009 (UTC)

::I agree with Pcap above that inasmuch as we need to mention the issues of computational grammars at all (which is not clear to me), the Lisp macro example is clearer and better documented than the Perl case. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 07:19, 6 September 2009 (UTC)
:: This is not entirely clear because there's no clear definition of a valid Perl program. Is a Perl program that has BEGIN block that loops forever a valid Perl program? What if it has an "obvious" syntax error in the rest of the code? I put obvious in quotes because the parser will never get to the error. So there are two ways to see this. If a Perl program that has a non-terminating BEGIN block is considered ''invalid'' Perl program (regardless of what comes after), then the Perl grammar is type-0, aka [[unrestricted grammar]] aka in class [[RE (complexity)]], because there exists a Turing machine that parses any valid Perl program, but may not finish on invalid ones. On the other hand, if you consider a non-terminating BEGIN block a ''valid'' Perl program, then you're not guaranteed that the parser will terminate even on valid programs, so the [[formal language]] of Perl programs is outside the Chomsky hierarchy in the class [[ALL (complexity)]]. Exactly the same observation applies to Lisp programs using non-terminating macros. [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 19:24, 10 September 2009 (UTC)

::I really don't think that this example can be suitable for this article. You cannot show an example and then even solve it on Wikipedia. It looks odd [[User:Budugoo|Budugoo]] ([[User talk:Budugoo|talk]]) 03:30, 21 October 2010 (UTC)

== Automated archiving? ==

Can someone knowledgeable in that set it up? The last manual archive is from nearly two years ago, and a lot of the 2008 discussions are no longer pertinent to the current article. [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 10:59, 11 September 2009 (UTC)

== Recent change to generations ==

I'm a little concerned about [http://en.wikipedia.org/w/index.php?title=Programming_language&diff=315719144&oldid=315001969 this change] and similar changes to [[Programming language generations]]. They're entirely sourced from http://psychology.wikia.com/wiki/Computer_programming_languages. I'm not very familiar with the issue, but it does appear to me [[WP:UNDUE]] or even [[WP:OR]]. [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 15:17, 23 September 2009 (UTC)
:Sorry, but I'm rather confused. The material was replaced to soften its dependence on unsourced material, yet you've undone the change to make it more reliant on unsourced material. The reference to the article you question isn't mentioned on this page, but is in the material on the proposed [[Programming language generations]]. However the questionable source only supports the claim that the prior view is held by some authors. I thought that finding support for its retention, even if weak, would be better than removing it entirely. The edit to this page [[Programming language]] better conforms to the view  described as "Historical" on the [[Programming language generations]] page, which is fairly heavily sourced to nine other papers published in reputable journals, mostly by experts in their fields. I quite believe the replacement is fully consistent with that material, but also happens (in an NPOV sort-of way) to be consistent with the earlier unsourced material. Have I convinced you to re-instate the changes made on this page? If not, what can I make clearer? I had considered re-copying the references from the [[Programming language generations]] page to the [[Programming language]] page, but that had seemed overkill, since this one refers to that one. However, if that's what should be done, it's easy enough.[[User:CSProfBill|CSProfBill]] ([[User talk:CSProfBill|talk]]) 16:45, 23 September 2009 (UTC)
:: "However the questionable source only supports the claim that the prior view is held by some authors." The wikia source is the only source for the the alternative/new view. Unless more authors support that view it seems entirely [[WP:UNDUE]] (or even [[WP:OR]]) to put in doubt here the traditional/prior categorization by generations. (See the three-bullet list at [[WP:UNDUE]].) [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 17:01, 23 September 2009 (UTC)

This discussion appears to be happening in the wrong place, primarily. The concern addressed seems to be about whether the article [[Programming language generations]] contains original research.  As far as it goes, that other article seems pretty well cited, though it has stylistic problems as of right now.  However, for this talk page, let's only discuss the pretty narrow stylistic change made and reverted on this article, not the citation quality of a linked article. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 17:23, 23 September 2009 (UTC)
: The "stylistic" change here was changing "that is, the [[First-generation programming language|first generation language]] " to "viewed by some to be [[Programming language generations|a first generation of languages]]" and so forth. The weakening of the claim is entirely and indirectly based on that wikia source (via the sub-article). Hence my revert. [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 17:29, 23 September 2009 (UTC)
:: I don't understand what wikia article you are mentioning, or why.  Wikia is definitely not a [[WP:RS]], but it also doesn't occur here, so that seems moot.  On the stylistic matter itself, I agree that "viewed by some" is unnecessarily mealy-mouthed, and the simple statement is much better. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 17:37, 23 September 2009 (UTC)

::: The one <s>[[Programming_language_generations#More_Recent_View_of_First_Three_Generations|cited here]]</s> that [http://en.wikipedia.org/w/index.php?title=Programming_language_generations&oldid=315723499#More_Recent_View_of_First_Three_Generations was cited here]. [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 18:46, 23 September 2009 (UTC)

::I'm happy to accept any other phrasing. The problem is simple. The prior text relies on unsourced material. The sourced material (e.g. Grace Hopper) supports the notion that the machine language programs are NOT written in first-generation programming languages. However, according to the existing (unchanged) [[first-generation programming language]]s, which is the origin of the similar statement on this page, they are. What is the preferred way to deal with the prior text, which already exists also elsewhere, is unsupported, but may be supportable? The changes I made to the claims were supported (except for the claim that someone held the view that the prior (unsourced) text espoused). As it stands without reintroducing the change I made, the current claims are unsourced, and there are other well-sourced opinions making contradictory claims, which are consistent with the text I had put in.[[User:CSProfBill|CSProfBill]] ([[User talk:CSProfBill|talk]]) 18:07, 23 September 2009 (UTC)
::: I see. I misunderstood what you were trying to do. Let me mull this over a bit, and see if there's a reasonable source that considers assembly languages first generation. If not, this article needs to be changed to reflect what is verifiable rather than trying to support what's already written by circular referencing (the wikia article was copied from here). [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 18:45, 23 September 2009 (UTC)
::: Quick note: the current text in ''this'' article on language generation seems indeed entirely unsourced. The reference given in that paragraph is an O'Reilly poster which does ''not'' divide the languages in generations. [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 18:56, 23 September 2009 (UTC)
::: However, the view that <s>assembly</s> machine code is a 1GL, and that macro assembly is 2GL, which is used in this article ('''''edited''''' 19:16, 23 September 2009 (UTC)) can be sourced, e.g. from [http://books.google.com/books?id=QGPHAl9GE-IC&pg=PA435&dq=assembly+first+generation+programming+language+1GL#v=onepage&q=assembly%20first%20generation%20programming%20language%201GL&f=false this book]. [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 18:58, 23 September 2009 (UTC)
::: So, I think it's best we hammer out this stuff at [[Programming language generations]], and ''then'' write a [[WP:SUMMARY]] here. I don't have a lot of time on hands today though... [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 19:00, 23 September 2009 (UTC)
::: I'm sorry if I didn't explain this clearly. Happy to move the discussion there and let it sit for a little bit - after tonight I also get short on time again since I've neglected other things to spend time writing and finding sources for the material that I didn't move from the other wikipedia pages. Please note that the issue is that ''machine languages'' were claimed to be first generation in the old text but (according to Hopper) that wasn't programming. Authors like Nauer saw ''assembler languages'' as forming a "new epoch". This gave rise to the "first generation", which the old text claims as "second", etc. The Rico reference has a good overall picture. What I couldn't find was anyone until the recent material, e.g. in the current wikipedia pages, that advocates the view that's used there. But it must have come from somewhere. So the issue is finding, for example, a reliable source for treating machine languages as first generation to replace the weak source with a stronger one. Or perhaps we should just replace the weak reference with "citation needed"? But it's a shame to leave the changes to the summary on this page go unmade since they don't even refer to the troublesome source? Thanks. [[User:CSProfBill|CSProfBill]] ([[User talk:CSProfBill|talk]]) 19:08, 23 September 2009 (UTC)
:::: Yeah, I contributed to the confusion by writing something else above that what's written in that book and in this article. I've corrected it now. But the book ''does'' support the current text in ''this'' article and the unsourced 2nd part in [[Programming language generations]]. [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 19:18, 23 September 2009 (UTC)
::::: Thanks for finding that. Part of the reason I wrote the "generations" page in that form was that these two, contradictory, namings seem to appear in the literature, and although I couldn't find a source, I presumed that the existing description was good. I would soon hope to replace the first-, second-, and third-generation pages with redirects to this comparative page. Thanks again. [[User:CSProfBill|CSProfBill]] ([[User talk:CSProfBill|talk]]) 19:29, 23 September 2009 (UTC)
:::::: I don't concern myself much with this kind of categorization issues. Presumably, in this article we should use the view that's commonly found in current textbooks (assuming they even agree), but I don't have a strong opinion on this. [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 19:33, 23 September 2009 (UTC)
::::::: But in the light of the Rico reference (Rico, DF; HH Sayani, RF Field (2008). "History of computers, electronic commerce and agile methods". Advances in Computers (Academic Press) 73: Emerging Technologies), even current texts use both sets of names, hence my attempt to put on this page a text that got the gist of the history in, but avoided actually tying it to the generation names, which is off on the other page. [[User:CSProfBill|CSProfBill]] ([[User talk:CSProfBill|talk]]) 19:44, 23 September 2009 (UTC)
:::::::: If there's no agreement, by all means, mention both schemes. I don't even see the three generations of PLs defined in that [http://books.google.com/books?id=Zf5MlsaAmNgC&pg=PT13&dq=%22History+of+computers,+electronic+commerce+and+agile+methods%22#v=onepage&q=%22History%20of%20computers%2C%20electronic%20commerce%20and%20agile%20methods%22&f=false Rico et al. ref] though. Only computers are split in 4 generations. [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 20:32, 23 September 2009 (UTC)
::::::::: The diagram I was referring to is on page 5, through the book at http://books.google.com/books?id=Zf5MlsaAmNgC&pg=PT13&lpg=PT13&dq=%22History+of+computers,+electronic+commerce+and+agile+methods%22&source=bl&ots=1kDBkhzlAH&sig=zK2lS-IRySSxahoqwMsSzJW-lUg&hl=en&ei=aYe6SsDzKcagjAfos8j6BQ&sa=X&oi=book_result&ct=result&resnum=3#v=onepage&q=%22History%20of%20computers%2C%20electronic%20commerce%20and%20agile%20methods%22&f=false . The second row apportions the programming languages into generations, but perhaps I read too much into it while looking for a reference more modern than the 1980's.  But still, I still think that a more neutral point-of-view is needed on the PL page if generations differ on terminology. Given how many of us "old-timers" are still around, I suspect other references can be found.[[User:CSProfBill|CSProfBill]] ([[User talk:CSProfBill|talk]]) 20:53, 23 September 2009 (UTC)
:::::::::: I think you're misreading the diagram. The generations in it refer only to computers. Otherwise we'd have 3rd and 4th generation operating systems, but no 1st and 2nd etc. There's no mention of programing language generations on page 6. [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 21:01, 23 September 2009 (UTC)
::::::::::: Plus, the factual accuracy of that paper is a little doubtful. It says for instance that 2nd generation computers, like [[IBM 7090]], did not have an operating system, but [[IBSYS]] is considered one, albeit very primitive (not a time-sharing system, tape-based etc.) IBM 7090 could also run [[BESYS]], which was a time-sharing system. [[User:Pohta ce-am pohtit|Pcap]] [[User_talk:Pohta ce-am pohtit|<small>ping</small>]] 21:22, 23 September 2009 (UTC)
:::::::::::: On the issue of rephrasing the paragraph to a more neutral viewpoint, I propose waiting a week or so to see whether other editors voice views (I'll keep an eye on the second-generation page as well because that's where discussion to merge them and to include the historical POV was also voiced before I started. Then I'm happy to propose a more neutral rephrasing - what's the best way to do that - put the text here in the talk which makes citations difficult or put it there on the page which makes subsequent changing easier? I would prefer to do the latter only because it's easier, but I'm happy to go either route. I will explain the rationale for the changed phrases here in the talk.
:::::::::::: As side-chat, I remember IBSYS, which wasn't really primitive for its time. When I was at MIT then, the Comp. Center ran FMS (the Fortran Moitor System), which was far more primitive than IBSYS, but was a better basis for [[CTSS]], which ranks with [[BESYS]] and [[Atlas Computer (Manchester)|ATLAS]] as the first time-sharing systems. My recollections run more along the lines of Ben Meadowcroft's (at http://www.benmeadowcroft.com/reports/corbato/) about the relative roles of [[Compatible Time-Sharing System |CTSS]] and BESYS in the creation of [[MULTICS]]. [[BESYS]] went through evolution and the 1957 date I have occasionally seen is 2 years before the first [[IBM 7090]] installation. (CTSS first ran on the [[IBM 709]]). But the real pivot for time-sharing was the introduction of disk storage, which I think was an IBM 353 for CTSS - managing swapping on tapes was no fun.[[User:CSProfBill|CSProfBill]] ([[User talk:CSProfBill|talk]]) 11:09, 24 September 2009 (UTC)

I doubt that my unsourced opinion means much here, but as an erstwhile expert in the field, the whole notion of grouping programming languages into "generations" is a lot of garbage from a technical point of view.  I don't know of a single academic programming language expert who takes such "generational" classifications seriously. [[User:K.lee|k.lee]] ([[User talk:K.lee|talk]]) 05:54, 11 August 2010 (UTC)

== reverting a bad revert ==

In [http://en.wikipedia.org/w/index.php?title=Programming_language&curid=23015&diff=401963181&oldid=401674017 this edit], someone reverted the work of another editor, claiming it was not correct. As far as I can tell, they were wrong about that.  So I'm reverting their revert. [[User:Kragen|Kragen Javier Sitaker]] ([[User talk:Kragen|talk]]) 23:05, 12 December 2010 (UTC)

== How does a programming language compare and contrast to a natural language ==

Humans must be able to agree on the behavior of a computer program.  A programming language has no value unless a human can perform the steps of computation in their head.  In order to write a program, a human must be able to conceptualize what the code does.  True, code can be generated by machine, and in a way that obfuscates, but a human can still work through that code, performing each step themselves, to see what it does.  Obfuscated code makes that more difficult, but that's not a fundamental point.  A programming language still must be simple enough and precise enough for humans to agree on the behavior of a particular program.

So the question is how a programming language compares and contrasts to a natural language.  When a human reads symbols of a program, they give behavior in their mind.  So how does that differ from a natural language?  Well, the real world, and the natural languages that describe it, is complex.  Statements in natural languages have ambiguity and people often argue about whether those statements correspond to the world outside our heads.  We are doing so on this very page.  In contrast, a programming language defines an artificial world that is much simpler than the real world.  So simple, in fact, that statements in a programming language have precise behavior that all people agree upon, and a machine can be constructed to carry out.  That simplicity of the artificial world, which has state and things that change state, that simplicity is the essential difference between a natural language and a programming language.

It's an important concept, and should not be left out of the article.  It's especially important for non-CS people, for example kids who are curious what a programming language is.  This puts things into perspective for them, saying how a programming language is different from a language people use to talk about the real world.[[User:Seanhalle|Seanhalle]] ([[User talk:Seanhalle|talk]]) 09:39, 28 June 2013 (UTC)

:This is about the new paragraph added to the lead section, I assume:
::''<nowiki>[Programming languages]</nowiki> are distinguished from natural languages by the fact that they define an artificial world that is simple enough to define precisely. In general, this enables a human to perform the actions indicated by the symbols of a program in their mind and arrive at the same resulting world-state as any other human, or machine, that performs the same actions. For well defined programming languages, the correct resulting world-state of an individual action can be proven formally.''
:I must confess that I am not happy with the exact wording of this section insofar as I think speaking about a precisely defined "artificial world" and about "world states" is somewhat misleading. It is true that specifications of programming languages quite often refer to abstract machines (abstractions of concrete hardware) to specify the semantics of programs encoded in the language, see [[operational semantics]], and that especially imperative languages quite strongly suggest that programs be interpreted in terms of changing world states. At the same time, not every syntactically program is meaningful in the sense that e.g. the relevant language specification may deliberately leave certain aspects undefined. So, in that sense, the "artificial world" mentioned is not defined precisely, or at least not fully defined. But perhaps you would say that these languages are not well defined.
:When reading a program written in a functional style I don't think in terms of changing world states at all. I agree with the general idea of what the paragraph says and with what you wrote above, namely that both humans and machines have to be able to interprete computer programs, and consistently so. I just think that we have to be careful not to mislead the reader into thinking that every programming language is imperative. But perhaps I am reading too much into that paragraph.
:— [[User:Tobias Bergemann|Tobias Bergemann]] ([[User talk:Tobias Bergemann|talk]]) 20:55, 24 June 2013 (UTC)
These days many programs are automatically generated by computers.  Also there are language families that are not based on using state as a method of getting things done e.g., [[functional programming]] and [[declarative programming]].  [[User:Derek farn|Derek farn]] ([[User talk:Derek farn|talk]]) 11:12, 25 June 2013 (UTC)

: How about the text in the next paragraph..  it was expanded to take into account the criticisms.  The point about such a paragraph is that *non CS people* also read wikipedia.  It is up to us to write something that gives them intuition about programming languages.  Pedantic insistence on exact details is good, but in the body where there is space to use enough words to get all the details exact to the satisfaction of the few of us who argue over them.  However, in the introduction, the sparsity of words requires statements that give the _intuition_ without the verbosity of exactness.  That verbosity and careful wording is required by more advanced aspects and by exceptions to the rule (an example apropos here is the comment about machine generated code -- a human still must understand the meanings of statements in the programming language, even in the case of machine generation.. it's an exception and subtlety that masks the intuition that humans must be able to read and agree on what the elements of a programming language do).  Such careful wording either precludes any statements at all in the introduction that touch on the concepts, or else require difficult to parse statements filled with caveats that hide the intuition.

Here's the proposed paragraph

A programming language does not describe things in the real world, as a natural language does. Instead, it defines an artificial world whose basic elements are things like integers and objects. A program then describes things in terms of those basic elements. A physical machine translates actions in that artificial world into actions in the real world. For example a desktop computer translates an integer into a pattern of light that a human's eyes perceive as a number. The translation provides the value for humans. The simplicity of the artificial world allows one to precisely specify the state of that world and actions within it. The precision and simplicity makes it possible for humans to agree on the state and behavior within that world, and a machine can be constructed that also agrees. Programming languages are useful because the real world and natural languages are too complex for such precision and agreement. (Just taking a look at the talk pages on wikipedia illustrates the difficulty in agreement!)[[User:Seanhalle|Seanhalle]] ([[User talk:Seanhalle|talk]]) 09:39, 28 June 2013 (UTC)

:Let's work on something here first rather than adding a large chunk of stuff to the introduction of an important article.
::Agreed, and please try to be constructive, as opposed to obstructionist, by actually writing things that would satisfy you.  It is too easy, and gives too much power to simply say "no" and throw up road blocks that impede progress.[[User:Seanhalle|Seanhalle]] ([[User talk:Seanhalle|talk]]) 09:39, 28 June 2013 (UTC)

:Some languages do describe things in the real world, so called [[domain specific languages]] can have a direct mapping to real world entities.  More general purpose languages tend to be more abstract and require greater effort to map from the concepts they support to the model of the real world being handled.  Isn't this kind of discussion more appropriate for a computer programming article? [[User:Derek farn|Derek farn]] ([[User talk:Derek farn|talk]]) 10:45, 26 June 2013 (UTC)

::I hear what you're saying, but would state, rather, that the two languages simply use the same names, but those names refer to very different things.  In the DSL, the name refers to an artificial entity that consists of integers, floating point numbers, and pointers.  It is still up to the machine and people to translate from the integers, floating point numbers, and pointers into into something in the real world.  The DSL and the natural language may use the same set of characters, but the DSL characters refer to a collection of artificial things, while the natural language characters refer to a real world thing.[[User:Seanhalle|Seanhalle]] ([[User talk:Seanhalle|talk]]) 09:39, 28 June 2013 (UTC)

:The above text was changed by [[User:82.139.115.35|82.139.115.35]]&nbsp;{{#iferror:{{#expr:82.139.115.35 round 0}}
  |<!--IPV6-->{{toolbar|separator=dot
    |1=[[User talk:82.139.115.35|talk]]
    |2=[[Special:Contributions/82.139.115.35|contribs]]
    |3=[http://toolserver.org/~overlordq/cgi-bin/whois.cgi?lookup=82.139.115.35 WHOIS]
  }}
  |<!--IPV4-->{{toolbar|separator=dot
    |1=[[User talk:82.139.115.35|talk]]
    |2=[[Special:Contributions/82.139.115.35|contribs]]
    |3=[http://toolserver.org/~overlordq/cgi-bin/whois.cgi?lookup=82.139.115.35 WHOIS]
  }}
}} (<span class="plainlinks">[{{#if:Talk:Programming language
 |{{fullurl:Talk:Programming language|{{#if:561650473
  |diff=561650473&
 }}oldid=561649034}}
 |{{SERVER}}{{SCRIPTPATH}}/index.php?title={{#if:561650473
  |&diff=561650473
 }}&oldid=561649034
}} diff]</span>). I assume that this is the same wikipedian as the original author, {{User-multi
 | User      = Seanhalle
 | Project   = 
 | Lang      = 
 | separator = dot
 | 1         = t
 | 2         = c
 | demo      = 
 | doc       = yes
}}. Please have a look at [[Wikipedia:Talk page guidelines]]. It's really rude to change comments after others have replied to them. — [[User:Tobias Bergemann|Tobias Bergemann]] ([[User talk:Tobias Bergemann|talk]]) 13:11, 26 June 2013 (UTC)

:My apologies, Tobias.  I felt my wording was itself rude, and set a poor example, so wanted to tone it down, without changing the heart of the meaning. [[User:Seanhalle|Seanhalle]] ([[User talk:Seanhalle|talk]]) 09:39, 28 June 2013 (UTC)

I'm sure there must have been some comparisons between programming and natural languages published previously in the literate. In the interest of verifiability, neutrality, accuracy and not turning this article in something that looks like someone’s personal essay it would probably be best to do a literate review first and then base any such comparison on those results. —''[[User:Ruud Koot|Ruud]]'' 16:16, 26 June 2013 (UTC)

:Ruud, that sounds like a good idea.  Some citations would be welcome.[[User:Seanhalle|Seanhalle]] ([[User talk:Seanhalle|talk]]) 09:39, 28 June 2013 (UTC)

Seanhalle, as [[User:Ruud Koot|Ruud]] has pointed out your various suggested additions read like someone’s personal essay, so the style needs to change.  The material covers how a particular kind of language might be used, but there are lots of languages that are not used in that way; however there are lots of developers following the usage you describe and so it is significant enough to warrant being included in an article.  Is the programming language article the best place for this kind of material?  What about the article on [[computer programming]], this ought to say something about how a language is used to get something done.   [[User:Derek farn|Derek farn]] ([[User talk:Derek farn|talk]]) 11:23, 28 June 2013 (UTC)

:Derek, the motivation is that my son looked at this page and still had no idea what a programming language was, even though he writes code in 3 different programming languages.  There's something very wrong with that.  The explanation in the paragraph I put up on the site opened his eyes and made the rest make sense.  I can't escape the feeling that you have been so immersed in programming languages for so long, that you've lost the ability to see from an outsiders perspective.  People come here, to this wiki page, in order to understand just what a programming language is.  And they come from the perspective of understanding what a natural language is.  What the page has now is technically correct, but lacks intuition that relates a programming language to a natural language.  It lacks a way to put programming language into perspective for them, and to relate, compare, and contrast a programming language to something they know.  Just because its not a way of thinking that you're used to doesn't mean it doesn't belong here, but rather more likely indicates that you have become unable to see things from the point of view of someone who doesn't yet know all of the things you know.  That makes you a poor choice for deciding what is valuable to such outsiders.

If you're wondering about my background, you can read about my work on parallel programming languages at http://opensourceresearchinstitute.org  It includes papers that cover theory of computation and theory of parallelism, focused on the basic structure and how that can be used to understand the interaction of language design, runtime system choices, and hardware.  

I also teach a graduate course on the design of parallel programming languages, which includes a survey of current parallel languages, and analyzes them in terms of properties related to portability, productivity, and adoptability. You can draw your own conclusions about my qualifications on the subject of programming languages, and the ability to teach about them.[[User:Seanhalle|Seanhalle]] ([[User talk:Seanhalle|talk]]) 02:48, 29 June 2013 (UTC)

:Sean, I understand the problem of articles not being easily digestible by casual readers, its something that I encounter surprisingly often when using Wikipedia.  An article's introduction is of necessity brief and to the point; there is plenty of opportunity to expand on the issues in the subsequent sections.

:While everybody can use a natural language fluently I doubt if many of them have any great understanding of human languages and their characteristics; a native tongue is just something people can use without having to think about how it works.  Philosophers seem to have managed to get themselves into plenty of tangles discussing such things as [[structural linguistics]] (I am a fan of [[cognitive linguistics]] myself).

:I think an article on how programming languages are used to solve problems would be great and that a summary of such an article would make a good additional subsection. to the programming language article.  [[User:Derek farn|Derek farn]] ([[User talk:Derek farn|talk]]) 16:48, 29 June 2013 (UTC)

== Caption of java program ==

The caption states: [..] which will print the message "Hello World!" to the standard output when it is compiled and executed.

I'm sure we all know that is statement is not quite true, although Java is compiled to bytecode, it's still only readable to the JVM. I think we could clarify this point; perhaps adding 'executed by the JVM'.

Suggests on how to clarify the above statement would be great.

The statement also isn't true in the sense that this code alone will not actually print the message to stdout when it is run, since it lacks a main method. In fact, it won't even compile without main(). Not sure if the caption alone should be changed, or if the article needs a better (functioning) example.  <span style="font-size: smaller;" class="autosigned">— Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[Special:Contributions/24.61.84.253|24.61.84.253]] ([[User talk:24.61.84.253|talk]]) 17:03, 7 July 2014 (UTC)</span><!-- Template:Unsigned IP --> <!--Autosigned by SineBot-->

== Programming paradigms are missing in the abstract ==

[[paradigm]]  <span style="font-size: smaller;" class="autosigned">— Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[Special:Contributions/79.204.117.100|79.204.117.100]] ([[User talk:79.204.117.100|talk]]) 16:01, 2 November 2013 (UTC)</span><!-- Template:Unsigned IP --> <!--Autosigned by SineBot-->

: Good point!  Got the lead section slightly expanded, so it is now mentioned. -- [[User:Dsimic|Dsimic]] ([[User talk:Dsimic#nobold|talk]]) 21:52, 2 November 2013 (UTC)

== Introduction for non-CS people ==
Hello, I'd like to add a section for younger people, like my son, and for non computer people.  I think most of us who edit this page are CS or related people, and we have a hard time understanding what it's like for someone coming from outside this world..  they're not helped by fine points of interest to us, but rather need some gentle path laid out that moves from the natural world they know and guides them to see how programming languages relate to that world.

I thought it best to open a discussion here, first, and post a proposed starting point, to gain the benefit of input from you.

Here goes: proposed section title "Introduction to programming languages for non computer programmers"

What is a programming language?

In the real world, basic physics is the rules of how our universe works.  It defines state, such as atoms and sub atomic particles.  And it defines characteristics that these have, such as momentum and direction and energy.  And it defines the rules for interactions, such as forces.

A programming language does the same thing, for an artificial, or "virtual" universe.  It defines state, which are called variables, and defines characteristics of the state, such as "integer" or "floating point", and defines rules for interactions, such as "+" and "-", which are add and subtract.  Most programming languages include a way to create new rules for interaction, which are called "functions" or "procedures".

The process of writing a program involves creating a model of some part of the real world inside the programming language's artificial universe.  For example, a variable might represent a person, and a function is defined that represents the action of one person talking to another person. In the programming language, a kind of state called a "string" contains letters.  In the program, the letters in a string are grouped into words, which represent what the speaker says.  The function takes a string from one person-variable and puts it into the other person-variable, and this represents the first person saying the words in the string to the second person.  

In practice these basic concepts are at the base of every programming language.  They all have kinds of state and operations that modify state.  Ultra simple programming languages, like so called "assembly language" only have one or two kinds of state, and a small number of fixed operations that can affect the state.  Advanced programming languages allow the programmer to define new kinds of state as part of the program they write, and some even allow defining advanced "meta" operations, which treat program code as state and generate new program code!

A programming language is different from other kinds of language in that its primary purpose is to construct models within the language-defined universe, and then have a machine, such as a CPU, set those models in motion.  Sometimes the desire is for that model to interact with the real world, such as the programs inside microcontrollers used in cars to control the brakes and the engine.  Other times the desire is for the model to go as far as it can and come to a stop, then the person using it looks at the final state the model arrived at.  This final state is the answer the person wanted to compute.

The key distinguishing feature of a programming language is the ability to set the model in motion and that the motion is animated by a machine, which modifies the state according to the language's rules.  Other languages, such as human "natural" languages, have words that represent state, and words that represent modifications of the state, but the only way to set these models in motion is for a human to perform the actions of modifying the state.  There does not yet exist a way for a CPU or other machine to directly animate a model specified in terms of a natural language.  

In fact, a human programmer performs the task of translating a model stated in terms of natural language into a model stated in terms of a programming language.  The program is correct if, when the program model is set in motion, it is observed to behave the way the natural language model would.  The natural language model is called a "specification" while the program model is said to "implement the specification".  This means the program model is observed to behave the way the natural language model says to behave.

Of special note are languages used by computer programmers and others to create descriptions and non-machinge-animatable models.  For example, languages such as XML are used for describing data, but have no operations that modify the data. In addition, UML is a popular language for specifying the structure of computer programs and the behavior expected from them. It is used during the process of creating program code.  Although a model can be stated in terms of UML, these models normally can't be directly animated by a CPU.  They are rather used to help programmers understand how the models they create in program code should behave and how they should communicate with other models created in code.

[[User:Kshalle|Kshalle]] ([[User talk:Kshalle|talk]]) 21:22, 1 February 2014 (UTC)

* Hello there!  Well-written and looking good to me; that would be a perfect fit for the "Overview" section in this article.  The only thing you still need is one or two references backing the content; I know, it's all good, but&mdash;as we know&mdash;Wikipedia is all about providing reliable references. &mdash;&nbsp;[[User:Dsimic|Dsimic]]&nbsp;([[User talk:Dsimic#nobold|talk]]&nbsp;|&nbsp;[[Special:Contributions/Dsimic|contribs]]) 02:09, 2 February 2014 (UTC)

== int main ==

I suppose this won't bother anyone who is reading about programming languages for the first time, but the function "main" must return an int in C (usually 0 if nothing goes wrong). It is declared as "void main()" in the example code in the picture at the beginning of the article. This can be confusing to someone who goes on to learn C.
<small><span class="autosigned">—&nbsp;Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[User:90.190.20.114|90.190.20.114]] ([[User talk:90.190.20.114|talk]] • [[Special:Contributions/90.190.20.114|contribs]]) 16:53, 5 January 2016 UTC</span></small><!-- Template:Unsigned -->

== History ==

Re-reading the article I'm a bit surprised that the history section doesn't mention Fortran, PL/I, or Algol (that I see, I may have mised it)  Cobol gets a sentence. Also, assembler languages are programming languages and probably deserve mention. [[User:Peter Flass|Peter Flass]] ([[User talk:Peter Flass|talk]]) 17:22, 11 January 2016 (UTC)

== Issues or problems in teaching programming languages ==

what are issues in teaching programming languages

== Overview - On Baghdad ==

I saw that in the overview the language seemed a little off to me. Specifically:
* The earliest known programmable machine preceded the invention of the digital computer and is the automatic flute player described in the 9th century by the brothers Musa in Baghdad, '''at the time a major centre of knowledge.'''[1]
This wording kind of has implications and isn't really neutral. Alternatively it could say "during the [[Islamic Golden Age]]".

- [[User:LawrenceTemple|LawrenceTemple]] ([[User talk:LawrenceTemple|talk]]) 04:08, 19 August 2016 (UTC)
:I used the Gold Age variant of your idea. The context is strongly about the timeframe and advances of knowlege, so that detail isn't non-neutral, and is clearer than just a comment about the location itself. Thanks for the suggestion! [[User:DMacks|DMacks]] ([[User talk:DMacks|talk]]) 14:37, 19 August 2016 (UTC)
::That is ethnocentric, they could also say that the flying carpet was the earliest form of an airplane.
::The Chinese, per-Colombian cultures, ceased to exist during that era?
::The pro-Islamic bias is obvious. The automatic flute player is in no way related to programming languages that the article is supposed to talk about. The automatic flute is a very primitive "device" and should not be in the article. But then again, considering the Muslim-pandering with is mainstream nowadays, nothing surprises me anymore. Shame on Wikipedia administrators for allowing heavily biased BS to be published.
[[Special:Contributions/124.35.178.162|124.35.178.162]] ([[User talk:124.35.178.162|talk]]) 01:23, 21 February 2018 (UTC)
: Just so you fellas get your facts straight, the first hydraulic automated device was not invented by Muslims. The construction of the first hydraulic automata was made by Ctesibius (flourished c. 270 BC) and Hero of Alexandria (c. 10 – 80 AD). Hero describes a number of working machines using hydraulic power, such as the force pump, which is known from many Roman sites as having been used for raising water and in fire engines. 
[[Special:Contributions/124.35.178.162|124.35.178.162]] ([[User talk:124.35.178.162|talk]]) 01:36, 21 February 2018 (UTC)
:: I'm unsure what hydraulics has to do with the article, it's not mentioned anywhere in the article or elsewhere in the talk page. Somebody got a little carried away with a rant I think. Regarding pre-Columbian cultures, there is no evidence of machinery or automation, or even the wheel, although they were quite advanced in other areas (mathematics for calendars, for instance). I'm sure if an earlier Chinese reference is found, this line can be replaced, but currently the flute is the best candidate for the earliest programmable machine.  But see next section:

:Can an automatic flute player be legitimately considered "a programming language"?  For a full programming language, you need 3 things: some kind of action, a decision (if) statement, and a branch (jump) statement.  Even early HTML has decision statements, based on browser type, etc. Player pianos and weaving looms were definitely steps on the way to automation and then computers, but the instructions for a player piano do not comprise a programming language.  At best, this could be mentioned in the history section, but not the lede.[[User:Nerfer|Nerfer]] ([[User talk:Nerfer|talk]]) 20:58, 6 September 2018 (UTC)

== This article is a total mess! ==

It repeats many common places, many of them wrong!, but repeated again, and again, in many programming courses given in basic education based on outdated information. Also many "complete idiot's guide", "learn in N days" or "for dummies" like those in the photo with tech books, repeat again and again.

Many people know some programming language and write code. That does not make then an authority in the subject. However many of them feel they are.

This article seems written from notes taken in basic programming courses.

Has discussions like: How many angels can be in the tip of a needle?  <!-- Template:Unsigned IP --><small class="autosigned">—&nbsp;Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[Special:Contributions/201.124.211.115|201.124.211.115]] ([[User talk:201.124.211.115#top|talk]]) 05:53, 11 June 2017 (UTC)</small> <!--Autosigned by SineBot-->

== Defining the term "programming language" properly ==

Wikipedia currently says a "programming language" is "a formal language that specifies a set of instructions that can be used to produce various kinds of output" which is true-ish, but vague. The phrase "various kinds of output" hints at the relevant characteristic, but still doesn't pin it down. Dictionary.com defines a "programming language" as "a high-level language used to write computer programs, as COBOL or BASIC, or, sometimes, an assembly language." This gibberish dances around it for a moment... but it makes no difference whether it is the highest-level symbolic meta-language or lowest-level machine code. An alternate Dictionary.com definition starts getting closer, "a simple language system designed to facilitate the writing of computer programs" but simplicity has nothing to do with it either and this definition still doesn't capture the essence. The important nugget here is the specification of decision making. A "computer language" is any predefined set of symbols and syntax that allows people to communicate with a computer system. But a "programming language" is a language among the broader set of computer languages that specifically enables a person to specify decision-making rules. CPUs make logical (true/false) decisions. The specification of a logical decision-making process is where the rubber meets the road. As example, HTML is a computer language, but not a programming language. If I want my computer's clock to display upside down, but only on Tuesdays, I can't use HTML to accomplish that. Get it? (HTML is really just a data markup language used to specify the metadata and the semantic structure of a Web document.)

Shall I take a crack at rewriting the first paragraph on the "programming language" page and I'll let you all have a look? I won't spend too much time on it unless the community wants me to, so let me know what you think.  <!-- Template:Unsigned --><small class="autosigned">—&nbsp;Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[User:Dlampton|Dlampton]] ([[User talk:Dlampton#top|talk]] • [[Special:Contributions/Dlampton|contribs]]) 00:39, 8 January 2018 (UTC)</small> <!--Autosigned by SineBot-->
{{talkarchive}}

== Image request ==
{{<nowiki>reqimageother</nowiki>|a representative image of computer code (see [[#Article image|discussion]])}}

I have little difficulty understanding the feature specification. I may have it missed it entirely.

I see the need for artwork to match the standard form (fashion) of other articles. An image representative of 'computer code' is simple, photograph some representative structured code that displays an editing style of say indenting. That is code, and its Boring, hence appropriate?.

If the goal is a little larger, to for instance portray the archetypal process of creating a program in a computer programming language using the artistic medium, image. I would suggest an photo of an actual 80 char screen, possibly green, with individual pixels large enough to be seen, the one line of text would read "Syntax Error: redo from start". It could, if one could be thought of, include the actual text that was a classic, obvious yet confusing problem in say basic syntax. This would to me encapsulate the constant process of humans trying battle the computers rigid interpretation of the humans otherwise reasonable requests. The prior syntax error could also be the humorous "please help" instead of just the more likely but terse "help". This idea that the human has mistaken (anthropomorphised) the computer for someone that can be persuaded with politeness is the point of desperation.
If the image context was to be larger an undrunk cup of coffee and an empty pizza box would round out the stereotype as these imply both the multitude of hours spent already and yet the incompleteness of the task.

==Humans or machines?==
I think we need to point out that programming languages, like other languages, are for humans to express human ideas in.  The unique thing about programming languages is that we can automatically translate these expressions into the ones and zeros that computers use.  Still, the primary purpose that should be stressed is that these are <b>human</b> languages, for humans to express solutions in which are meant to be understandable by other humans.  Since most of the cost of software across the useful lifespan of a program is invested in enhancements and maintenance, the human-readability of programs is much more important than their nature as a "technique for expressing instructions to a computer".

''Low-level languages such as machine code are also programming languages. All programming languages are in principle both human- and machine-readable, but the relative emphasis varies.''

:I agree, the importance of producing code that can be easily understood by a human is of extremely important and must be mentioned prominently in this article. Indeed, producing readable code that other humans (and not merely computers) can easily understand is one of the hallmarks of a good programmer. But - this is accomplished mostly through adding comments in a natural human language to the source at key points, and mostly not through the direct use of the programming language itself. 
:The original and still primary purpose of a computer programming language is ''not'' communication with other humans. A programming language is ''not'' a human language in the oridnary sense of the term; even two hardcore professional programmers don't ever go to lunch and talk to each other in Java or C. Natural human languages are far better suited to interpersonal communication. Programming languages were invented for and are used nearly exclusively for the express purpose of allowing humans to easily communicate instructions to computers (and later be able to easily modify those instructions), and not for human-to-human communication. Even programming manuals frequently express algorithms as human language influenced pseudocode rather than in a real programming language.
:It's perfectly possible (and regrettably common) to write huge complex blocks of code or even entire applications that are unintelligible to anyone but the author, yet which work perfectly well when executed by a computer. A programming language is basically and fundamentally a "technique for expressing instructions to a computer." Doing so in a human-readable fashion is a big plus, of course, but it is not the fundamental purpose of a programming language, and is usually accomplished through appropriately garnishing the code with comments in some natural human language. [[User:Kwertii|Kwertii]] 09:38, 9 May 2004 (UTC)

:: FWIW, I am a programming language theorist and I would define "programming language" formally in the following manner: a ''programming language'' is a [[decidable]] [[formal language]] equipped with a [[Turing-complete]] [[semantics]]; a ''program'' is a programming language together with a member of that language. (BTW, the page for "Turing-complete" is not really, er, adequate...) This means that a language is a set of finitary strings, for which it is computable whether or not a given string belongs to it, ''together with'' a computationally adequate model, for example a mapping from each such string to a &lambda;-term, or Turing tape, or partial recursive numeric function. In my opinion, few programming language researchers would disagree with this definition as applied to formal work. However, if you want to define the popular notion of "programming language" then, yes, you might want to add fuzzy conditions like "human-readable" and so on, and maybe weaken the Turing-completeness condition to admit terminating languages like Charity. -- [[http://www.cs.uu.nl/~franka Frank Atanassow]], 24 July 2004
:::That formal definition is too constraining.  It would be a rather odd definition of "programming language" that did not count the simply-typed lambda calculus as a programming language.  Conversely, I had a colleague working on a language with an undecidable type system.  (The subtyping constraints were flexible enough to allow the user to encode Prolog programs in them.)  He had proposed various restrictions to make the type system decidable, but it seems clear to me that his language didn't become a "programming language" only when he imposed those restrictions.  So a programming language need not have a Turing-complete semantics, nor must it be a decidable formal language.  [[User:K.lee|k.lee]] 23:09, 25 Jul 2004 (UTC)

::And conversely, to determine which is more "primary" or "important"--which is worse, a programming language that humans can't read, or one computers can't read? "Most of the cost of software across the useful lifespan of a program" may be in enhancements and maintenance, but if the program weren't machine-readable, its "useful lifespan" would be zero. --Daniel.
:::A programming language that humans can't read is clearly worse.  There are plenty of useful programs that are not machine-readable.  Virtually all work by academic programming language designers begins with the development of "core" languages, which are mathematical constructs first and foremost.  The call-by-name lambda calculus is hardly primarily a tool for communicating with computers (if by "computers" you mean those beeping chunks of silicon that sit on people's desks).  I find this this machine-oriented focus kind of disheartening.  Do we not agree with the Dijkstra quote concerning astronomy and telescopes at the top of the [[computer science]] article?

::::"plenty of useful programs that are not machine-readable"--and similarly there are plenty of useful programs that are barely human-readable. That's not a good test.
:::::There is a big difference between "not" and "barely". [[User:K.lee|k.lee]] 23:09, 25 Jul 2004 (UTC)
:::: The test I have in mind is:

::::-Examine the total amount of resources that humans have put into designing, studying, and using programming languages. (Or, if you like, examine the returns on that investment.)

::::-What portion of that investment would have been made, and what portion of those returns would have been received, if no programming language had been machine-readable? I think 3% for both would be a wild overestimate.

::::-What portion of that investment would have been made, and what portion of those returns would have been received, if no programming language had been more human-readable than, say, FORTRAN? I'd guess 70% of the investment and 20% of the returns, anyway...given how badly even readable programming languages are typically used.

::::The exact numbers are obviously arguable, but that's the test I had in mind. I agree with Dijkstra, but what computer science is about, and what programming languages are for, are two different things. Computer science is not about machines, but programming languages are for controlling machines, first and foremost; if they could not be used for that they would be relegated to a smallish sub-discipline of mathematics, neither very popular nor very well-funded.

::::-Daniel.
:::::FORTRAN is already tremendously human-readable, compared to binary machine code or any number of encodings that would be adequate to the purpose of describing computation to machines.  Furthermore, I don't see too much programming language research on making languages easier to read by machines.  So this argument actually demonstrates the opposite of what you intended it to. [[User:K.lee|k.lee]] 23:09, 25 Jul 2004 (UTC)

:::Lastly, Kwertii's comments strike me as unconvincing:
:::*It is irrelevant that programmers don't speak to each other in Java.  Musicians don't speak to each other in musical notation.  Mathematicians don't speak to each other in pure set theory and first-order logic.  (Admittedly, some of them come close.)  Lawyers do not speak to each other purely in legalese. Sculpters do not speak to each other with a series of little [[statuettes]].  There are other forms of human-to-human communication besides the oral use of natural language.  Programming languages are one of them.
:::*Furthermore, although programs can be written that are often called "unreadable", they are not ''literally'' unreadable, merely ''difficult to read''.  Nor should we construe the existence of hard to read ''programs'' as evidence that the primary purpose of ''programming languages'' is to communicate with machines.  The English translation of Jacques Derrida's ''On Grammatology'' is nigh unreadable, but that does not show that deconstructionist literary theory is not a form of human-to-human communication.
:::*It is certainly ''not'' the case that programmers communicate with other programmers primarily through comments!  In fact, natural language comments are a noriously ''bad'' way to communicate precisely about a program.  Code itself is the major form of programmer-to-programmer communication.  (See the [http://www-2.cs.cmu.edu/~dst/DeCSS/amicus-brief.html amicus curiae brief in MPAA v. 2600], which argues a similar point.)
:::*Finally, as for Kwertii's claim that the "original" purpose of programming languages was to communicate with machines --- programming languages predate executable programming language implementations by at least two decades.  The lambda calculus was invented in the 1930's.  FORTRAN was invented in the 1950's. [[User:K.lee|k.lee]] 09:24, 20 May 2004 (UTC)

::::Make that one decade. The codes given to some of the first computers in the 1940's, via paper tape and the like, certainly count as programming languages, and were designed to control machines. For that matter, Babbage's punch cards were designed to control machines.

::::-Daniel.

::::''Augusta Ada Byron King, Countess of Lovelace, born December 10th 1813 ... invented the first computer programming language.'' -- [[WikiWikiWeb:AugustaAdaByron]]. I'm not sure which side of the argument this factoid supports.

----

''producing readable code that other humans (and not merely computers) can easily understand is one of the hallmarks of a good programmer. But - this is accomplished mostly through adding comments in a natural human language to the source at key points, and mostly not through the direct use of the programming language itself.''

Many people believe this. Quite a few programmers disagree very, very strongly. We believe that producing readable code is mostly through renaming, refactoring, etc. so that the name of an variable communicates (to humans) what it is, the name of a method communicates (to humans) what it does, etc.

See
[[WikiWikiWeb:TreatCommentsWithSuspicion]],
[[WikiWikiWeb:ToNeedComments]]
("Refactor the code properly and you won't need comments.")

-- [[User:DavidCary|DavidCary]] 23:36, 5 Jul 2004 (UTC)


As computers grow more complex, our ability to translate solutions into executable binary has become more abstract, enabling us to express solutions in terms of objects, templates, patterns and aspects.  Such abstractions enable a more natural translation from human needs, often expressed as "use cases", into executable solutions.  It is this trend toward greater abstraction in the expression of programming solutions that enables programmer productivity to double, despite programmers being locked into fixed biological hardware.  

If we gaze deep into the crystal ball, we see the logical extension of this trend as computers that are capable of conversing with humans and creating executable binary programs from desires or solutions expressed in pure human language. The shift away from computer-centric aspects of programming languages toward more human-solution-centric aspects will continue to be the defining characteristic of near-future programming languages.  

The "holy grail" of programming language development from this viewpoint would be the creation of a transparent interface to a computing substrate that can extract requirements from the user and instantiate an executable solution.  Of course, at this level of abstraction, there is no "programming language" any longer, merely a somewhat pedantic conversation required to define the essential complexity of the problem the user wishes to solve.

At any rate, some mention should be made of this shift from computer-centric aspects toward human-centric aspects and how this affects programmer productivity and how it will shape the role of programming languages going forward.

==language links==

(moved to [[Talk:List_of_programming_languages]])


==Possible prejudices re: "mainstream" languages==
This article seems to be written largely from the point of view of a programmer in mainstream languages.  For example, interactive use is attributed to interpreters, without considering that eg. many Smalltalk and Lisp systems have native compilers that are used interactively.  Sorry for not bothering to work this rant into a considered and balanced edit of the article.

-- han

I disagree. I don't think we need to perpetuate the prejudices of "programmers in mainstream languages" (read C/C++, Java). That would be about as stupid as rewriting the operating systems entry from the point of view of a windows user.

Anyways, someone who has a copy of 'Programming Language Concepts and Paradigms' handy, an exceedingly comprehensible book on the subject, should rewrite this article. -- Ark

==Total rewrite==

This entire section needs to be rewritten from scratch. This includes this topic plus those for the various languages and language concept articles. This is going to be a big project but I think its important. Computer programming is too much a part of modern life to be half covered in an encyclopedia so I have to agree with Ark. [[User:Rlee0001|Rlee0001]] 05:25 Jul 27, 2002 (PDT)

On another note: I would limit the list of programming languages here to just the main languages and not all the dialects. For example, there are something like 15-20 dialects of BASIC listed in the [[BASIC programming language]] page. Instead of listing all of them, one link for the entire language would suffice. If the user want's a dialect, he/she can stiff get to it from the BASIC page. Same goes for all the languages. Further, I fail to see why people are listing such obscure languages and dialects in an encyclopedia. Some languages have historical or technological significance. Others are just current brandnames for half-written freeware with a source forge page and no user base. Should "Applesoft BASIC" really get its own topic? What did it do to revolutionize the language? Did it have a particularly large user base? Did it establish any conventions which are widely in use today? If not its probably not worthy of its own topic. Even worse is articles like ibasic. This is a basic interpreter for the mac. It has no historical significance: it was just created within the last year by an ameture developer who lives in some small cottage in sweden somewhere. It gets it's own encyclopedia article? [[User:Rlee0001|Rlee0001]]

: I would propose the following:

* Make a (short) list of the most significant programming languages in history to put on the [[Programming language]] page. Annotate the list to make clear just why these language are mentioned.
* Make new article called [[List of programming languages]], where every single progamming language can be mentioned, even dialects. This page can have several different orders, such as alphabetical, but also by type (functional, OO, etc.) or maybe even a history tree (there's a good book about the history of Programming Language by Sebasta, if I'm right, you may use that as a reference).
* For those dialects/spin-offs/implementations/ports of programming languages that are never going to be more than a single-sentence article: assemble on the page of the main article ([[BASIC programming language]] here) and make a section where you mention this or, when this is getting a long list, make it a separate article.

: That's what I think would be best. I'll try and see if I can help you with some of the work you're proposing to do; there are enough other people with knowledge about the subject around, so it should be possible to get something good out of this. [[User:Jheijmans|Jeronimo]] 01:56 Jul 29, 2002 (PDT)
---
: BTW re: classifying languages by category, many languages belong in more than one category (constraint languages vs. rule-based languages vs. logic languages; and what about functional + OO languages like CLOS?)  Just to keep in mind. --[[User:K.lee|k.lee]]
----
<div class="infobox sisterproject">
<div style="float: left;">[[Image:Wikibooks-logo-en.svg|50px|none|Wikibooks]]</div>
<div style="margin-left: 60px;">[[wikibooks:|Wikibooks ]] has more about this subject:
<div style="margin-left: 10px;">'''''[[wikibooks::Wikibooks:Programming languages bookshelf|Wikibooks:Programming languages bookshelf]]'''''</div>
</div>
</div> <div class="infobox sisterproject">
<div style="float: left;">[[Image:Wikibooks-logo-en.svg|50px|none|Wikibooks]]</div>
<div style="margin-left: 60px;">[[wikibooks:|Wikibooks ]] has more about this subject:
<div style="margin-left: 10px;">'''''[[wikibooks::Computer programming|Computer programming]]'''''</div>
</div>
</div>
I have added two Wikibook links which allready have the texts which where suggested - The first link has an alphabetical and category list of languages - the 2nd link points to short introductions. I hope that helps. --[[User:Krischik|Krischik]]&nbsp;<sup>[[User_talk:Krischik|T]]</sup> 16:52, 18 September 2005 (UTC)

===Rewrite of [[User:K.lee|k.lee]]===

FYI: For some time I've been working on a ground-up rewrite of this article, because its current state does not make me happy.  It's not ready to go live, but I've finally posted my current draft [[User:K.lee/Programming language rewrite|in my user space]]. I welcome comment on my rewrite; also feel free to edit it directly.  It's taking me a long time to do the rewrite, but I plan to replace the entire current article eventually.  [[User:K.lee|k.lee]] 02:28, 27 Aug 2003 (UTC)

:The link seems to be broken. -- [[User:Doradus|Doradus]] 11:05, 27 Aug 2003 (UTC)

::It appears to me as a red "edit" link rather than a regular blue link. -- [[User:Doradus|Doradus]] 21:49, 28 Aug 2003 (UTC)

::: is there a reason that javascript isn't mention in the " Commonly Used Languages"? Also the link is red for me too ... [[User:Reddi|reddi]] 21:58, 28 Aug 2003 (UTC)

::Ok, the link works now. -- [[User:Doradus|Doradus]] 00:03, 1 Sep 2003 (UTC)

:: I'm not sure I like the rewrite.  I haven't read the original to compare it, but the rewrite seems to be at a very awkward level of detail.  Anyone with enough background in the area to understand that writeup presumably doesn't need to read it.  For instance, the grammar example casually uses the terms "atom" and "symbol" which have very little meaning to those outside the field of computer programming.  In fact, the whole section on grammars would be better off in another article (say, on parsing). -- [[User:Doradus|Doradus]] 00:10, 1 Sep 2003 (UTC)
:::Actually, I think that when I get to editing this article some more, I'll factor out several sections (e.g., the history of programming languages, and language semantics) into separate articles.  I'll keep your suggestion in mind.  [[User:K.lee|k.lee]] 02:07, 2 Sep 2003 (UTC)
----

The link seems to be working now. :-)

I would like to ask is there a clear concensus that the original article is unsatisfactory to the extent that it needs a re-write?
[[User:TonyClarke|TonyClarke]] 11:38, 27 Aug 2003 (UTC)
:Well, I don't know about a consensus, but here are my reasons for wanting to rewrite the article.  First, the original article is rather disorganized.  Second, it leaps into issues like the representation of data without even saying why programming languages exist in terms that a layperson can understand.  Third, the original article does not maintain a sufficient distinction between the design of programming languages and their implementation.  Fourth, the article does not give enough attention to formal languages (actually, if you counted all the programming languages ever invented, I suspect formal languages would outnumber "practical" languages).  Finally, and most importantly, as the poster at the top of this talk page noted, the article does not give priority to a programming language's role in ''human-to-human'' communication --- which all language designers and software engineering researchers, not to mention most working programmers, understand as its most important role.  It's possible that you could alter the original article to fix these flaws, but the changes would be radical enough to resemble a ground-up rewrite anyway.  BTW I have reused sections from the original article where I thought appropriate.  [[User:K.lee|k.lee]] 02:07, 2 Sep 2003 (UTC)
----
The current main page definitely needs to be re-considered. While it is quite accurate (it seems to me), it is mostly a summary of the topic using the terminology of the discipline, and so is quite inscrutable to a newcomer. It occurs to me that an encyclopedia needs both a specialist and non-specialist version of the general information articles. The specialists need a means to agree on the theoretical structure of the topic, and the newcomers need to learn about it from scratch.

===Removed from subject page:===
'''To Do:''' this is just an outline to get started;
add some descriptive text (or put in '/' links)
and add a ''few'' representative languages to the descriptions

*sequence of execution
**procedural, sequential, linear
**event-driven
**pseudo-random
*method of execution
**interpreted
**compiled
**hybrid
* main programming paradigm
** [[procedural programming]]
** [[structured programming]]
** [[object-oriented]]  programming
** [[functional programming]]
** [[aspect oriented programming]]
** [[logical programming]]
** [[distributed programming]]
*primary method of use
**script, shell, command
**[[macro]], text processing
**application
**systems programming
*abstraction level
**visual programming and integrated development environments
**1GL (First Generation Languages)
**2GL (Second Generation Languages)
**3GL (Third Generation Languages)
**4GL (Fourth Generation Languages)
**database UI development kits
**high-level (declarative, objective, procedural)
**[[assembly language|assembly]]
**[[machine language|machine]]
**[[microcode]]
*other
**pathological
***[[Turing tarpit]]s
**specialty

----
[[User:Rlee0001|Rlee0001]] 01:51 Oct 20, 2002 (UTC)

==Numbers of Users?==
Do Ruby and Scheme really have several hundred thousand users, as in programmers who use them regularly? I doubt it, but I've been wrong before. [[User:Wesley|Wesley]]

I believe so. But no one can prove either point anyway. --TakuyaMurata

I think it's probably true. For example, OCaml has at least 10^3 vocal users, probably 10^4 real users and probably 10^5 people who've played with it. However, such things are so difficult to quantify (e.g. look at Tiobe's silly estimates, which see huge bias from big business) and even to define (e.g. should we be talking about the total running time of programs written in different languages in order to combat, for example, the majority of Sourceforge projects "written in C++" that have yet to see an alpha release?) that I don't think such (mis)information belongs on Wikipedia. -- [[User:jdh30|Jon Harrop]]

==Naming conventions?==
Hi,

why have we put virtually every programming language on "Foo programming language", and not on "Foo" if "Foo" is reasonably unique? "Programming language" is disambiguation, and that should only be used when there is ambiguity, should it not? 
--[[User:Eloquence|Eloquence]] 00:08 Jan 24, 2003 (UTC)

:Please see [[Wikipedia talk:Naming conventions (languages)]]. There's no counterargument against changing to a sensible naming scheme that I'm aware of other than that certain people seemed to take it as a personal affront when it has been suggested in the past. --[[User:Brion VIBBER|Brion]] 00:12 Jan 24, 2003 (UTC)

Heck, I'd forgotten about that. The convention as stated at [[Wikipedia:Naming conventions]] does now say ''not'' to add "programming language" if the name of the language is unique, but I've not done any work in moving pages to reflect this new convention yet. I don't have time to start on this right now, but now that I've been reminded about it, I'll get to it when I have time (others, of course, are more than welcome - indeed encouraged, nay ''begged'' - to get there before me). --[[User:Camembert|Camembert]]

Great. I'll start some moving, although fixing double redirs will be an annoyance and we'll probably lose some page histories .. --[[User:Eloquence|Eloquence]] 00:19 Jan 24, 2003 (UTC)
----
==Proper classification of Python==
Some people including me might take exception to Python being classified as procedural with bolt-on OO technology, this has been extensively discussed in  [http://groups.google.com/groups?hl=en&lr=&ie=UTF-8&safe=off&group=comp.lang.python the Python community]

==Miscellany==
I would like to point out that the programming language list above misses [[Objective-C]]. [[User:Brent Gulanowski|Brent Gulanowski]] 15:54, 15 Oct 2003 (UTC)

==Turing completeness and generality==
One thing the article appears to miss is the basic elements that all languages must share to be able to express any computable algorithm. I was taught this as "Sequence, Selection, Repetition" but it may be known in a number of ways. I feel this is important, as well as correct attribution to whoever proved it mathematically - was it [[Alan Turing|Turing]] maybe? I feel that once it is clear that all languages must support this basic elements, then they can be discussed in the abstract without having to say language X has this feature, language Y has this feature, etc. (though that can be added as an extension). [[User:GRAHAMUK|GRAHAMUK]] 23:29, 9 Nov 2003 (UTC)

:I agree that it would be very nice if the article has discussion for foundmental aspects of programming language. Particularly I would like to see what makes programming language real languages. What distinguishes them from markup languages like HTML. I am not sure about Sequence, Selection, Repetition. I believe the most basic elements of languages are control and data abstraction. This theory fits to the explanation of assembly language very well. Assembly language supports jump and conditional jump, very primitive form of control abstraction. It also supports labeling, primitive form of data abstraction.

:Also I think that the article is too much devoted to discussion for data type and data structures. Is it so important to mention strong typed or dynamic type checking since [[datatype]] article covers such adequately. And control flow on the other hand has very few. Don't we have to even mention if or while? -- [[User:TakuyaMurata|Taku]] 05:34, Nov 11, 2003 (UTC)

::Sequence/selection/repetition is far more fundamental to the concept of a programming language than data or control abstraction. I'm not saying that a language with only those features would be a good language, but I am saying that without those features it would not be a programming language at all. See [[brainfuck]] - it's a perfectly valid programming language, any computable problem can be expressed in it - it's just not a good one for expressing human ideas. It's at that second level that abstractions are important, but these are building on the fundamental requirement for stepwise execution, decision branches and loops. Incidentally assembly languages are possible without the features you mention, yet still remain valid languages. I can remember using a (poor) 6502 assembler on the [[commodore 64]] that did not have labels - you had to specify branches using line numbers. But it did work. [[User:GRAHAMUK|GRAHAMUK]] 06:28, 11 Nov 2003 (UTC)

::Thinking about this further, this is ''precisely'' what separates programming languages from markup languages. I'm not familiar with the full extent of HTML, but as far as I know it lacks the ability to perform branches based on conditions, or the ability to perform repeats. Also, talking of assembly language, it is possible in theory to design a serial processor with only one instruction - "subtract and branch if negative", yet such a processor could still implement any known algorithm, because it obeys the fundamental requirement of seq/sel/rep. This is pretty close to the idea of brainfuck in hardware. I sometimes wonder if such a processor, despite lacking, well, anything much really, could be made to go so fast that it would still be actually pretty good on performance. You could also make it massively pipelined. The ultimate RISC machine... Anyway, I digress, but the point is made, I think. See also [[turing complete]]. [[User:GRAHAMUK|GRAHAMUK]] 06:41, 11 Nov 2003 (UTC)

Umm, very interesting. I think you are talking about what an minimum requirement to make the language capable of simulating the [[Turing machine]]. And probably the three criteria Sequence, Selection, Repetition are right. I was thinking like programming language as the mean of abstraction. The [[Turing machine]] is the most powerful computer we know today and we don't need any programming languages or such to perform computable algorithms. Programming languages were in my view needed and then invented because human beings need something abstract to make programming easier. Mnemonics in assembly languages are completely meaningless to the computer but are only to we human. This is why I claimed data and code abstraction are basic elements of programming language.

But you are right. [[Brainfuck]] is considered as programming language generally, if it misses my picture of programming languages. SImilar small languages like [[PostScript]] are also among them. In other words, programming languages are not only for human or are they? -- [[User:TakuyaMurata|Taku]] 06:40, Nov 13, 2003 (UTC)

-- [[User:TakuyaMurata|Taku]] 06:40, Nov 13, 2003 (UTC)

Is "sequence/selection/repetition" what they're teaching the kiddies nowadays? :-) [[Functional programming]] folks might prefer to say it's abstraction/evaluation/recursion.  Turing equivalence can't be used as a precise criterion, because for instance it assumes infinite storage, and classic [[Fortran]] requires fixed-size allocation, yet few would say it's not a programming language. I would call Turing-equivalent languages "general-purpose programming languages", while leaving "programming language" as a more general moniker for any linguistic form of expression that instructs a computer, irrespective of generality. [[User:Stan Shebs|Stan]] 08:23, 13 Nov 2003 (UTC)

"Sequence, selection, and repetition" are ''not'' enough to make a language Turing-complete.  A finite-state automaton is capable of all of the above (which correspond to the concatenation, union, and Kleene star operator of regular languages).  You also need arbitrary memory allocation (or infinite storage, which is the same thing).

Also, Stan's point re: FORTRAN is a good one.  The primary distinction between markup and programming languages is one of emphasis.  They overlap --- any Turing-complete markup language (e.g., LaTeX) can also be considered a programming language --- but "everyone knows" when something is primarily a programming language or a markup language.

Finally, it's pretty obvious that any non-joke programming language is intended primarily for human consumption.  Joke languages like [[Brainfuck]] or [[Unlambda]] are simply exceptions that prove the rule --- they're designed by humans for human amusement.  [[User:K.lee|k.lee]] 05:27, 17 Nov 2003 (UTC)

:Actually Stan I have no idea what they are teaching the "kiddies" these days as you so dismissively put it. I actually picked up the seq/sel/rep thing from a course I did many years ago which was an introduction to microprocessor design. The point was emphasised that as long as the hardware provided these things, then it could run any software "language", and therefore all programming languages mapped to these fundamental concepts at their heart. This stayed with me so it must have made some sort of good sense to me at the time. Now, it's quite likely that from a software perspective, some of these things may be self evident - for example, the fact that each statement of a language is executed in written order and thus one thing logically follows another (Sequence). Programmers take that for granted (though obviously CPU designers need to construct a mechanism to make it happen), so maybe it doesn't need to be stated - but we must write for the proper audience here. 

::Too bad that they take it for granted :-) What you say is valid for procedural languages, but absolutely not for declarative ones. In  [[Prolog]] language, you state the set of "rules of inference". The burden of setting the order of their application is onto compiler. Once you see what I mean, it is easies to agree that HTML and TEX are as good a programming language in a sense that they make the computer do what I want. The "magic triads" abstraction/evaluation/recursion, sequence/selection/repetition, encapsulation/.../... are woodoo talk for specific approaches, important for sure, but they must be discussed where they fit. When speaking about PL in general, one must have a broader POV. Read more good SF, folks :-)[[User:Mikkalai|Mikkalai]]

That audience is not other programmers - they know this stuff already -, it is the "intelligent layman" who may not realise that that's the case. Without some proper foundations, the abstraction/evaluation/recursion thing is still too "high concept". Another example I clearly remember from my own early steps with programming (I've been a professional programmer for 20 years, so it's a while ago!) is parameter passing - programmers take for granted that parameters map from caller to callee based on the ''position'' of the parameter in a list, but I can remember thinking how error prone that seemed - back then I thought it would be better to "find" the parameter based on its name and ignore its position. Of course knowing now how a CPU actually implements a subroutine, the "position" thing is clearly far more efficient and sensible, and there are likely other undesirable side effects that name binding might have. The point to make here is that to the uninitiated, what seems obvious to a programmer may not be at all obvious to someone else, so starting with implicit fundamentals in order to eliminate any misunderstandings seems a good way to go with an article such as this. Given this approach, I'm not sure that referring to Turing completeness is even a good idea - is the intelligent layman that bothered about the mathematics? I suspect most people coming to WP are looking for a solid, precise but not necessarily complete discussion of the subject. If it grabs them sufficiently, they can look into the maths further if they want. [[User:GRAHAMUK|GRAHAMUK]] 12:05, 18 Nov 2003 (UTC)
::People learn positional parameter passing in junior high school algebra: if f(x, y) = 3x + 4y, then f(1,2) = 11.  It's true that a function in a programming language is not the same thing as a function in pure math, but the notation ought to be familiar enough.  It's only because (a) programming is usually taught at such a low, machine-oriented level and (b) math is usually taught badly, period, that so many programmers find the "high-concept" explanation less intuitive.  To the educated layperson, who has not been forced into low-level thinking by a typical CS curriculum, abstraction and application may well be as easy to explain as branching and looping.  The experiences of the PLT Scheme folks suggest that Scheme (which is, basically, the call-by-value lambda calculus) is easier to teach to undergraduates than C or Java.  The only undergraduates who struggle with Scheme are those who learned bad hackery in C in high school, and convinced themselves that this was the only way to program.  If we're targeting the article towards laypeople, then there's no reason to avoid conceptual explanations in favor of a machine-oriented explanation.
::Also, a Wikipedia article should be as complete as the contributors can make it.  If the article grows too long, then it should have a quick summary at the top of the article, followed by the more in-depth discussion; or else it should be broken into sub-articles.  But there's no reason to leave something out if it's an important concept, simply because it requires more effort on the part of the reader to grasp.
::P.S. Minor pedantic point: you don't need recursion in order to be Turing complete.  Abstraction and application suffice; you can build recursion out of abstraction and application, as with the pure lambda calculus's y-combinator.  [[User:K.lee|k.lee]] 18:15, 18 Nov 2003 (UTC)

:Hey, I added the ":-)" to indicate clearly that the "kiddie" remark was in jest, oh well. Although I'm probably the most formally qualified WP editor for this article (PhD in languages and all that), my first step would be to learn from my predecessors - review the current EB/Encarta/etc writeups, plus reread the intro sections to the best textbooks, both those aimed at specialists and those aimed at nonspecialists - and get an idea of the strategy that others have used. Since encyclopedias are reference works, there is a certain falloff; everybody reads the first sentence, 50% read the second also, 10% get to the second paragraph, and so forth, with only the deeply interested lasting all the way to the end of the article; so you generally want to transition gradually from generalities ("language is how we tell a computer what to do") to Church-Turing, which has to be mentioned eventually, because it's one of the bases that justify some of our classification of types of languages. [[User:Stan Shebs|Stan]] 18:43, 18 Nov 2003 (UTC)

::I agree about the structure 100% - far too many WP articles dive in with no context establishing stuff up front. I suppose the rest of it comes down to whether we approach languages bottom-up or top-down. I can see advantages to both approaches. Since I came from a hardware background, bottom-up seemed to work well for me, going from boolean algebra to logic gates to registers to CPU architecture to stored programs to machine code blah blah etc. Other readers will respond better to the top-down approach, going from "high concepts" of languages towards the underlying bits and bytes. Perhaps both approaches need integrating in the article by including two sections. I'm presuming that the top-down approach is preferred by most teachers of the subject these days, but one thing I do notice is that as a result few people (who are not programmers but nevertheless are expected to know the basic principles) cannot understand or make the mental leap from the language to the chips that implement it in hardware. I've read a lot of vague handwaving arguments to explain it recently while marking some student work at the local uni, so perhaps I've just got a bee in my bonnet about bridging the software/hardware divide in a sensible, clear manner. [[User:GRAHAMUK|GRAHAMUK]] 22:29, 18 Nov 2003 (UTC)

:::The hardware/software divide should get its own article I think; tricky to explain but worth trying. You could maybe do it as a sort of slice across other articles, xref'ing if the reader doesn't know a particular term. Something like "global = 1;" -> "ld r2,1; st global,r2" -> memory-mapped device -> electricity flowing -> light bulb turning on. If you stuck to the "what" and "how", and leave out the "why", it could be both succinct and illuminating. [[User:Stan Shebs|Stan]] 08:15, 19 Nov 2003 (UTC)

I know you guys know much about programming languages and theories in computer science than I do but I was wondering how about historical approach. [[RISC]] is a very good article. Although I don't have much expertise in hardware, the article makes a lot of sense to me. The nice thing is that it doesn't know give particular examples of RISC like a list of instruction code but it focuses on why computer science comes up with the idea of RISC in historical and technical context and also gives a plenty of practical examples of architectures. I think the same strategy can be applied to this article. In some ways, the article simply gives a summary of concepts which really doesn't make sense unless you know it before and sometimes goes to too much detailed. For example, I don't see why it is so important to spend a lot of space to discuss type system while some important concepts such as lazy evalution, side effects and referentical transparency are completely omited.

As I keep repeating, I think it is very important to avoid the article is like a textbook. [[RISC]] article is completely useless if you want to learn an assembly language and how to make a code generator for RISC architectures. Let alone [[Wikibook]] for such case. Well, just a thought. I am just hoping I am any help at all. -- [[User:TakuyaMurata|Taku]] 07:15, Nov 19, 2003 (UTC)

:Yes, a bit of historical recapitulation is helpful, especially to motivate why there are different languages. This article can't really get much into specific concepts like lazy evaluation though, those have to be pushed to language semantics articles so as to keep the top-level article readable by laypeople. [[User:Stan Shebs|Stan]] 08:15, 19 Nov 2003 (UTC)

:You would not expect to learn an assembly language or how to make a code generator for RISC architectures from Wikipedia. You would get that from a text book! So which is it to be? To my mind, the RISC article is actually a very good encyclopedia article. [[User:GRAHAMUK|GRAHAMUK]] 09:40, 20 Nov 2003 (UTC)

Umm, can we have a slight summary of different programming paradigms? I think it is important to show that why we have come to have several languages and what is difference between them. I am not suggesting to have complete discussion of specific topics like lazy evaluation but I don't know how to put, more like how different languages approach the problem of programming in different ways. I think such discussion can have the article more focused on making sense to the general public about what programming is like. The imperative approach is not only one and surprisingly many even computer programmers know little about how problems are done in programming with many different ways. Many people just learn how to do programming in a particular language like C or LISP and not sure programming language as general. For example, I think it would be nice to see how to reverse a string in many ways as an example. While it is very unnecessary to discuss how arguments are passed or how type system works. The bottom line is that the article must not be a summary of programming languages topics, but should discuss actual problems. I know it is easy to say and hard to achive, just chating about my idealistic view. -- [[User:TakuyaMurata|Taku]] 08:40, Nov 20, 2003 (UTC)

:I agree that there should be some explanation for why there are many languages - this itself shows that there is no one, true way to program. However, I'm not sure about examples, at least not in this article. There could be a link to a separate article listing the same program in all the various languages if you wanted. The problem is that including examples here of string reversal (or whatever) is EXACTLY turning it into a text book. The article should be about languages, not a tutorial for any particular one (or all of them). Seems to me your suggestions lean more towards the textbook approach, despite declaring that you don't want WP to be one. [[User:GRAHAMUK|GRAHAMUK]] 09:52, 20 Nov 2003 (UTC)


::Well, it shows that we have not yet found any one, true way to program. -[[User:Doradus|Doradus]] 15:40, 20 Nov 2003 (UTC)


''I agree with [[User:TakuyaMurata|Taku]] -- if you think something is "too much" for an encyclopedia article, please move it to one of the Wiki Books http://en.wikibooks.org/wiki/IT_bookshelf --[[User:DavidCary|DavidCary]] 15:36, 26 Jul 2004 (UTC)''

----
(moved to [[User talk:Dysprosia]])

==Cut from "History of..."==
The following piece is cut out of section "History of programming languages".
:<<<

As the cost of computers has dropped significantly and the complexity of computer programs has increased dramatically, development time is now seen as a more costly consideration than computer time. 

Newer integrated, visual development environments have brought clear progress.  
They have reduced expenditure of time, money (and nerves).  Regions of the screen that control the program can often be arranged interactively.  Code fragments can be invoked just by clicking on a control.  The work is also eased by prefabricated components and software libraries with re-usable code, primarily object-oriented.

Object-oriented methodology was introduced to reduce the complexity of programs, making code easier to write and to maintain. However, some argue that programs have, despite this, continued to increase in complexity. Recent languages are emphasising new features, like meta classes, mix-ins, delegation, program patterns and aspects.

See [[programming paradigm]]
:>>>
All the above is true, but... This rant is good for a pop-sci article in an online magazine, but not for encyclopedia: chaotic, no *history*, and no *programming languages* [[User:Mikkalai|Mikkalai]] 00:37, 13 Dec 2003 (UTC)
----
"[[Computer language]]" is not synonymous with "[[programming language]]".  A programming language is a computer language used for programming.-[[User:Doradus|Doradus]] 00:14, 2 Jan 2004 (UTC)
: I'm agree, [[computer language]] has its own article, and shouldn't be stated that is a synonym of "programming language" because "computer language" is broader. --[[User:Suruena|surueña]] 13:02:51, 2005-09-06 (UTC)

== Writing From Scratch ==

This Section Programming Language needs a total wash and be written from scracth. I volunteer myslef to devote some time to it. As I am new to this site and I am learning how to edit things so this section will be online within a week and with a new style
[[User:Yana209|yana209]] 22:01, Jun 22, 2004 (UTC)

----
''Some languages such as [[MUMPS]] and is called [[dynamic recompilation]]; [[emulator]]s and other [[virtual machine]]s exploit this technique for greater performance.''

The clause before the semicolon isn't even complete. I'd fix it, but I'm not sure how exactly it should read. - [[User:Furrykef|Furrykef]] 15:17, 9 Sep 2004 (UTC)
:fixed. [[User:Ancheta Wis|Ancheta Wis]] 11:42, 29 Jan 2005 (UTC)

==Programming languages causing crashes==

The reason that I deleted the sentence
:"Unfortunately many programming languages cause crashes because the languages themselves are poorly constructed."
is that I don't understand it. I suppose it means that the poor design of some programming languages is causing crashes, which raises the question: which languages is the author refering to? A possible interpretation is that programs written in low-level languages like C are prone to crashes, but that is not poor design in my opinion, but a conscious design choice to prefer speed, ease of compilation and flexibility at the price of allowing more crashes. Putting this sentence in the history section confuses me even more, because that implies that the problem of poor design no longer exists, which is at odds with my interpretation. So, please explain what you mean if you reinsert the above sentence. Thanks, [[User:Jitse Niesen|Jitse Niesen]] ([[User talk:Jitse Niesen|talk]]) 16:30, 28 July 2005 (UTC)

You're right it shouldn't be in history section because it is such a fundamental point and the bane of any decent computer scientist. We are swamped with poorly written junk languages (and operating systems) that gain prominence via clever marketing rather than on merit. Yes I'm referring to design and unfortunately don't have time right now to flesh it out (though, again, anyone who knows the field should be able to do so). Treat it as a stub and add to the list. No I'm not referring to C and I recognise it's horses for courses. Thanks for the feedback. And please add to the "stub" rather than delete again. [[User:Mccready|Mccready]] 01:22, 1 August 2005 (UTC)

Of all major programming languages I would only say of C++ and C#, that they are poorly constructed. This could hardly be considered many, and should be discussed in their respecive articles, not here. Your statement also lacks any form of argument. --[[User:R.Koot|R.Koot]] 01:44, 1 August 2005 (UTC)

I would like to add to the discussion here. In fact there aren't many badly constructed languages at all (I know none, and I've programmed in many). What one can say is the lower the languages (closer to the machine language) the more stress is put on the knowledge of the developer to create a good working program (You need to know your language's do's and don'ts). Take for instance the difference between C++ and Java. Although they both are Modern Languages, C++ still can cause buffer over and underruns while this is pretty difficult to achieve in Java. Although memory leaks still can appear in Java this is probably one of the major flaws in C++ Programs. It's not the language that's bad, but the code that's written in them!
--[[User:PaulSinnema|Paul Sinnema]] 09:44, 16 September 2005 (UTC)

Programming languages don't cause crashes. Programmers who write bad code, or faulty compilers, runtimes, etc. do. [[User:Dysprosia|Dysprosia]] 08:08, 17 September 2005 (UTC)
<nowiki>{{Wikibooks Module|Computer programming|Error handling}}</nowiki>
: I begg to differ. Example: <code>X / 0</code> will crash a C and C++ programm but will be a CONSTRAINT_ERROR in Ada. So there are differences in how languages tread error conditions and it is rightfull that we describe that to the reader - preaps a comparison table might be helpfull to the reader in that respect. --[[User:Krischik|Krischik]]&nbsp;<sup>[[User_talk:Krischik|T]]</sup> 09:08, 18 September 2005 (UTC)

:: I beg to differ in turn -- it is ''you'' who is causing the division by zero error, not the programming language. What you are measuring above is something completely different. [[User:Dysprosia|Dysprosia]] 10:31, 18 September 2005 (UTC)

::: True. And yes, we talk about two half of the same coin - a programming mistake and how the language reacts to that - but then this Module is called [[Programming language]] and not [[Programmers]]. And how about <code>X / Y</code>. Is still the programmers fault or prehaps faulty data delivered to the programm. If you say "programmer" then I ask: Have you realy got a <code>if (Y != 0)</code> in front of every division - or made a full static analysis proving that Y can't be 0 - for all programms you have ever coded?

::: We live in a time of Viruses, Worms and Trojian Horses. A time where an unprotected Windows XP computer is infected and turned into a Spam-Bot in about 4 minutes after beeing connected to the internet. Programmers are not perfect and error handling - or the absence - is an important aspect of a Programming language and need to be explained to the reader. Please Note: I have never said a programming language is faulty because it has no error handling - that would break the NPOV. --[[User:Krischik|Krischik]]&nbsp;<sup>[[User_talk:Krischik|T]]</sup> 12:31, 18 September 2005 (UTC)

:::: It is the programmer's fault for not making a program that is not tolerant to faults and errant data, the programmer's fault that they do not perform adequate buffer checking, the programmer's fault for inadequate testing. Blaming Windows XP's insecurity on the programming language that they used, in my mind, is a cop-out. A programming language is just a means of expressing an algorithm -- what has any significance is the behaviour of the compiler or the runtime or the libraries or all of these, when unspecified or illegal behaviour occurs. The compiler is not the programming language.

::::: You can't have is that some programming language has better features then your beloved C, can you? You can stand that expressing an algrorithm (incl. the needed error handling) might be easier in another language, can you? A typical case of "If my beloved programming language does not have feature X then feature X is bad, evil, send from hell - or whatever other nasty place you religion has to offer". You think I am unfair - well, you violent defence of C's greates weakness leads to no other conclusion. Or why should a programmer not know about or choose a programming language wich makes error handling easier? And Yes: I have 15 years of C/C++ programming experience I know what I am talking about - but then: I also have experience in Pascal, Modula-2 and Ada - programming languages where buffer overruns are virtualy unknown. --[[User:Krischik|Krischik]]&nbsp;<sup>[[User_talk:Krischik|T]]</sup> 09:44, 19 September 2005 (UTC)

:::::: You ought not to get into insults and making nonsense claims that I have thought you "unfair" and that I have made some "violent defence" towards C (I've barely mentioned the name of the language in this thread). Think about the actual matter at hand. If you actually think about this carefully, you will understand where I am coming from: a programming language is ''only'' a specification on how to translate ideas into something more low-level. A specification does not cause crashes. Misunderstanding the specification ''does''. If I tell you not to cross the street when the light is red, and you cross it anyway and get hit by a car, whose fault is it? [[User:Dysprosia|Dysprosia]]

::::::: The person who walks of course. But then: there must be a traffic light in the first place. --[[User:Krischik|Krischik]]&nbsp;<sup>[[User_talk:Krischik|T]]</sup> 11:47, 19 September 2005 (UTC)

:::::::: It is still possible to cross a light safely without a light. [[User:Dysprosia|Dysprosia]] 05:07, 20 September 2005 (UTC)

::::::::: One person crossing one road: Yes. But can you image a city like New York, London or Paris without traffic lights? Trafic light where invented because traffic became to compex for the old "look right look left" technique of crossing the road. (BTW: The Ada motto is "Ada, the language for a complex world") ---[[User:Krischik|Krischik]]&nbsp;<sup>[[User_talk:Krischik|T]]</sup> 10:45, 21 September 2005 (UTC)

:::::::::: However, it is still possible. Regardless, what you need to also understand is that while runtime checks are fine and dandy, the overhead they incur is simply unacceptable for certain applications. When you're running some application where a bit of performance lag isn't an issue, then fine. But if you're writing hardware applications or time-critical applications, performing checks may unacceptably slow things down. The lack or disabling of runtime error checking/handling is not necessarily a bad thing. Again, the language is not to blame for this (for example, you can get C compilers which integrate bounds checking, but slow the application down -- you have to check ''every'' single array access), but of the compilers or the execution environment. 
:::::::::: Which is what I've been maintaining all along. [[User:Dysprosia|Dysprosia]] 09:18, 22 September 2005 (UTC)

:::: And since you mention it, I ''do'' check return values when I call C library functions, amongst other things.

::::: All return values - all parameters - all buffers sizes - all integer ranges - all type convertions - allways - never ever forgetting it even once? Because that is what you have to measure up against when compare yourself to a compiler which provides all that be default. --[[User:Krischik|Krischik]]&nbsp;<sup>[[User_talk:Krischik|T]]</sup> 09:44, 19 September 2005 (UTC)

:::::: So you understand now that it is not the programming language that provides typechecking ''et al''? You said yourself "a compiler which provides..." (Regardless, understanding types is not very difficult. There are other more strongly typed languages than C, and there are even dynamic typed programming languages. It is not difficult to understand and keep in mind.) [[User:Dysprosia|Dysprosia]]

:::: And so should you. [[User:Dysprosia|Dysprosia]] 22:23, 18 September 2005 (UTC)

::::: Actualy: No I don't have to check return values - my current assingment is done in Ada. --[[User:Krischik|Krischik]]&nbsp;<sup>[[User_talk:Krischik|T]]</sup> 09:44, 19 September 2005 (UTC)

:::::: When you program in C, you'd better. Do you catch exceptions and/or perform error checks when you program in Ada or do you just ignore them? [[User:Dysprosia|Dysprosia]] 10:10, 19 September 2005 (UTC)

::::::: Depends - the great strenght of expeptions is that I only need to handle the expeptions I am interested in and let the applications framework worry about the rest. Shure, the applications framework is done by programmers as well, just like the compiler. And I can still forget an exeption I ''should'' be interested in - but it does not happen as often as in C. Net result: I start the debugger only twice a month. --[[User:Krischik|Krischik]]&nbsp;<sup>[[User_talk:Krischik|T]]</sup> 11:47, 19 September 2005 (UTC)

:::::::: Thus Ada is not immune to you having to perform error correction at some point. No programming language is. (This is beside the nub of the matter though.) [[User:Dysprosia|Dysprosia]] 05:07, 20 September 2005 (UTC)

::::::::: Shure can't argue with that. --[[User:Krischik|Krischik]]&nbsp;<sup>[[User_talk:Krischik|T]]</sup> 10:45, 21 September 2005 (UTC)

== programming language popularity: the TIOBE Programming Community Index ==

Should we realy have [http://www.tiobe.com/tpci.htm TIOBE Programming Community Index a link] to a biased statistic without telling the readers in which way the index is flawed?

TIOBE's [http://www.tiobe.com/ company statement] is: ''We offer out-of-the-box solutions for the programming languages C, C++, C# and Java.'' &mdash; which oviously means they want those languages to look "good" on there statistic.

We should either explain he flaw or remove the link. Of course it is tricky to keep an NPOV when explaining an flaw in some way.

=== How is the Index flawed? ===

'''The search query '+"<language> programming" -tv -channel' is used to calculate the TPC Index.'''

Since you are probably reading this discussing because you are language advocate of some sort you can just google for '+"<language> programming" +tv +channel' with <language> beeing your favorite programming language - and then decide if those pages where rightfully excluded from the index.

My first google hit for my favorite language is: '''This association is aimed at promoting ADA programming language to the software... TV channel, producer) on any type of platform (OpenTV, MediaHighway). ...''' &mdash; rightfully excluded &mdash; don't think so.

: I removed the link, because you are not alloweds to link to your own website, not because I'm advocating some language. Please [[Wikipedia:Assume good faith|assume good faith]]. Cheers, --[[User:R.Koot|R.Koot]] 14:01, 14 August 2005 (UTC)

:: Hmmm, there are several links to some of my pages on Wikipedia and Wikibooks. But they have never been added for vanity but only because they fit to the topic at hand. If it was any different the other contributers would have removed them. And in that respect I [[Wikipedia:Assume good faith|assume good faith]]. --[[User:Krischik|Krischik]] 14:21, 14 August 2005 (UTC)



=== popular programming languages ===

The article "[[buffer overflow]]" currently claims that
:''" As of 2005, the most popular languages generally are C and its derivative, C++."''

While I suspect this is correct, I wonder how that author found out?

Is it even possible to rank programming languages according to "popularity"
(or in some other, more objective way) in a NPOV way?
If so, should we discuss "popularity" here in the [[programming language article]],
or split it off into a [[popular programming language]] article?
See [http://c2.com/cgi/wiki?ProgrammingLanguageUsageStatistics C2: Programming Language Usage Statistics].
--[[User:DavidCary|DavidCary]] 05:19, 11 November 2005 (UTC)

== Rewrite has gone on long enough ==

I have given [[User:K.lee]] two weeks to put up or give up with his rewrite.  His "rewrite" approach is anti-collaborative and he has been claiming that his rewrite is pending for over two years.  The "reqeustrewrite" template is only used for k.lee's claim for this article.  Wikipedia itself is not much older than that, which meas that no else has had a real and equal "turn" at this article since most of the work for the past two years will be lost when/if k.lee ever commits his version. [[User:Fplay|Fplay]] 19:55, 9 December 2005 (UTC)
: k.lee e-mails that that requstrewrite tag can be removed immediately. [[User:Fplay|Fplay]] 20:14, 9 December 2005 (UTC)

== FORTRAN ==

Minor note, but the spelling was changed from "Fortran" to "FORTRAN" since the article was referring to the first version of the language which was indeed spelled that way. The current accepted convention (see the [[Fortran]] page) is as follows: FORTRAN, FORTRAN II, FORTRAN IV, FORTRAN 66, FORTRAN 77 are in upper-case, with the new versions (such as Fortran 90) are in lower-case "Fortran" as per their convention. The FORTRAN spelling is a very important issue for FORTRAN programmers worldwide.


== New introduction ==

I am willing to agree that my first stab at an introductory paragraph for "programming language" might not be  ideal.  However, the current first paragraph is likely to be incomprehensible to all but the most knowledgable of people.

The first paragraph should provide a brief summary/definition for a reasonably intelligent person who knows nothing about computers.  Later material can get technical and dense.

Let's work out some good wording that encapulates this rather nebulous of entities.

[[User:Derek farn|Derek farn]] 14:15, 15 February 2006 (UTC) ''(Copied here from my talk page --[[User:TuukkaH|TuukkaH]] 16:31, 15 February 2006 (UTC))''

:I'm sorry for impolitely reverting your introductory paragraph, I was thinking of the edit history of another programming-related article. I'll restore it here for further discussion:

:<blockquote>A '''programming language''' is a language designed to allow [[programmer]]s to specify a sequence of operations to be performed (usually by a computer). The syntax and semantics of programming languages are much more restricted than [[natural language]]s.  The written, human accessible, form of a programming language is known as [[source code]] and may be translated by a [[compiler]] into a form that can be executed by the [[cpu]] of a computer.</blockquote>

:What I like about your version is that it's easy to read and probably also to understand. What I like about the earlier version is that it doesn't oversimplify, and it has links to other ''relevant'' articles. To me, the important things to tell in the introduction include:
:*The purpose of programming languages is to allow people to describe computer programs on a level where they can be made executable.
:*Programs are described by the data they act on and the algorithms they employ.
:*My pet with some nice links: "Programming languages are a type of [[computer language]]s, excluding [[pseudocode]] which is exclusively for human communication."

:--[[User:TuukkaH|TuukkaH]] 16:31, 15 February 2006 (UTC)

I'm not sure I would have made the programming/computer language distinction.  Yes html is a markup language, but some people think it is a programming language.  Who are we to disagree?  Do we require programming languages to be Turing complete?  Is calling html a computer language just a way of deflecting critisism of not calling it a programming language?

: We can somewhere down the article mention that some people think that HTML is a programming language, but we need not include this topic in the introduction. HTML doesn't allow one to describe algorithms so it clearly isn't a programming language. HTML and programming languages allow humans to communicate with computers so they're computer languages and mentioning this puts the topic in its place. --[[User:TuukkaH|TuukkaH]] 19:23, 16 February 2006 (UTC)

Anyway, back to the problem at hand.  I now appreciate that my definition was overly restrictive.  Some languages require programmers to specify what, not how.  For instance, SQL requires a set of conditions to be specified, not the nuts and bolts of finding the data.  What about Prolog which consists of clauses (ok, most implementations have extensions that support a more imperative style).  How about:

:A '''programming language''' is a language designed to allow people to create programs that control the actions of a machine (which is often a [[computer]]).  The [[syntax]] and [[semantic]]s of programming languages are much more restrictive than [[natural language]]s.  The written, human accessible, form of a programming language is known as [[source code]] and is often translated into a different form before being executed on a machine (in the case of a computer, by the [[cpu]]).

:Programming languages take many forms.  Many in common use require programmers to write [[source code]] that implements the algorithms used to  produce the required actions (so called [[imperative programming]]).  Other languages require programmers to specify the ''what'' rather than the ''how'' (so called [[declarative programming]]).  For instance, users of [[SQL|structured query language]] specify the conditions that must be met by data in a database for it to be returned as the result of a query, and various support programmers work out how to actually retrieve that data).

: Programming languages differ from languages such as [[markup languages]] in that they are [[Turing complete]].
[[User:Derek farn|Derek farn]] 01:34, 16 February 2006 (UTC)

:: This feels like a runaway introduction, see for example [[Wikipedia:Lead_section]]. I don't feel we should go into details such as syntax, semantics, source code, cpu, imperative vs. declarative, let alone Turing-completeness. --[[User:TuukkaH|TuukkaH]] 19:23, 16 February 2006 (UTC)

Yes, it is getting a bit bloated.  I think that Turing completeness is a good way of distinguishing programming languages from other kinds of languages (I don't understand you later comment about infinite execution; there are various mathematical formalisms used when discussing properties of languages; I am using the term as a way of putting a minimum limit on the expressive power of a programming language).  Or are we going to duck this issue entirely?

: Could you check [[Turing completeness]] and [[machine that always halts]]? My comment below referred to the fact that if you require programming languages to be Turing complete you artificially leave out programming languages that are somehow able to limit programs to always halt. I say we duck this issue entirely because it's about a mathematical theory which isn't directly applicable in practice, in programming. We can duck for example by restricting programming languages to those that ''are used'' to describe ''data structures'' and ''algorithms''. --[[User:TuukkaH|TuukkaH]] 09:31, 17 February 2006 (UTC)

People are familiar with what a natural language is, so let's make use of this knowledge.

:A '''programming language''' is a language designed to allow people to create programs that control the actions of a machine (which is often a [[computer]]).  The [[syntax]] and [[semantic]]s of programming languages are much more restrictive than [[natural language]]s.  The written, human accessible, form of a programming language is known as [[source code]] and is often translated into a different form before being executed on a machine.

:Programming languages take many forms, the two major divisions being [[imperative programming]] and [[declarative programming]].  Some languages are intended to be used within specific domains (eg, banking), while others are intended for more general usage.

:Languages differ in their [[formal language|expressive power]] and a language powerful enough to be [[Turing complete]] would be regarded as a programming language.  [[Markup language]]s such a pure [[html]] are not Turing complete, but can be made so with the addition of extensions such as [[PHP]], or [[Javascript]].

[[User:Derek farn|Derek farn]] 00:28, 17 February 2006 (UTC)

=== [[Turing complete]] is not enough ===
I don't think that beeing [[Turing complete]] is enough to make a programming language. The language should also be used for general programming. That's why at [[Wikibooks]] we draw the line between [[b:Wikibooks:Programming languages bookshelf|Wikibooks:Programming languages bookshelf]] and [[b:Wikibooks:Domain-specific languages bookshelf|Wikibooks:Domain-specific languages bookshelf]]. A "domain-specific language" may as well be [[Turing complete]] but it is not used for general programming bu only in a specific domain. i.E. [[PostScript]] is considered turing complete however I would not consider it a programming language as it not used for general programming - Or has anybody seen a text-editor or an excel clone written in PostScript?

--[[User:Krischik|Krischik]]&nbsp;<sup>[[User_talk:Krischik|T]]</sup> 07:11, 16 February 2006 (UTC)

: A "domain-specific language" can very well be a programming language but not necessary one suitable for general purposes. The article on [[PostScript]] has links to game of life, a webserver, fractals, barcodes, HTML renderer, raytracer. Even if a language isn't the best tool for the job it can still be a programming language. --[[User:TuukkaH|TuukkaH]] 19:23, 16 February 2006 (UTC)

:: Now that I find intersting - especialy the webserver part. And unlike the akademic brabble below this could change my mind about [[PostScript]]. In which case I have choosen a bad example. --[[User:Krischik|Krischik]]&nbsp;<sup>[[User_talk:Krischik|T]]</sup> 12:00, 17 February 2006 (UTC)

==== Yes it is ====

What difference does it make what a language is actually used for?  And what exactly is ''general programming''?

Postscript is very much like [[Forth]], would you say that Forth is not a programming language?

: Forth is used by humans to create programms for computers - so certanly it is programming language. --[[User:Krischik|Krischik]]&nbsp;<sup>[[User_talk:Krischik|T]]</sup> 11:53, 17 February 2006 (UTC)

Most languages are only used by a handful of people.  Does that mean they are not programming languages because they are only used for specific tasks (whatever it is that the handful of people write with them)?

To take your example, I know people who work with printers and formatting software who spend large amounts of time writing code in postscript.  I even have a program that prints out a calendar that is written in postscript.  Just because lots of people choose not to write their software in postscript does not stop it being a programming language.

[[User:Derek farn|Derek farn]] 12:46, 16 February 2006 (UTC)

: In your edit comment you claim that a programming language is equivalent to Turing complete. There are a lot of programming tasks that don't need infinite execution, so if a language would otherwise be a programming language but it has only finite execution you wouldn't call it a programming language. Now I wouldn't call it ''a Turing-complete programming language''. To take another example, primitive lambda calculus is a Turing-complete model of computation but it lacks data types and IO. I don't really know if it should be classified as a programming language but I think it's better to keep the models of computation separate from the introduction of programming language. --[[User:TuukkaH|TuukkaH]] 19:23, 16 February 2006 (UTC)

:: Actualy: How many programming languages are turing complete? '''int''' in C is either 16, 32 or 64 bit - hardly ''infinite''. C demands that there is an integer type '''intptr_t''' to which a pointer can be cast to - here goes support for ''infinite'' memory. "Turing complete" is the theoretical concept for academic use only. --[[User:Krischik|Krischik]]&nbsp;<sup>[[User_talk:Krischik|T]]</sup> 11:53, 17 February 2006 (UTC)

: The assertion that PostScript is ''not'' a programming language is utterly nonsensical. What is it, if it is not a programming language?  

:: A page description language. Because that is what it is used for in 99.99% of all cases. Even the calendar programm mentioned above is only that - it '''prints''' a calender - it is not an outlook clone. If it starts having a database to keep appointments then it aproaches programming. --[[User:Krischik|Krischik]]&nbsp;<sup>[[User_talk:Krischik|T]]</sup> 11:53, 17 February 2006 (UTC)

::: Look. Do you even ''know'' about the PostScript language at all? It sounds like you think that PostScript's capabilities are solely devoted to graphics output. Yes, it does this well, but it is not its only functionality.
::: Furthermore, it can be argued that nearly ''all'' programming languages can in some sense be page description languages. What do you think a GUI display does when it prints a calendar? 
::: Just because PostScript does not have the regular idea of user I/O that other programming languages have does not mean the language is suddenly "not" a programming language. [[User:Dysprosia|Dysprosia]]

:::: I never tought that a programming language needs "user i/o". Many embedded programms or batch processing programms do well without. --[[User:Krischik|Krischik]]&nbsp;<sup>[[User_talk:Krischik|T]]</sup> 13:01, 17 February 2006 (UTC)

::::: So what on earth are you basing your argument upon that PostScript is not a programming language? You seem to use some sort of arbitrary definition that because some programming language doesn't "keep appointments" or is an "excel clone", it's not a programming language? [[User:Dysprosia|Dysprosia]] 13:17, 17 February 2006 (UTC)

: Does a programming language have to have [[curses]] or GUI capabilities to be considered a programming language? Of course not. Just because PostScript does not have a lot of user-interaction libraries available to it doesn't mean it fails to be a programming language. If PostScript had such libraries, it would be rather easy to create a "text-editor" or "excel clone"! [[User:Dysprosia|Dysprosia]] 09:49, 17 February 2006 (UTC)

:: I think we are all in agreement that PostScript is a programming language, and even a Turing-complete one, and you can even write different kinds of programs in it in practice.  Perhaps you meant this answer to Krischik above, he was the one who didn't want to think of PostScript as a programming language? --[[User:TuukkaH|TuukkaH]] 10:37, 17 February 2006 (UTC)

::: Of course. [[User:Dysprosia|Dysprosia]] 11:05, 17 February 2006 (UTC)

::: No, I am not in agreement - I still think it is a page description language. --[[User:Krischik|Krischik]]&nbsp;<sup>[[User_talk:Krischik|T]]</sup> 11:53, 17 February 2006 (UTC)

:::: And Lisp is a list processing language and Visual Basic a painting program. —''[[User:R.Koot|Ruud]]'' 13:29, 17 February 2006 (UTC)

==== Definition ====
I propose the following definition, distilled from many sources throughout my education and career. This definition disposes of the qualitative assessments of languages, and focuses on quantifiable features:
;General purpose programming language :A general purpose programming language must meet three criteria: it must be Turing complete; it must have at least a prototype compiler/translator/interpreter implementation; it must be in use, or targetted for use, independent of any particular application software.
Examples of general purpose programming languages:
;C :Clearly satisfies all three requirements.
;Perl 6 :While its implementations are currently shakey at best, they exist, and it otherwise meets 1 & 3.
;JavaScript :It is rare that JavaScript is used outside of a Web browser, but it ''is'' used that way.
;PostScript :Implementations of PostScript as a stand-alone language have existed since the 80s, though they are rarely used outside of research and QA for embedded applications.
Examples of non-general purpose programming languages:
;SQL :Misses on item 1
;pseudocode :The typical pseudocode used in computer science books and papers has no formal implementation that I am aware of.
;vi macros :Misses on item 3 (yes, vi macros are Turing complete).
If we can agree to this definition, then we could agree to limit the scope of the article to such languages, and then create articles to collect the exceptions. -[[User:Harmil|Harmil]] 13:48, 6 March 2006 (UTC)

=== SQL is not Turing complete ===
SQL has no looping construct.  Ok, the support software behind it contains lots of loops, but that is not the same thing.

I have always thought of SQL as a programming language, but on reflection I guess it should be called something like a ''database query language'' and along with [[markup language]]'s not be included in the list of programming languages.  The SQL Standard is not maintained by [[SC22]], the [[ISO]] committee responsible for programming languages.

[[User:Derek farn|Derek farn]] 13:08, 16 February 2006 (UTC)

: Have you had a look at [[PL/SQL]]? [[User:Krischik|Krischik]]&nbsp;<sup>[[User_talk:Krischik|T]]</sup> 13:03, 17 February 2006 (UTC)

PL/SQL adds programming language features to SQL (because it does not have any), hence the name Programming Language/SQL.

[[User:Derek farn|Derek farn]] 14:17, 17 February 2006 (UTC)

Doesn't the acronym "SQL" stand for "Structured ''Query Language''"? I would not call it a programming language in its own right, but possibly a tool for other languages. --[[User:BBM|BBM]] 22:33, 16 May 2006 (UTC)

== Removed comments ==

I just removed the following comments from the end of "History of programming languages" (reformatted to shorten lines), as their presence (with newlines in between) was creating excessive vertical whitespace, and in any case they really belonged here. [[User:Hairy Dude|Hairy Dude]] 05:14, 2 February 2006 (UTC)

 &lt;!--- Chaotic and not to the point of the section, i.e., "history of
 comp lang." I move this piece in "Talk" according to wikipedia principle:
 better no article than bad article --->
 
 &lt;!--- Changed "teached" to "taught." I also disagree with the claim
 that Java was the first programming language taught in universities.
 Languages like FORTRAN, Cobol, C, etc., were all extensively taught
 before Java came on the scene. shrao@acm.org, 2005-02-02 --->
 
 &lt;!-- The assertion: "Java...became...the first programming language
 taught at the universities" is intended to convey that Java has become
 the programming language of choice for 100 level language classes in
 university curricula. It's a rather badly worded sentence. Changed "first"
 to "initial." tim@fourstonesExpressions.com, 2005-03-24 -->
 
 &lt;!-- The sentence is still poorly worded; changed "the initial" to
 "an introductory". danb@cs.utexas.edu, 2005-10-04 -->

== "Millions" of what? ==

http://hopl.murdoch.edu.au/ reads "This site lists 8276 languages... It has delivered more than 1,720,000 programming languages descriptions in the last 14 months". (I think this latter bit is their way of saying web-hits.) [[User:Ewlyahoocom|Ewlyahoocom]] 20:15, 11 March 2006 (UTC)

: I think it was deliberatly done to confuse people. —''[[User:R._Koot|Ruud]]'' 20:43, 11 March 2006 (UTC)

::<s>I'm pretty sure it was a good faith mistake. Haven't we all discovered some new bit of information, rushed to add it to Wikipedia, only to find out later (usually only a few minutes) that we misread it?</s> Hmmm... maybe we'll have to keep our eye on you. [[User:Ewlyahoocom|Ewlyahoocom]] 20:48, 11 March 2006 (UTC)

::: Oy... what happened to [[WP:AGF]]? —''[[User:R._Koot|Ruud]]'' 20:57, 11 March 2006 (UTC)

:::: When the editor in question writes "I think it was deliberatly", then one no longer has to assume, yes? However... if I may assume that you're joking, then you may assume that I'm joking, too. [[User:Ewlyahoocom|Ewlyahoocom]] 21:11, 11 March 2006 (UTC)

::::: My "it being done" refered to HOPL stating such a large number without sopecifing what "delivered" mean, not that my addition was done to confuse people. —''[[User:R._Koot|Ruud]]'' 21:18, 11 March 2006 (UTC)

:::::: Oh, I see! HAHAHA! Wait a sec... where's your good faith for those guys!? HAHAHAHA! :-) [[User:Ewlyahoocom|Ewlyahoocom]] 05:49, 12 March 2006 (UTC)

==Article image==
Is there a better, more representative image of computer code than the [[:Image:Html-source-code.png|current one]]?

:What would it ideally depict? Certainly not HTML like currently. Perhaps a simple function in a typical, popular programming language such as C. Or something more readable such as Python. --[[User:TuukkaH|TuukkaH]] 12:32, 16 January 2006 (UTC)

::Instead of cropping the picture to make it fit, maybe it's better to have a scaled-down image that conveys the shape and layout of some chunk of code, without necessarily trying to be legible in detail.
::As for the language, i'm sure everyone has their favorite (also Python, in my case).  But for Wikipedia, the language's historical recognition, heritage, and influence are probably more important factors than current popularity.  To me, the two most obvious contenders are C, and Lisp/Scheme.  --[[User:Piet Delport|Piet Delport]] 16:58, 16 January 2006 (UTC)

:::I don't have a problem with C/C++ or LISP. However, to keep source code language agnostic I'd propose using a psuedo-language that just shows block structure layout of programming languages, which is universal to all languages.--[[User:Capi crimm|Capi crimm]] 04:30, 6 March 2006 (UTC)

::::Pseudocode would feel a bit like giving the Cola article an artificial "[[Acme Corporation|Acme]] Cola" image.  --[[User:Piet Delport|Piet Delport]] 10:43, 8 March 2006 (UTC)

:::: To be accurate, block structure layout is not universal to ''all'' languages. &ndash; [[User:Zawersh|Zawersh]] 02:13, 5 June 2006 (UTC)

:::What about a segment of [[MediaWiki]] [[PHP]] code? MediaWiki powers Wikipedia, so I think it is appropriate, should one specific language have need to be used. --[[User:BBM|BBM]] 22:42, 16 May 2006 (UTC)

:::: My inner programmer cringes at the thought of being represented by PHP...  but the idea has merit.  --[[User:Piet Delport|Piet Delport]] 07:22, 17 May 2006 (UTC)

: I've added the reqimageother template above this page if you guys wouldn't mind. I agree that this article deserves something better. -- [[User:Face zz|Face]] 09:47, 2 May 2006 (UTC)<br />P.S.: Maybe we can do something with [http://www.webopedia.com/FIG/PROG-LAN.gif this] too?

:: What is the cryptic "High-Level Language" block supposed to represent, though?  --[[User:Piet Delport|Piet Delport]] 14:41, 2 May 2006 (UTC)

::What about the misleading steps/indentation? If we use something like that, we need to do it differently. The indentation gives the impression that higher-level languages are somehow less than lower-level ones, even to the point that hardware is better than software. How about a ladder diagram instead. [[User:Jaxad0127|Jaxad0127]] 00:10, 6 June 2006 (UTC)

What about this one about the history of programming languages: [[:Image:Historie.png]]? If not as main image, at least could be used in the History section. [[User:ManuelGR|ManuelGR]] 22:44, 14 May 2006 (UTC)

: The German text probably rules it out speedily, but beyond that, the selection of languages strike me as unbalanced:  Smalltalk gets no less than five entries, while many major languages are left out.  There are also some... creative arrows, such as the Prolog -> Lisp one.  --[[User:Piet Delport|Piet Delport]] 01:20, 15 May 2006 (UTC)
==Assessment comment==
{{Substituted comment|length=201|lastedit=20060911170143|comment=Needs fixing of a few {{[[Template:fact|fact]]}}s. [[User:Titoxd|Tito]][[Wikipedia:Esperanza|<span style{{nw=}}"color:#008000;">xd</span>]]<sup>([[User talk:Titoxd|?!?]])</sup> 17:01, 11 September 2006 (UTC)}}
Substituted at 21:56, 3 May 2016 (UTC)
{{talkarchive}}

== HTML and Turing-completeness ==

{{user|Derek farn}} recently [http://en.wikipedia.org/w/index.php?title=Programming_language&diff=52876643&oldid=52853548 reverted] the article from this:

: ''Some examples of languages that are not Turing complete are [[HTML]] (although it can contain Turing complete languages such as [[PHP]] and [[Javascript]])''

back to this:

: ''Some examples of languages that are not Turing complete are pure [[HTML]] (the use of embedded [[PHP]] or [[Javascript]] makes it Turing complete)''

reasoning that "HTML with embedded PHP is still HTML; the two interact within a web page".

I disagree with this sentiment, hence my original edit.  My reasoning is:

* HTML with embedded PHP is not still valid HTML.  (Try running PHP files through an HTML validator.)

:: I used the phrase "pure HTML" to imply HTML without extensions. But then of course <script> ... </script> is in this ''pure'' HTML and it can contain Javascript.  Not an ideal solution, but I think it conveys the intent in a few words. [[User:Derek farn|Derek farn]] 00:02, 14 May 2006 (UTC)

* PHP does not know, or care, what kind of data you put in its raw output sections.  (It can be HTML, CSS, XML, ASCII art, or anything else conceivable.)

:: I don't see what this has to do with this issue. [[User:Derek farn|Derek farn]] 00:02, 14 May 2006 (UTC)

* PHP and Javascript don't "interact" with HTML; they interact with the [[web browser|browser]]/[[user agent]] and the [[Document Object Model|DOM]] tree.  HTML's role is nothing more than a completely passive data format.  (The same role can be filled by other formats, like [[XUL]], for example.)

:: The two do 'interact' within a web page to produce a desired result.  What it is that they each interact with is too low level a detail to get involved with here. [[User:Derek farn|Derek farn]] 00:02, 14 May 2006 (UTC)

* In other words, embedding PHP/Javascript in HTML does not make HTML Turing-complete any more than putting a computer on a table makes the table Turing-complete.  The two are simply orthogonal, and i think it confuses the issue to suggest otherwise.

:: A great many web developers (or at least the ones I seem to talk too) seem to make little distinction between HTML with/without some embedded scripting language.  I added the PHP/Javascript wording to head off heated debates about what is/is not HTML. [[User:Derek farn|Derek farn]] 00:02, 14 May 2006 (UTC)

::: I always read that HTML with scripting (client or server side) was called Dynamic HTML (DHTML). The script tag hasn't always existed.[[User:Jaxad0127|Jaxad0127]] 01:43, 14 May 2006 (UTC)

::: Good observation.  The [[HTML]] article does not mention static but there is a [[dynamic HTML]] article.  This is the distinction we need to make (I'm assuming that all scripting languages are Turing complete???). [[User:Derek farn|Derek farn]] 12:19, 14 May 2006 (UTC)

:::: This is where Turing completeness gets a little sticky.

::::: Very sticky in that we have to make a distinction between algorithms and 'real world' output.  Turing completeness deals with algorithms and does not get involved with setting bit that cause lights to come on, or some other user visible behavior).  So yes, there are languages where it is possible to write programs that cause things to happen that cannot be written in another language (because the compiler for that language does not provide a mechanism, or the compiler for the language might not even exist on a given problem).  So the wording really ought to talk about 'algorithms being expressed'; the current wording takes the simplistic approach. [[User:Derek farn|Derek farn]] 16:11, 13 June 2006 (UTC)
:::: While you can generally do the same thing in all languages, some have special constructs that cannot be simulated in other scripting languages without extending (rewriting) the interpreter. With HTML in mind, a good example is JavaScript (JScript) vs. VBScript. JavaScript can easily change things like class and style, while all VBSCript can do is replace the tag entirely, which never works. But, VBScript has a special construct just for HTML pages (I can't remember what it is or find the book describing it) that allows it to turn the document into a word processor, the exact nature of which is nearly impossible to do in JavaScript, given it's limitations. But for the most part, they can be used interchangeably. [[User:Jaxad0127|Jaxad0127]] 15:41, 13 June 2006 (UTC)

Would anyone else care to share their opinion, and help settle this?  --[[User:Piet Delport|Piet Delport]] 11:35, 13 May 2006 (UTC)

== strong typing vs. weak typing in Scheme and Lisp ==

In the table, Lisp is listed as strong while Scheme is listed as weak.  At a minimum it would seem to me that the two should be the same.  Within Wikipedia Lisp and Common Lisp are listed as ''dynamically'' typed, without mention of strong or weak typing.  Discussion on the [[scheme programming language]] page leans towards calling it strong, although it acknowledges that usages in the literature differ.

I think we should try to establish a consistent usage within Wikipedia at least, preferably backed up by references.  Can anyone help with this?  [[User:Ideogram|Ideogram]] 14:00, 31 May 2006 (UTC)

== prepare for major changes ==

I intend to merge content from [[User:K.lee]]'s infamously delayed rewrite into this article.  This will entail major changes.  If you have any opinions or suggestions, especially related to k.lee's rewrite, now is the time to discuss them.  [[User:Ideogram|Ideogram]] 04:02, 1 June 2006 (UTC)

I have created the subpage [[Talk:programming language/merge]] so that we can work on this without disturbing the current article.  [[User:Ideogram|Ideogram]] 04:48, 1 June 2006 (UTC)

I have merged the History section.  [[User:Ideogram|Ideogram]] 05:08, 1 June 2006 (UTC)

I have merged the Taxonomies section.  [[User:Ideogram|Ideogram]] 05:26, 1 June 2006 (UTC)

Ok since no one has spoken up, it must be ok to commit my changes to the current article.  I have done so.  Let's see if that stirs things up.  [[User:Ideogram|Ideogram]] 23:38, 2 June 2006 (UTC)

I have merged the Why programming languages? section.  I will wait a little while before committing it to the current article.  [[User:Ideogram|Ideogram]] 17:09, 3 June 2006 (UTC)

I have committed this change to the current article.  [[User:Ideogram|Ideogram]] 06:21, 4 June 2006 (UTC)

I have completed the merge, primarily involving merging the Elements section.  Again I will wait a little while before committing the changes.  [[User:Ideogram|Ideogram]] 06:54, 4 June 2006 (UTC)

: I'm not fully sure what the status is on everything, so if what I say isn't relevant, I apologize. In both the current and the merge articles, the "Type system" section refers to a main article. In both articles, the text that follows seems far too long. Since we're referring to a main article, the text that follows should only give a very cursory overview of the subject. Compare to the "Data structures" section in either article, which is of a much more appropriate length, I think. &ndash; [[User:Zawersh|Zawersh]] 07:58, 4 June 2006 (UTC)

::Yes, it is quite long but it ''is'' broken up into subsections static/dynamic and weak/strong.  The article referred to is quite long and more detail than most people want.  I think a section of about one page is long but not too long.  These concepts are important to understanding programming languages.  Does anyone else have an opinion?  [[User:Ideogram|Ideogram]] 08:05, 4 June 2006 (UTC)

::I have stripped away a lot of excess detail and tightened up the writing.  The result is about half the size.  What do you think?  [[User:Ideogram|Ideogram]] 05:08, 5 June 2006 (UTC)

I have committed the Elements section to the current article.  This completes the majority of the merge.  [[User:Ideogram|Ideogram]] 21:46, 4 June 2006 (UTC)

== WikiProject Programming languages ==

I am trying to revive [[Wikipedia:WikiProject Programming languages]].  [[User:Ideogram|Ideogram]] 16:39, 3 June 2006 (UTC)

== PL/I and Algol ==

Notes on [http://en.wikipedia.org/w/index.php?title=Programming_language&diff=56708487&oldid=56697100 my recent change]:
*Algol was developed in Europe by a consortium of Americans and Europeans.  I think PL/I was developed at IBM's lab in <s>Stuttgart</s> Hursley (England), presumably with input from the rest of the company.  PL/I may have won for political reasons, but it was not ''only'' because Algol was perceived as "European".  See, for example, [http://www.multicians.org/pl1.html the reasons the MULTICS project chose PL/I].
::Agreed, not only -- but a major cause (but only mentioned in a comment, anyway). [[User:Quota|quota]]
*PL/I has not influenced later language design on a scale comparable to Algol.  If you do a diff between Algol and PL/I, very little of that diff survives in later languages, whereas a great deal of the Algol core does.
::Given that many of the keywords are the same, it's hard to be definite.  However, certain key words  such as '''real''' and '''begin''' from Algol have died out almost completely, whereas the PL/I equivalents (float and do) are ubiquitous, and many scripting languages (such as the [[REXX]] family) follow PL/I closely. [[User:Quota|quota]]
*PL/I notation is not widely used in pseudocode.  Look at the code examples in the [[PL/I]] article.  This doesn't look much like the pseudocode used in, say, Knuth or Cormen/Leiserson/Rivest/Shamir.
::Those are all 'academic' sources (which certainly do tend to follow Algol, due to its use by ACM, etc.).  In commercial programming, PL/I-like code and pseudocode are prevalent. [[User:Quota|quota]]
*I don't see any harm in selecting a few languages that were influenced by Algol.  I chose Simula, Scheme, Pascal, and Modula because
*#The influence in these cases is especially obvious; all except Scheme adopt and extend Algol syntax, and all incorporate arbitrarily nested block-scoped procedures.
*#They were directly influenced, as opposed to indirectly influenced via another language.
*#These languages have, in turn, been influential in the design of other languages
:Not many languages satisfy these three criteria.  It can be argued, for example, that Java was influenced by Algol, but Java's direct antecedents were Smalltalk and C++, not Algol.  By contrast, the Scheme designers adopted lexical scoping directly from Algol; at its inception, Scheme was essentially Lisp + Algol.
::OK. [[User:Quota|quota]]

--- [[User:K.lee|k.lee]] 20:29, 3 June 2006 (UTC)

== APL ==

There should be some mention of APL under History.  I don't know enough to write it.  [[User:Ideogram|Ideogram]] 16:15, 4 June 2006 (UTC)

:  Why [[APL_programming_language|APL]] specifically and not say [[Snobol]] or any of the several other ''fringe'' languages that have been around for a long time? [[User:Derek farn|Derek farn]] 22:34, 4 June 2006 (UTC)

::APL has notably unusual characteristics.  It was the first array-oriented language and can be said to have started a paradigm.  It was influential on functional programming.  It is notoriously dense.  It and its descendants are still used today on Wall Street.

::I'm not familiar with SNOBOL, it seems to me largely notable for its string-handling.

::There is not a clear dividing line, of course; if someone wanted to argue for SNOBOL I would be willing to consider it.  But I think APL holds a pretty special place in programming language history.  [[User:Ideogram|Ideogram]] 23:33, 4 June 2006 (UTC)

::: The problem I see is that people are going to start adding in their own favorite ''influential'' language.  I would not be surprised if this starts to happen with the Fortran, Cobol, Lisp list of 'first' modern languages. [[User:Derek farn|Derek farn]] 23:58, 4 June 2006 (UTC)

::::I doubt that would happen.  And if it does happen, the Wikipedia way is to resolve it with discussion and by consensus.  Does anyone else have an opinion on APL?  [[User:Ideogram|Ideogram]] 00:11, 5 June 2006 (UTC)

:::::I've used APL (a lot, long ago), SNOBOL (not much), FORTRAN (some), LISP (more), COBOL (with a gun to my head), and C/C++ (untold hours) since early in their inception.  I guess I'm the living dinosaur in the crowd.  In a historical account of the day, SNOBOL is distinctly less important than APL. SNOBOL has a relationship to Perl about on par with the important, yet once or twice removed influence of Simula on Java.  APL, along with LISP, is the partial progenitor of the functional programming idiom.  APL provided the first spreadsheet-like interactive console well suited to teletypes with that strange yellow paper, the better implementations were among the first examples of just-in-time compilation, it was a pointer/reference free language that managed the free store interactively.   The mathematical primitives were powerful enough that it spawned a dedicated class of vector processing machine (much like Java's JVM).  It was one of the first languages to make an interactive time-share service possible.  IP Sharpe was well established in the "Grid computing" game back in the late 1970s with APL as the core vehicle.  APL proved especially well suited to statistical analysis and gained a strong commercial foothold in the actuarial business.  Anyone who gained fluency in APL continued to use it as a RAD tool for algorithm development long after it was widely conceded that APL code was unmaintainable.  Imagine trying to operate a timeshare service on COBOL over 300 baud dial-up networking.  On glass interfaces, the APL workspace was surprisingly spreadsheet-like.  It usually provided a huge back-scroll buffer.  You could scroll back to any line, edit the contents of the line, then press enter to reinvoke the command, whose output was then appended to the session log.  Problems: use of the overprinting Greek character set was elitist and non-standard, it had the software engineering robustness of writing an orbital mechanics package in Microsoft Excel (I'm sure it could be done, but would you *want* to maintain it afterward?), it had terrible support for heterogenous aggregates (combining strings, booleans, integers into the same data structure), no support for a function call taking more than two arguments, and no structured programming iteration constructs (while, for, if/else).  On the contrary, it strongly encouraged the use of its powerful set of mathematical primitives to make iteration and conditional statements unnecessary, or to use recursion to express those ideas wherever possible.  In effect, it pushed you in a functional programming direction whether it was immediately convenient or not.  In my own opinion the worst defect of all was having no way to create or maintain a library independent from the active workspace.  What you would do is maintain a workspace with a set of related library primitives (and funny prefixes on the function names to designate their kinship) and then *import* each library workspace into the application workspace separately, such that the application workspace gained a copy of all the imported code (and any interactive global variables that came with it).  No APL I ever worked with allowed to workspaces to be active concurrently.  To maintain a library, you had to save your application workspace, load the library, change and debug it, then save it, reopen your application, import a fresh copy of the changed code, and cross your fingers.  If internal functions of the library workspace were deleted, you would still have these lingering around in your application workspaces unless you conscientiously rooted them out.  As applications scaled, the application workspace became the worst kind of mosh pit one could imagine.  This sounds worse than it was in practice.  APL was so concise, you were still in RAD mode when the same programming effort in another languages gained the scale of a graduate school dissertation.  C++ as a language remains partially crippled by drawing into itself assumptions that prevailed when C itself was first conceived.  APL died because it was designed toward using a 110 baud yellow paper teletype as a quick and dirty way to gain *interactive* access to the computational power of a Cray-like supercomputer.  As a physicist (most early APL programmers were physicists by training) you could get a *lot* done in that crappy paper console environment.  Everything that made APL great in that respect equally made it one of the all-time nightmares in software engineering. The horror you rarely ever had to deal with was sloppiness.  Like they say about Haskell now, it wasn't easy to write bad code that worked at all.  I learned everything important I now know about software engineering from my days with APL: because it never pretended to address the problem in part measure.  When I'm contemplating an algorithm, I use my APL brain; when I'm contemplating any other aspect of program creation, I use *anything* else.  The essential feature of the APL experience is that the language was extremely stark: both for what it offered, and what it didn't.  By contrast, as much as I can recall about SNOBOL, it the kind of overstuffed PL/1-ish syntax that causes you to drag your old sofa out to the curb in hopes someone is dull enough to think it might be a good idea to drag it off to a new home.  I couldn't sit down to SNOBOL now with the overwhelming sense that I was on the production set of "That Sixties Show".  The notion of textual representation (strings) as a fundamental data type leads all the way through Perl and SGML to modern XML.  In its soul, APL had the tightest kinship to LISP.  Everything at the surface was a study in contrasts: homogenous arrays vs heterogenous lists, rigid infix notation with extremely spare use of parentheses vs rigid prefix notional with maximal use of parentheses, streamlined large-scale statistical analysis vs logic-heavy expert systems.  An interesting point about LISP is that it guessed wrong about certain major classes of applications.  Speech recognition was first tried from the expert system approach and never worked very well; later it was approached from the Markovian perspective (a more APL-friendly computational framework) and it worked fine.  LISP is too much in the heavens for its own good.  I always found it easy to flip between APL and LISP because they shared the same soul.  Except I vastly preferred mentally disentangling the rich and distinctive set of Greek letter to the generic uninformity of the parethetical hinterland.  APL was like the Chinese ideographs: once you learn them, ideas jump straight into your mind, completely bypassing one level of intermediate processing.  LISP is the modern day Hawaaiin.  What does that language have, about ten letters to the alphabet?  One thing I would like to point out very strongly about APL, it was the first language that caused you to mentally read f(g(x)) as (fog)(x) on a very deep level.  The people who couldn't make that shift just couldn't function in APL at all.  You '''thought''' of yourself as '''composing the operators''', not cascading data through a succession of function calls.  For that reason I say APL was highly influential in the functional programming camp that originated later.  For that reason APL forced you to confront certain aspects of your programming talent in a way that FORTRAN or COBOL never could.  If you survived the experience, it made you stronger, permanently.  Even when APL was already on the out, people approached APL in the same spirit that people now approach Ruby: it could make you think in new ways.  An experience that Java never offered.  The corporate forces don't necessarily want programmers to think in new ways so languages like Ruby end up with a cultish overtone (through no fault of its own).  I haven't had the APL feeling again until C++ introduced (more precisely, reluctantly stumbled into) template metaprogramming.  Liberating on certain interesting levels if you survive the experience.  Does any of this warrant a comment in the main text?  I think a few extremely concise sentences about APL are warranted.  Iverson would like that.  [[User:MaxEnt|MaxEnt]] 22:24, 8 June 2006 (UTC)

== deletion of "Purpose" ==

I think there needs to be a wider debate on whether this needs to be deleted.  Deleting an entire section is a pretty major change.  Obviously I thought it was useful since I included it in the merge.  Any other opinions on this matter?  [[User:Ideogram|Ideogram]] 21:41, 4 June 2006 (UTC)

: I think it is a useful section, too. I agree with the person who deleted it that it doesn't cover all programming languages, but the solution isn't to delete the section. The solution would be to improve it. Brief mention of [[visual programming language|visual languages]] and [[logic programming|logic-based]] languages might be welcome. (Logic programming actually contradicts some of what the section says&mdash;it does fill in the gaps, rather than requiring a step-by-step path.) I think a larger problem is that much of the section didn't discuss their purpose so much as how they work and are used. Those aspects are important, but perhaps could be restructured a bit. In any case, I am in favor of restoring what was deleted&mdash;even if it could be improved, removing it seems detrimental to me. &ndash; [[User:Zawersh|Zawersh]] 22:02, 4 June 2006 (UTC) 

: This ''Purpose'' subsection was added relatively recently and contains a mismash of different ideas.  I'm sure that some of these would be of interest to readers (eg, the practical problems associated with writing programs), while others are simply wrong (eg, the idea that all programs express computation and that all programming languages require an exact specification).  Other wording reads like a novel (eg, "In return for this exacting discipline, programming languages reward the user with a unique power:"). [[User:Derek farn|Derek farn]] 22:29, 4 June 2006 (UTC)

::I think the definition of ''computation'' as "the task of organizing and manipulating information" is sufficiently general to cover all programming languages.

::Even high level and logic programming languages require a degree of exactness from human programmers not present in natural language.  The statement that computers "have only limited ability to 'understand' human language" is exactly right in my opinion.  There is the paragraph at the end which mentions that languages have developed to "let programmers express ideas that are more removed" from the hardware.

::As for wording, that can be easily corrected without deleting the whole section.  [[User:Ideogram|Ideogram]] 22:42, 4 June 2006 (UTC)

As for a "narrow view", the vast majority of programming languages are procedural.  An encyclopedic overview of the subject can be forgiven for concentrating on this paradigm.  And even functional languages can't infer everything from a "what" description, they need some details about an algorithm to proceed.  [[User:Ideogram|Ideogram]] 21:50, 4 June 2006 (UTC)

:This claim is a bit fuzzy.  FP folks contrast FP with "procedural", which leaves a "vast majority" on the other side (except for "delarative" and "logic" programming, which are sort of in neither place).  OOP folks, however, often contrast OOP with procedural programming.  Obviously, for FP folks, OOP is a type of procedural, but OOP folks tend not to characterize it that way.  OOP programming is certainly widespread enough not to leave a "vast majority" outside of it. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 01:10, 5 June 2006 (UTC)

=== Should be restored ===
:''Copy of whole text: [[/Purpose]]''

I've been asked to take a look at this dispute.  At first brush, it seems to me that the "Purpose" section contains several relevant concepts that are not elsewhere addressed in the article.  There is a bit too much of a advocacy tone in the section, I think, but the general idea of pointing to the requirement for formalism and contrasts with natural and other artificial languages/codes seems quite relevant.  I think maybe it could use a little bit of tweaking, but in general the section should be restored. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 01:04, 5 June 2006 (UTC)

===Purpose===

: The title ''Purpose'' does not describe the contents below. [[User:Derek farn|Derek farn]] 22:51, 4 June 2006 (UTC)

::Can you suggest a better title?  [[User:Ideogram|Ideogram]] 23:26, 4 June 2006 (UTC)

::: This is really a mishmash of material that should be scattered over various subsections or not included.   [[User:Derek farn|Derek farn]] 01:13, 5 June 2006 (UTC)

:::: This is an important question, though the current answer is not extremely well organized.  But having made the point about Turing completeness above, the obvious question for the reader is, why are there so many of these things if they're really 'all the same'? [[User:Saccade|kraemer]] 03:20, 14 June 2006 (UTC)

Like other specialized languages, such as [[musical notation]] and [[mathematics|mathematical]] formulae, programming languages facilitate the communication of a specific kind of knowledge, namely, ''computation'', or the task of organizing and manipulating information.  For example, a programming language might enable its user to express the following:

* A step-by-step procedure for [[sorting]] a list of names in [[alphabet|alphabetical]] order.
* A set of precise rules for predicting the future motion of [[planet]]s in the [[solar system]].
* A specific [[Communications protocol|protocol]] allowing computers to communicate over the [[Internet]].

: Um, yes.  It would probably need to be specific.  [[User:Saccade|kraemer]] 03:20, 14 June 2006 (UTC)

Programming languages differ from most other forms of human expression in 

: Should say "Some programming languages ..."  [[User:Derek farn|Derek farn]] 22:51, 4 June 2006 (UTC)

:: Exception?  [[User:Saccade|kraemer]] 03:20, 14 June 2006 (UTC)

that they force the author to write instructions with exceeding precision and completeness.  In a natural language, or even mathematical notation, authors can be ambiguous and make errors.  For example, consider natural 

: Mathematical notation can contain errors?  So can programs, but they are not intended. [[User:Derek farn|Derek farn]] 22:51, 4 June 2006 (UTC)

::Mathematical notation written on a chalkboard in a lecture often contains errors that may or may not confuse students.  [[User:Ideogram|Ideogram]] 22:56, 4 June 2006 (UTC)

::: More to the point, a certain amount of syntax abuse isn't only acceptable when expressing a mathematical idea, it can often be helpful, at least to people who are trying to get a first-pass intuition for something. 03:20, 14 June 2006 (UTC)

language:

* Speakers can leave things out, because humans excel at "filling in the gaps" of a partial statement.  If someone says: "Going to the store," the listener might use the context to fill in the missing words: "I am going to the store on the corner."

: A number of languages allow programmers to leave things out and the compiler figures out what was intended. [[User:Derek farn|Derek farn]]

::This could be reworded, but the point is that humans "fill in the gaps" much better than any compiler ever did.  [[User:Ideogram|Ideogram]] 22:57, 4 June 2006 (UTC)

::: Depends on the requirements of the language.  [[Cobol]] has all sorts of implicit behavior (one of the design aims was to make it English language 'like'.  PL/1 requires support for all sorts of implicit conversions and figuring out what behavior actually occurs can be a major undertaking.  I'm sure an article discussing the trade-off between expressive power, ambiguity, programmer convenience, and likelihood of a mistake being made would be of interest to many people.   [[User:Derek farn|Derek farn]] 01:13, 5 June 2006 (UTC)

::::You can't possibly argue that COBOL or PL/1 approach the ambiguity and error-correcting features of natural language.  [[User:Ideogram|Ideogram]] 01:20, 5 June 2006 (UTC)

:::: Natural languages do not have error correcting features.  Most human communication contains a great deal of redundancy, while programming languages have much less redundancy. [[User:Derek farn|Derek farn]] 10:44, 5 June 2006 (UTC)

:::::Natural languages are spoken by humans who use the redundancy in them to correct errors.  This is purely a semantic argument and is not productive.  [[User:Ideogram|Ideogram]] 15:07, 5 June 2006 (UTC)

:::::: Agreed. [[User:Saccade|kraemer]] 03:20, 14 June 2006 (UTC)

* Speakers can make grammatical errors, because humans excel at compensating for minor errors in language.  If someone says, "I am going to the store am the corner," the listener can usually tell that "am" is meant to be "on".

But because computers are not yet able to "fill in the gaps", and have only limited ability to "understand" human language, every part of every computation must be expressed explicitly and exactly in a programming language.

: Not true.  To start with logic languages require users to specify the what, not the how.  Some languages (eg, SQL) do not provide no means of specifying any computation.   [[User:Derek farn|Derek farn]] 22:51, 4 June 2006 (UTC)

::Please note the definition of ''computation'' used at the top of the article:  "the task of organizing and manipulating information".  This is not equivalent to specifying an algorithm in a procedural manner.  [[User:Ideogram|Ideogram]] 23:00, 4 June 2006 (UTC)

::: My point was that programs is some languages do not express computations. [[User:Derek farn|Derek farn]] 01:13, 5 June 2006 (UTC)

::::In what sense do logic languages and SQL not perform "the task of organizing and manipulating information"?  [[User:Ideogram|Ideogram]] 01:21, 5 June 2006 (UTC)

::::: But that's exactly the point.  Logical languages specify the result of a computation, and it's up to the compiler to figure out how to make it happen.  It's extremely misleading to say that "every part of every computation" is expressed "explicitly" -- the entire point of a computer language is to make the predictable and boring bits implicit, while communicating to the reader the parts that really matter. [[User:Saccade|kraemer]] 03:20, 14 June 2006 (UTC)

Each phrase in a program corresponds unambiguously to its literal meaning, and no more.

: "... its literal meaning..."  What about ''phrases'' that have unspecified, undefined, or implementation defines behaviors?  [[User:Derek farn|Derek farn]] 01:13, 5 June 2006 (UTC)

:: Conditional agreement -- this is true with respect to implementations, but not to specs. [[User:Saccade|kraemer]] 03:20, 14 June 2006 (UTC)

If the author of a program states that the program should perform an incorrect step, the program's meaning will include that incorrect step.  If the author omits a necessary step, the program's meaning will not include that step.  Therefore, in order to write a "correct" program, the author must be correct in every detail.

: This belongs in an article on writing programs, not on programming languages. [[User:Derek farn|Derek farn]] 22:51, 4 June 2006 (UTC)

::I agree this can be deleted.  [[User:Ideogram|Ideogram]] 23:01, 4 June 2006 (UTC)

In return for this exacting discipline, programming languages reward the user with a unique power: Many programming languages are ''executable'' by an electronic computer.

:  This belows in a pulp novel, or if it must be included then in an article on writing programs. [[User:Derek farn|Derek farn]] 22:51, 4 June 2006 (UTC)

::The wording could be improved, but the point that programming languages are executable languages is pretty critical.  [[User:Ideogram|Ideogram]] 23:02, 4 June 2006 (UTC)

::: It's silly, but true.  It should clearly be rephrased, but if you can manage to clearly describe your problem in a compilable language, you're not gonna have to bust out the slide rule.  [[User:Saccade|kraemer]] 03:20, 14 June 2006 (UTC)

In other words, tasks expressed in most programming languages can be performed autonomously by a computer, without human intervention.  Therefore, programming languages have enormous practical utility; they enable the construction of programs that automatically perform tasks.  The entire [[information technology]] industry is built around the construction and use of programs.  A ''programming language implementation'' is a system that enables a computer to execute a program written in a programming language.  Programming languages can be implemented by an [[interpreter (computing)|interpreter]], a [[compiler]], or some combination of both.

: This belongs in an introductory text on computers. [[User:Derek farn|Derek farn]] 22:51, 4 June 2006 (UTC)

::This could be deleted; the point about interpreters and compilers is useful but duplicated elsewhere.  [[User:Ideogram|Ideogram]] 23:04, 4 June 2006 (UTC)

::: Agreed [[User:Saccade|kraemer]] 03:20, 14 June 2006 (UTC)

Many languages have been designed from scratch, altered to meet new needs, combined with other languages, and fallen into disuse.  Although there have been attempts to make one "universal" computer language that serves all purposes, all of them have failed.  The need for diverse computer languages arises from the diversity of contexts in which languages are used:

: Good points.  This needs to be said somewhere. [[User:Derek farn|Derek farn]] 22:51, 4 June 2006 (UTC)

* Programs range from tiny scripts written by individual hobbyists to huge systems written by hundreds of programmers.
* Programmers range in expertise from novices, who need simplicity above all else, to experts, who may be comfortable with considerable complexity.
* Programs may need to extract the right amount of performance on platforms ranging from tiny microcontrollers to [[supercomputer]]s.  

: These are actually rather similar -- in both of these contexts we're normally trying to squeeze maximum performance out of limited resources.  The true contrast is actually with home computers, which usually have lots of spare cycles to spend on chrome. [[User:Saccade|kraemer]] 03:20, 14 June 2006 (UTC)

* Programs may be written at one time, to reflect some exacting constraints, and then not changed for generations, until these constraints change, or they may undergo nearly constant modification.

: This is really important, but not really about programming languages -- it's more about technique. 03:20, 14 June 2006 (UTC)

* Finally, programmers may simply differ in their tastes or habits:  they may be accustomed to discussing problems and expressing them in a particular language.  Languages like [[COBOL]] and '[[C (programming language)|C]]' proved surprisingly persistent despite some deficiencies often observed.  Some credit [[William H. Gates III]]'s devotion to [[BASIC]] for keeping that language alive to this day.

One common trend in the development of programming languages has been to add more ability to solve problems on a higher level.

: Another trendy has been towards simpler languages that do everything through librray calls. [[User:Derek farn|Derek farn]] 22:51, 4 June 2006 (UTC)

::I don't know if you can call this a "trend"; C certainly was a simple language that did everything through library calls.  [[User:Ideogram|Ideogram]] 23:06, 4 June 2006 (UTC)

::: This definitely isn't a "trend" -- some especially good languages for high-level expression of various types of abstract computation include LISP, APL, and haskell -- I challenge anyone to fit a meaningful temporal model.  [[User:Saccade|kraemer]] 03:20, 14 June 2006 (UTC)

The earliest programming languages were tied very closely to the underlying hardware of the computer.  As new programming languages have developed, features have been added that let programmers express ideas that are more removed from simple translation into underlying hardware instructions.

: Good points, needs some rewording.  [[User:Derek farn|Derek farn]] 22:51, 4 June 2006 (UTC)

:: Agreed. The ideas aren't more removed; their expression is.  [[User:Saccade|kraemer]] 03:20, 14 June 2006 (UTC)

Because programmers are less tied to the needs of the computer, their programs can do more computing with less effort from the programmer.  This lets them write programs in ways that are closer to the way they think about the problems they are solving.  It also lets them write more programs in the same amount of time.  And because the programs are written more like how they think about the problems, it is easier for a new programmer to understand a program that was written by somebody else.

: A very bold claim.  Where is the evidence?  [[User:Derek farn|Derek farn]] 22:51, 4 June 2006 (UTC)

::It has long been known that higher-level languages are more productive than lower-level languages.  From "The Mythical Man-Month", pages 93-94:

::"Corbató ... reports ... a mean productivity of 1200 lines of debugged PL/I statements per man-year ...

::" ... Corbató's number is ''lines'' per man-year, not ''words''! ...

::"* Productivity seems constant in terms of elementary statements, a conclusion that is reasonable in terms of the thought a statement requires and the errors it may include.

::"* Programming productivity may be increased as much as five times when a suitable high-level language is used."

::[[User:Ideogram|Ideogram]] 23:27, 4 June 2006 (UTC)

::: Interesting quotes, do you have a reference?  See: Lutz Prechelt. "The 28:1 Grant/Sackman legend is misleading, or: How large is interpersonal variation really?" Technical Report iratr-1999-18, Universität Karlsruhe, 1999. for an example of how results in 'old' papers get misunderstood and an ''urban legend'' is born.  [[User:Derek farn|Derek farn]] 01:13, 5 June 2006 (UTC)

::::I included the reference above, "The Mythical Man-Month".  Even if ''you'' think it's an ''urban legend'' the fact that it's verifiable makes it fair game for inclusion in an encyclopedia.  [[User:Ideogram|Ideogram]] 01:17, 5 June 2006 (UTC)

::There are a few claims there. Which are you calling into question? Just the last bit, "it is easier for a new programmer to understand a program that was written by somebody else", or other parts as well? &ndash; [[User:Zawersh|Zawersh]] 01:46, 5 June 2006 (UTC)

:: I am calling all of them into question.  If you read old papers you will find that many of them are based on very small sample sizes and the results are open to several interpretations.  Go read about the Grant/Sackman urban legend, this has been repeated in umpteen books and is incorrect. [[User:Derek farn|Derek farn]] 10:44, 5 June 2006 (UTC)

::: I looked up Grant/Sackman and skimmed over it. What I read indicated that it deals with variance in productivity due to differences in individual programmers. It didn't seem to address high-level versus low-level languages. I'm not sure if you're citing it only as an example that old papers can lead to "urban legends" or if you're citing it as evidence against this passage, but it only seems to work for the former. (Unless I'm missing something?) I'm not a huge fan of the passage above, but it does express one idea that seems fairly obvious to me: as a generalization, high-level language allows for more productivity than lower-level language. For example, if someone is working in the medical imaging field, they'll be able to develop software solutions for many problems much faster and probably more accurately with IDL than with an assembly language. I did a quick bit of searching last night and wasn't able to find any papers that directly support this (nor did I find any that contradict it), but it seems pretty self-evident to me. It does of course have exceptions: low-level device drivers and operating systems would be hard to write in high-level languages. It also has caveats: a language that doesn't target one's problem domain may not be as successfully used as another language that does. But the fundamental concept seems sound. Having written all this, however, I'm realizing that perhaps this is something that should go into a different section. A major aspect of using programming languages is selecting the right one for a given task. Would a short section on that topic, covering the few points I just mentioned, be appropriate for this article? &ndash; [[User:Zawersh|Zawersh]] 13:09, 5 June 2006 (UTC)

::::Let's see a more relevant reference.  That's the way we do things here, if you argue for something, you have to verify it.  Saying it's an old paper doesn't cut it.  [[User:Ideogram|Ideogram]] 15:12, 5 June 2006 (UTC)

::: [[User:Zawersh|Zawersh]] you are right to say that my point was to illustrate how urban legends grow up around rarely read papers.  For as long as I can remember it has been popular to cite "The Mythical Man-Month" as the reference for some software engineering theory.  Brooks cites the Sackman/Grant paper (Chapter 3 note 1) for his source of a 25-1 productivity difference and I suspect that many of his other references are themselves of poor statistical quality or are misquoted.  Brooks is a great read and people are still making the mistakes he experienced, but he is not the font of software engineering knowledge.   [[User:Derek farn|Derek farn]] 18:44, 5 June 2006 (UTC)

::::You aren't going to make much headway by arguing against the reliability of widely respected sources.  This is about verifiability, not your ''opinion'' that he is "not the font of software engineering knowledge."  [[User:Ideogram|Ideogram]] 19:03, 5 June 2006 (UTC)

: I'm sorry, but does anyone actually think that this isn't true, at least in the limiting case?  Seriously, who writes all of their code in assembly?  Even if you think that things have been going downhill since FORTRAN 2, you don't have to be Paul Graham to believe that it's easier to understand code that's written in a higher level language.  [[User:Saccade|kraemer]] 03:20, 14 June 2006 (UTC)

== thank you all participants ==

I would like to thank all of you participating in editing and discussing this document, even the ones I disagree with.  It is exhilarating to work with equally talented peers on a subject of shared interest.  [[User:Ideogram|Ideogram]] 04:12, 5 June 2006 (UTC)

== History merge ==

I propose that the content from the History section be merged into [[History of programming languages]]. Right now, that article is a skeleton without much content. It has the potential for being a rich article, and it would allow for greater detail to be included than would be appropriate for this article. The history section in this article could then be either condensed or left as is, but with a link to [[History of programming languages]] as the main article for the section. Any thoughts? &ndash; [[User:Zawersh|Zawersh]] 13:20, 5 June 2006 (UTC)

Sounds like a good idea.  [[User:Ideogram|Ideogram]] 15:09, 5 June 2006 (UTC)

You can go ahead and copy content to [[History of programming languages]] and discuss how to edit this article as a separate step.  [[User:Ideogram|Ideogram]] 15:24, 5 June 2006 (UTC)

: I've copied the history section to the history article, weaving in the bits of possibly useful content that were already there. If anyone objects, feel free to revert and provide feedback either here or in the history article's talk page. I'm not too knowledgeable on the history myself, so I won't be able to expand it much myself, but hopefully it will encourage additional contributions. Given that there's so much conflict at the moment, I'm going to hold on off doing anything in this article until things have calmed down some lest I introduce another point of contention. &ndash; [[User:Zawersh|Zawersh]] 03:56, 6 June 2006 (UTC)

::Thank you.  [[User:Ideogram|Ideogram]] 03:57, 6 June 2006 (UTC)

== syntax edits ==

I feel [[User:Derek farn]]'s edits here add words without adding content.  Please discuss.  [[User:Ideogram|Ideogram]] 19:47, 5 June 2006 (UTC)

*"purely" doesn't really add content here.
*Derek farn seems to have something against semicolons.  I feel they are a valid punctuation mark that reduces wordiness.
*The clarification that symbols can be words and punctuation marks is unnecessary.  We already mention graphical programming langauges are "more" graphical, and "symbols" is usually understood to include letters and punctuation marks.
*"the following examples" there is only one example, and some discussion of lexical structure and BNF precedes it.
*"The following example" is wordy.
*Language specification is a difficult subject and rather than try to explain it I prefer to delete the undefined term.
*There is a parallel sentence structure here that makes the analogy between having bugs and having a false sentence.  We need to explain that a syntactically correct program may not have the effects the programmer intended.
*The final statement is true of all natural languages, not just English.  And we don't have to mention we are using English as an example, that is self-evident.

[[User:Ideogram|Ideogram]] 20:24, 5 June 2006 (UTC)

"Meaning can only be defined by a language specification."  Most language specifications (ANSI standards for instance) focus on syntax.  Fully specifying a language semantics implies a formal language, which does not correspond to any widely used language.  Furthermore even a formal language must leave out details of the programmers ''intent'' which I submit is a large part of programming semantics.  [[User:Ideogram|Ideogram]] 20:30, 5 June 2006 (UTC)

: It sounds like you have never read any non-toy language specfications.  Unfortunately the ANSI ones cost money (although only $19 each for C and C++).  The Java language spec can be downloaded free from Sun's web site.  Your local univrsity library may hold copies of ANSI Standards.  Anyway, go and read some and see how littl eof the material is syntax related.  [[User:Derek farn|Derek farn]] 20:50, 5 June 2006 (UTC)

::Ultimately it comes down to verification.  If you can verify this statement, I will accept it.  [[User:Ideogram|Ideogram]] 20:52, 5 June 2006 (UTC)

:::Most language specifications define semantics.  See, e.g.:
:::*[http://www.schemers.org/Documents/Standards/ Scheme R5RS]
:::*[http://www.masswerk.at/algol60/report.htm Algol 60 report]
:::*[http://www.adahome.com/rm95/ Ada 95 reference manual]
:::*[http://java.sun.com/docs/books/jls/ Java language specification]
:::*[http://www.csci.csusb.edu/dick/c++std/cd2/index.html Draft C++ standard]
:::Hopefully that's a broad enough sampling. [[User:K.lee|k.lee]] 21:43, 5 June 2006 (UTC)

::::The emphasis on semantics is beyond dispute.  APL and LISP can define their syntax almost on a single beer napkin.  Neither of those languages have keywords such as "const", "volatile", "template" or "using" to muddy the waters.  APL has no syntax to declare or describe types at all.  It defines a few type literals (character strings, integers, floats) otherwise type is always inferred.  Almost the whole of the language was the elegance of the extended mathematical operator set.  Here's a data point from the C language:  

<pre> 
  char* p = malloc (0);
  char* q = malloc (0); 
  assert (p != q);  
  if (p) free (p); // error to free p otherwise 
  if (q) free (q); 
</pre>

::::First, there was a tempest about whether the language is required to accept malloc (0) as a valid operation; I think it ended up being implementation defined because some "protect the user" implementations refused to remove their lint detector concerning this construct.  Another camp (of which I'm a long standing member) was horrified to see zero treated as a special case value.  

::::The language defines that no two concurrently valid memory blocks returned from malloc() have the same address, so you can compare p with q to determine if they came from the same (successful) malloc.  Since NULL is used to represent an invalid allocation, the language defines it as an error to attempt to free it again.  These are the super nitpicky details that every language standard is made from.  

::::Another infamous semantic dispute is the definition of the modulus operator for negative integers.  I tend to put my weight behind establishing the simplest and strongest invariant.  

<pre>
  unsigned int mod (int x, unsigned int m) { 
    unsigned int r = x % m; 
    assert (0 <= r && r < m); // elegant semi-open invariant 
    return r; 
  }
</pre> 

::::You can argue for an elegant reflection symmetry to handle integer m capable of taking on negative values.  Worthless in the C langauge because the pointer dereference operator is not available in a reflected complement (if you think of a pointer as being like a stick cursor in a text document there the "next" character is different depending on which direction you are interating).  Which means that negative modulands have effectively no practical application because the language doesn't inately support reflection transformations.  Given that realization, what do you impose on the language standard?  Bear in mind that code to conform to a strict definition can sap your performance in the common case that occurs 99.999% of the time.  The invariant above would require that the modulus operator return zero always when m <= 0.  Not much of an imposition on the implementation, but you have to be wary about the type returned:    

  template <typename T> T (int x, T m) {
    unsigned int r = 0; 
    '''if (m > 1)''' r = x % m; 
    assert (0 <= r && r < m); // elegant semi-open invariant 
    return r; 
  }
   
::::And no, I'm almost 100% sure than neither C/C++ nor any other language I've used defines modulus this way.  It wasn't until Eiffel came along and fully internalized some of what Dijkstra had to say that the simplicity and strength of invariant return became the conscious centerpiece of the analysis.  If the invariant requires a non-negative return value, maybe the return type should be an unsigned quantity?  That interacts with the C type system further downstream in the same expression, in perhaps surprising ways.  In the C language, where subscripting an array with an negative index is easy to do, and not so often what you intended, do you really want to encourage arithmetic primitives to return negative values more than practical considerations would dictate?  In a language that promises to catch every such mistake (at compile time when possible, or at run time) you might have different sensibilities on this matter.  

::::Languages standards are etched in green cheese.  There are no turtles.  It's green cheese, all the way down.  The moldy rind (syntax) is the least of your concerns.  The C++ standard devotes about a 100 pages to template argument function overload resolution, and hardly any of that concerns the syntax of template function declarations or function invocations. [[User:MaxEnt|MaxEnt]] 01:16, 9 June 2006 (UTC)

== programming language implementation ==

This is currently a broken link.  Does anyone intend to write this article?  If not, I prefer not to include it.  [[User:Ideogram|Ideogram]] 20:50, 5 June 2006 (UTC)
:Added a stub.  Not entirely satisfying, but IMO this is important to have an article that unifies the common material in [[compiler]], [[interpreter]], [[virtual machine]], etc., and adds some discussion of the principles of runtime systems and other pragmatics.  See [http://en.wikipedia.org/wiki/Category:Programming_language_implementation the category] for a subset of the stuff that should be discussed in [[programming language implementation]] eventually. [[User:K.lee|k.lee]] 21:35, 5 June 2006 (UTC)

== purpose rewrite ==

I have edited the purpose section in my copy at [[Talk:programming language/merge]] to condense it and try to address some of the objections.  Please feel free to edit and comment.  [[User:Ideogram|Ideogram]] 21:03, 5 June 2006 (UTC)

: Why do you persist in trying to add this mish-mash of disjoint ideas and poor rewrites of existing material?  [[User:Derek farn|Derek farn]] 21:31, 5 June 2006 (UTC)

::I think you need to concede that consensus is that this is a useful section.  You make good points and we value your participation in making it better but it looks like deleting it entirely is off the table.  [[User:Ideogram|Ideogram]] 21:36, 5 June 2006 (UTC)

::You can of course write your own version from scratch that addresses the same goals and we can discuss it, but deleting the section entirely is not the way to achieve that.  [[User:Ideogram|Ideogram]] 22:02, 5 June 2006 (UTC)

: Anybody here know how to put a section up for a vote?  [[User:Derek farn|Derek farn]] 21:48, 5 June 2006 (UTC)

::Fine, let's have a vote.

:: I seem to recall there is a procedure to follow.  POinters anybody?  [[User:Derek farn|Derek farn]] 21:56, 5 June 2006 (UTC)

::: See [[Wikipedia:Straw polls]]. However, note that [[WP:NOT|Wikipedia is not a democracy]]. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 23:27, 5 June 2006 (UTC)

::::Well apparently a vote is not binding anyway.  How do you propose to resolve this?  I suggest you write your own version from scratch.  If you can't or won't do that, we are left with this, which is better than nothing.  [[User:Ideogram|Ideogram]] 23:44, 5 June 2006 (UTC)

:::: My problem with this material, as a subsection, is that it tries to cover too broad a range of subjects.  There are a number of points it discusses that belong in an article on programming languages.  Let's put each point in the subsection in which it belongs (open to suggestions on this point).  This is not a standalone article.  Let's  cut out the 'good' parts and merge them into the existing material.  [[User:Derek farn|Derek farn]] 00:43, 6 June 2006 (UTC)

::::Please see [[User talk:Allan McInnes#voting procedure]] for an outline of how to approach this debate.  [[User:Ideogram|Ideogram]] 00:02, 6 June 2006 (UTC)

::::Do you agree we need a subsection describing why programming languages exist, and what need they fill?  [[User:Ideogram|Ideogram]] 01:57, 6 June 2006 (UTC)

:::: Why they exist?  You mean the economic considerations that favor them over writing in hex or assembler?  Sounds useful.  [[User:Derek farn|Derek farn]] 02:02, 6 June 2006 (UTC)

::::The average layperson doesn't have a clue what hex or assembler is.  The average person ''does'' have a clue what natural languages are, and may wonder about the relationship between programming languages and natural languages.  In fact, when I explain what I do for a living to laypeople, this is one of the most frequent questions.  I have never in my life been asked by a layperson why people program in high-level languages rather than hex or assembler, because programmers are the only people who even know about those things, and they already know the answer.  The motivation for ''high-level languages'' should also be in the article (and, indeed, it is already mentioned under the history section), but first the article needs to explain why programming languages need to exist at all. [[User:K.lee|k.lee]] 02:25, 6 June 2006 (UTC)

:::::The current "purpose" section covers these points:
*****Programming languages facilitate communication
*****Programming languages are different from natural languages
*****Programming languages are executable
*****Many languages are needed for different contexts
*****Programming languages have become higher level

::::::Which subtopics do not belong here?  [[User:Ideogram|Ideogram]] 02:29, 6 June 2006 (UTC)

*'''Approve'''.  [[User:Ideogram|Ideogram]] 21:52, 5 June 2006 (UTC)
*'''Approve'''.  [[User:K.lee|k.lee]] 21:58, 5 June 2006 (UTC)  (Considerable rewrite may be needed, but I think we obviously need a section that explains ''why'' programming languages exist.)

=== Quick poll on "purpose" section ===

I see some "votes" above, but it's not clear exactly what they are "approving" of.  I believe a clarification would allow the votes to be more meaningful.  How about:

:''Should a section entitled "purpose" be included in this article?  If included, such a section would attempt to highlight differences between a programming language as formalized artificial language and a natural language.  In particular, such a section would emphasize the relative error intolerance of programming languages and their ability to instruct a computer to carry out computations.''

==== Support inclusion ====
# <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 02:12, 6 June 2006 (UTC)
# [[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 02:34, 6 June 2006 (UTC)
# [[User:Ideogram|Ideogram]] 02:37, 6 June 2006 (UTC)
# [[User:Zawersh|Zawersh]] 03:35, 6 June 2006 (UTC)

==== Oppose inclusion ====
#
#
#

== library section ==

I'm not sure we need a library section.  Although the line is fuzzy, and many languages come to be intimately tied to their standard libraries (C comes to mind) strictly speaking libraries are not part of programming languages.  Harbison and Steele discuss the C library in what amounts to an appendix, and say "Many facilities that are used in C programs are not part of the C language as such but are part of 'standard libraries' ...".  [[User:Ideogram|Ideogram]] 23:02, 5 June 2006 (UTC)

: The line does become fuzzy as you cast your net wider, but i think most non-trivial programming languages have a definite standard library "core" which, in practice, is at least as important and fundamental to the language as its syntax and semantics.  Some examples:
:* [[Haskell programming language|Haskell]]'s Prelude
:* [[Java programming language|Java]]'s <code>java.lang</code> namespace (which is required by (among other things) syntactical constructs like the enhanced for loop)
:* [[Python programming language|Python]]'s "builtin" namespace (which Python's name resolution rules treat specially, besides the "local" and "global" namespaces)
:* [[Scheme programming language|Scheme]]'s standard procedures, and [[Smalltalk]]'s base library  (which are responsible for implementing the majority of the control and organizational constructs that other languages consider "syntax", despite the fact that they hold no special syntactic status within their language definitions)
: (I think [[C programming language|C]] is actually an exception, by the way, in that the language ''isn't'' particularly tied to its standard library:  a lot of C's success in domains like embedded system programming is probably due to the fact that the standard library can be treated as an "optional extra", without impacting the language much.  Equally, at the other extreme, it's not uncommon for big applications to use runtime libraries like [[GLib]], [[Apache Portable Runtime|APR]], and [[Netscape Portable Runtime|NSPR]] as more capable "libc replacements".)
: --[[User:Piet Delport|Piet Delport]] 01:53, 6 June 2006 (UTC)

:Most language reference manuals describe a standard library. [[User:K.lee|k.lee]] 02:27, 6 June 2006 (UTC)

::It was an explicit design goal of the C language to '''not''' tie itself strongly to its standard library, and that perspective was strongly adopted by Stroustroup in his design of C++.  Before C, most langauges defined the IO facility as part of the core language.  Linux kernel hackers have a different view of their standard libary than application programmers.  Note that the C/C++ standards make heavy use of "as if" terminology.  In practice, aggressive compilers are free to do a lot at compile time to cheat in the separation of church from state, as long as they do it "as if" the separation were still in force.  Both C++ (in the template-metaprogramming idiom) and Perl grant incredible powers to the writers of libraries to reshape the language almost beyond recognition.  Template-metaprogramming libraries are compile-time artifacts.  Because the C language standard library always made liberal use of #define macros to speed execution, it also had/has strong elements of compile-time binding.  Coplien in his book (early C++ years) explains that a big part of what motivated AT&T to pursue software technologies such as C/C++ was the problem of upgrading a complex switch on the fly without ceasing continuous operation.  In that context, it's of the utmost concern what portions of your standard library are leaching into your compiled code base.  It's '''possible''' with C++ (but not much fun, I wouldn't think) to architect a system where you can incrementally relink new code on the fly.  Java has much of the same conceptual footing in that area, but I don't know whether anyone has pursued it's use that way in real life; probably Jini has that aspiration somewhere in its genes.  Likewise, the notion of the system "library" in a real-time OS such as QNX has a very different flavour to it; often the OS has far more invested in the library than the programming language itself.  [[User:MaxEnt|MaxEnt]] 00:09, 9 June 2006 (UTC)

== Definitions ==

I think we need to make clear that this section is intended to discuss ways of defining what a programming language ''is'', rather than ways to classify them.  [[User:Ideogram|Ideogram]] 23:38, 5 June 2006 (UTC)

: As one of the several authors of the current wording I'm not sure I follow the ''is''/''classify'' distinction.  [[User:Ideogram|Ideogram]] please go and read up on a few language definitions before jumping in here.  Also please go over the rather protracted discussions and edits that led to the current wording.   [[User:Derek farn|Derek farn]] 00:30, 6 June 2006 (UTC)

::Since the person responsible for the edits understood what I was talking about, I don't see the need to read up on anything for you.  [[User:Ideogram|Ideogram]] 01:54, 6 June 2006 (UTC)

: Good catch.  Feel free to move my contribution--indeed the whole section, to taxonomy.  OTOH, I'm a bit uncomfortable with the weaselish definitions of programming languages we have.  "A stylized communication technique"?  A bit too imprecise; sounds like someone was trying to avoid offending somebody.  No "universally agreed definition"?  Perhaps not, but there are several ''authoritative'' definitions given by guys like John Reynolds, Michael Scott, and numerous other researchers in the subject who know what they are talking about; FTMP these definitions intersect.  I'd crack open a few books (I'm don't have any handy at the present time) and lift a definition from one (or several) of these individuals.   Where they disagree, we can acknowledge competing viewpoints; but saying "nobody agrees" is a cop-out.  --[[User:EngineerScotty|EngineerScotty]] 23:48, 5 June 2006 (UTC)

:: There was no attempt to avoid offending anybody.  There is no universally agreed definition and there are plenty of ''authoritative'' definitions, most of which are reflected in the current wording.  Yes, we could pick the definition given by one individual (I happen to prefer the Turing machine one), but that does not reflect reality.  [[User:Derek farn|Derek farn]] 00:30, 6 June 2006 (UTC)

::I agree but it's a big can of worms.  If you are willing, I encourage you to lead the discussion (enough arrows in my back already :-).  [[User:Ideogram|Ideogram]] 23:52, 5 June 2006 (UTC)

:::It appears that quite a few researches in the subject agree with you.  I consulted numerous programming language texts; '''none''' of which bothers to define "programming language".  They all seem to take the [[Justice Potter]] approach--"I know what it is when I see it".  :)  One definition (not very authorative) that I did locate online, and wasn't obviously wrong, was on die.net:  

:A formal language in which computer programs are written <http://dict.die.net/programming%20language/>

Wiktionary:
:code of reserved words and symbols used in computer programs, which give instructions to the computer on how to accomplish certain computing tasks

Encarta: 
:special vocabulary for instructing computer: a unique vocabulary and set of rules for writing computer programs

Thoughts?
--[[User:EngineerScotty|EngineerScotty]] 16:49, 9 June 2006 (UTC)

::Being that this is Wikipedia, the one from Wiktionary (a sister porject) would probably be best. The page even links to this one on Wikipedia. The page is here: [[http://en.wiktionary.org/wiki/programming_language]]. [[User:Jaxad0127|Jaxad0127]] 16:55, 9 June 2006 (UTC)

::FOLDOC is usually a pretty reliable (and has been the starting point for several articles here on WP). Their definition is [http://foldoc.org/foldoc.cgi?programming+language here]. It begins:
:::''A formal language in which computer programs are written. The definition of a particular language consists of both syntax (how the various symbols of the language may be combined) and semantics (the meaning of the language constructs).''
::--[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 19:12, 9 June 2006 (UTC)

More quotes:

:A programming language is a language intended for the description of programs.  Often a program is expressed in a programming language so that it can be executed on a computer.  This is not the only use of programming languages, however.  They may also be used by people to describe programs to other people.  Indeed, since much of a programmer's time is spent reading programs, the understandability of a programming language to people is often more important than its understandability to computers.

:There are many languages that people use to control and interact with computers.  These can all be referred to as ''computer languages''.  Many of these languages are used for special purposes, for example, for reserving seats on airplanes, conducting transactions with a bank, or generating reports.  These special-purpose languages are not ''programming'' languages because they cannot be used for general programming.  We reserve the term ''programming language'' for a computer language that can be used, at least in principle, to express any computer program.  Thus, our final definition is:

:''A programming language is a language that is intended for the expression of computer programs and that is capable of expressing any computer program.''

:--Principles of Programming Languages, 2nd ed.

:'''What is a program?'''  At first glance, programs have two different sorts of manifestations.  On the one hand, they are documents of some kind that give a series of instructions to be executed by a computer.  But these passive documents can be turned into active physical processes:  when a program is executed, the instructions in the document are carried out.  The program text is passive, but the ''executing'' program is an event in real time.  Does "program" refer to the passive text, or the active event?  The answer is ''both'', because from our point of view in this book, ''a program is a machine''.  The program text represents the machine before it has been turned on.  The executing program represents the powered-up machine in active operation.  There is no fundamental distinction between the passive program text and the active executing program, just as there is none between a machine before and after it is turned on.

:So a program is a kind of machine, in particular a "software" machine.  There is nothing a program can do that a mechanical machine built out of gears and sprockets can't, but the software version can be built using a programming language on a computer terminal.

:'''What is a programming language?'''  It follows that a programming language is a ''construction kit for software machinery''.  The machines we build depend on the interplay betwen tools, materials and imagination.  Where software machinery is concernd, programming languages define the tools and materials.  Theoreticians note that all general-purpose programming languages are "Turing-equivalent."  Ultimately they can all compute the same set of functions, so none is more powerful in a mathematical sense than any other.  The analogous observation is that all hardware machines must obey the same physical laws.  No software machine can solve the halting problem (can compute a mathematically uncomputable function), and no hardware machine can violate the laws of thermodynamics.  

:--Programming Linguistics

[http://www.google.com/search?q=define%3Aprogramming+language&start=0&start=0&ie=utf-8&oe=utf-8&client=firefox-a&rls=org.mozilla:en-US:official google define:programming language]

== Looking for a home ==

Not sure where to put this (useful) text I removed; when I replaced the section on &quot;specification" (which includes both syntax and semantics, as well as lots of other stuff) with "semantics":

* a description of the language's syntax and semantics (e.g., [[C language]]).  The latter usually lists the results of performing an operation and restrictions on the kinds of operations that can be performed.
* a description of the behavior of a [[compiler|translator]] (e.g., [[C plus plus programming language|C++]]).  The syntax and semantics of the language have to be inferred from this description.
* a definition in terms of an [[executable]] specification (e.g., [[Prolog]]), often written in that language.

Perhaps "implementation" should be broken out as a separate section; as it's frequently useful to view programming languages as abstract machines apart from their actual realizations; formal specifications of programming language implementations probably goes there.  Plus, use of reference implementations as a means of specification has been ommitted.  --[[User:EngineerScotty|EngineerScotty]] 00:03, 6 June 2006 (UTC)

== semantics ==

I feel these entries might be too detailed and theoretical for the article.  In the textbook references I listed formal methods of specifying semantics are barely mentioned.  How often are they really used in industry?  I suppose I should read the specifications listed by k.lee above.  [[User:Ideogram|Ideogram]] 00:08, 6 June 2006 (UTC)

All right, I'll be honest, I don't understand formal semantics.  I've never had to learn them and I don't know how useful they are.  I'll leave arguing about this to others.

I think it's important to distinguish between the general definition of semantics and the computer science definition.  In a general sense, there are aspects of program semantics that are only understood by the programmer.  The computer science definition seems to be closer to "what can be captured in a formal description".  I think this difference accounts for my attempt to say that a formal semantics doesn't prevent bugs.  [[User:Ideogram|Ideogram]] 00:18, 6 June 2006 (UTC)

Semantic bugs are almost an edge case in actual programs.  The easiest way that I can come up with to describe them is bugs that no reasonable compiler/interpreter would reject, but which aren't really bugs in the logic of the program.  These are usually defined with respect to a specification.  A really simple example comes from scheme.  The scheme function EQ? determines whether two objects are the same at the level of addressing.  If FOO and BAR are both defined to be the same complicated thing, (say, the string "mumble"), but they neither one was defined in terms of the other, they are EQUAL? but not EQ?.  Because it's more expensive to store an address to a cell storing a small integer than it is to just hang onto the integer, most scheme implementations just store the integer itself, so if you use EQ? to test equality, you'll get what you want.  Nonetheless, in the official scheme specification, the result is indeterminate, so it's a semantic bug.  I hear there's something similar in C such that void main(void) is really allowed to do pretty much anything.  A more useful example:  imagine that you calculate some value n as a function of the inputs, and then run a loop as k goes from 0 to n.  If k is a small integer in a strongly-typed low-level language, and n is bigger than the maximum size for a small integer then you're going to run into problems.  This isn't something any compiler could signal an error on (not a syntactic error), but it's not really a sign that your algorithm is fundamentally messed up either (not a computational error).  It's a semantic bug.  [[User:Saccade|kraemer]] 03:44, 14 June 2006 (UTC)

== Move taxonomies ==

We should probably move the taxonomies section to a main article [[Programming language taxonomy]] or something. [[User:K.lee|k.lee]] 01:19, 6 June 2006 (UTC)

:Is there any reason to create a new article [[Programming language taxonomy]] when [[Categorical list of programming languages]] already exists? --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 01:47, 6 June 2006 (UTC)
::[[User:Allan McInnes|Allan McInnes]] I think this article is current under siege by a few people with a small amount of knowledge and an unwillingness to spend time reading up on this subject. [[User:Derek farn|Derek farn]] 02:05, 6 June 2006 (UTC)

:::Great, go start your own wiki.  [[User:Ideogram|Ideogram]] 02:11, 6 June 2006 (UTC)

::::How about we all try to [[WP:CIVIL|keep things civil]], and [[WP:NPA|avoid personal attacks]]? --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 02:25, 6 June 2006 (UTC)

:::::I would like to request that [[User: Derek farn]] try to avoid sarcasm in his edit summaries.  [[User:Ideogram|Ideogram]] 02:31, 6 June 2006 (UTC)

::The [[categorical list of programming languages]] is an alphabetized laundry list.  I was hoping that it would be possible to produce an article on programming language taxonomy that a human being could conceivably read.  It is clear that the categorical list will never become such an article.  [[User:K.lee|k.lee]] 02:39, 6 June 2006 (UTC)

:::There are at least two people working on that right now.  I think they would welcome your help.  [[User:Ideogram|Ideogram]] 02:46, 6 June 2006 (UTC)

::: I fully support the idea of making [[Programming language taxonomy]] its own article. I don't think [[Categorical list of programming languages]] is well suited to becoming an actual article, and its title isn't all that appropriate for such an article either. I've been working at transitioning the content in the categorical list into the category system (as well as cleaning up the list). Perhaps if we had a good taxonomy article and the list was redundant through the categories, we might be able to drop the categorical list eventually. &ndash; [[User:Zawersh|Zawersh]] 03:25, 6 June 2006 (UTC)

== Mediation Cabal Request ==

I have submitted this dispute to medcabal.  I suggest we all leave these pages alone until they get to us.  [[User:Ideogram|Ideogram]] 02:51, 6 June 2006 (UTC)

:Mediation Cabal request is [[Wikipedia:Mediation Cabal/Cases/2006-06-06 Programming language|here]], for anyone interested. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 02:56, 6 June 2006 (UTC)

:I think Derek Farn has indeed gone a bit overboard with reverts and snide edit comments... but I also know Ideogram is pretty new around here.  Cooling down and chilling out is always a good idea, but this disagreement is hardly a ripple in the general sea of disputation among WP editing. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 03:01, 6 June 2006 (UTC)

::LOL so the worst is yet to come ... [[User:Ideogram|Ideogram]] 03:03, 6 June 2006 (UTC)

:::Not necessarily on this article. But LotLE is right, there are plenty of ongoing disputes on WP. Take a look at the history and talk pages for [[Muhammad ibn Musa al-Khwarizmi]] sometime... --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 03:22, 6 June 2006 (UTC)

::::I prefer to stick to technical matters.  [[User:Ideogram|Ideogram]] 03:26, 6 June 2006 (UTC)

Medcabal has responded.  [[User:Ideogram|Ideogram]] 09:53, 8 June 2006 (UTC)

==Standard Library==
The advice to new wikipedians is be bold, and in this area I have actual expertise, so I was.

It was labelled as a stub that needed work, so I had a go. Assuming it to be outside the realm of prior recent edit wars. On looking at it in context it now has more words than it should, and so implies excessive importance relative to other ideas on the page. Perhaps they are needed, (the idea is inherently complex as it being part of a language is a bit fuzzy), perhaps all the words are not. Being my words I cant tell.
Feel free to 'fix' it, radically.
[[User:AccurateOne|AccurateOne]] 05:58, 6 June 2006 (UTC)
BTW the talk page is large, zen needs to fix it.

:I don't think standard libraries are suposed to provide platform specific implementation. Thats the job of the interpreter. Stdlibs contain commonly used objects, etc, so programers don't have to do them themselves. Ex: Java. [[User:Jaxad0127|Jaxad0127]] 06:07, 6 June 2006 (UTC)

:I was also bold and condensed it pretty strongly. Some of the stuff I cut out (such as some of the references to encapsulation) seems better suited to the [[standard library]] article. I also removed some of the stuff that either seemed technically inaccurate or too subjective (though I'm not certain that I fully avoided those traps myself!). If you think something I removed is vital for this article (as opposed to the standard library), feel free to re-introduce it. Hopefully I didn't over-condense. &ndash; [[User:Zawersh|Zawersh]] 06:44, 6 June 2006 (UTC)

:I thought I had responded here, but thanks you removed the right stuff. I have now removed the secstub tag as presumably it isnt now. [[User:AccurateOne|AccurateOne]] 08:07, 10 June 2006 (UTC)

== "Purpose" discussion ==

Derek farn, if you still want to discuss this, we can pick it up here.

The current "purpose" section covers these points:
*Programming languages facilitate communication
*Programming languages are different from natural languages
*Programming languages are executable
*Many languages are needed for different contexts
*Programming languages have become higher level

Which subtopics do not belong here?  [[User:Ideogram|Ideogram]] 09:55, 8 June 2006 (UTC)

: Whoops -- see comments above, please?  [[User:Saccade|kraemer]] 03:46, 14 June 2006 (UTC)

== design philosophy ==

It seems to me this subsection doesn't say anything, and should be either expanded or deleted.  [[User:Ideogram|Ideogram]] 11:11, 8 June 2006 (UTC)

== blorped about APL == 

I just blorped a response to the APL question above.  Yes, there are some typos I'm not going to fix.  Mutatis mutandi.  As I was grappling with how to best spin the significance of APL in its era, it finally occurred to me that a hugely overlooked perspective on the history of language design is the embedding forces imposed by a difficult work environment: paper cards, 100 baud teletypes, compilers trying to run in 64KB of memory, lack of lowercase letter forms, etc etc.  Languages are not designed solely for expressive power.  Much of the syntax of the C language was shaped by the requirement for a one-pass compilation process, and that influence remains with us everywhere.  The casualty in one-pass compilation frameworks is effective error reporting.  When you misspell a keyword in Google, it suggests alternate spellings.  Our compilers could easily do the same if the compilation model worked by downward refinement.  By now it is built into our genes that diagnosing a failed compile is a process akin to diagnosing a train derailment.  A human reader will can look at your code, without hardly any understanding of your problem domain and suggest "it looks like you forgot to declare the variable i as an integer".  Yet our compiler tradition is so rigidly front-to-back in their lexical analysis, they utterly lack the barest modicum of an overhead vantage point.  Maybe it had to be that way for deeper reasons.  In pactice, however, those decisions were originally reached to conserve scarce operational resources, and it now persists more by tradition than conscious design.  I was reading pages about the origins of human languages (anthro-linguistics) and in that world, certain formative forces are clearly declared: this language was written on wood with a horizontal grain, so no letter element is a horizontal groove (which might split the wood).  Cuniform letter forms are extremely different from ink and brush letter forms; parchment vs paper also had a strong influence.  Our punch cards, 110 baud teletypes, 1200 baud glass consoles, etc. have had no lessor influence on language design than stone tables or the ink absorption properties of dried goat hide.  If you are writing with a chisel, you soon invent APL.  [[User:MaxEnt|MaxEnt]]
{{talkarchive}}

== references ==

If we want this to be a Featured Article (and who doesn't?) we will need references, about one per section.  If you can please try to put references on new material, and look for references for the material that is already there.  [[User:Ideogram|Ideogram]] 05:28, 9 June 2006 (UTC)
* Agreed. FA articles require references. I have a programming language book from my class i just finihsed that I'll use to help contribute to this article in the future.--[[User:ZeWrestler|<span style="color:green">ZeWrestler</span>]]  [[user talk:ZeWrestler|<sup><span style="color:green">Talk</span></sup>]] 12:42, 9 June 2006 (UTC)

== deletion of definitions section ==

This will probably start a howl of protest, but I feel this is the weakest section of the article currently and want to start a discussion.

I have problems with all of the definitions mentioned in this section.

"The language's function" mentions computer programs, which requires readers to know what a computer program is, hardly likely if they don't know what a programming language is.

"The language's users and audience" although a programming language can be used to instruct machines, the reason they exist and we don't use hex or assembler is because they are primarily used for communication between people.

"The language's constructs" different languages have different constructs.  Declarative languages don't have control flow constructs.

"The language's expressive power" in my source quoted above there is a distinction between ''computer languages'' which are not Turing complete and ''programming languages'' which are.  This definition may not be universal, but it is verifiable and neatly avoids having to include the explanatory paragraph below.

Note that if you want to argue for multiple conflicting definitions in general and these definitions in particular I will ask you for verification.  [[User:Ideogram|Ideogram]] 11:44, 13 June 2006 (UTC)

Derek farn, you tell me to discuss the deletion on the talk page and then revert my changes while ignoring the fact that I have already started a discussion here.  I'm not going to start a pointless edit war, but I want the mediator to take note.  [[User:Ideogram|Ideogram]] 14:51, 13 June 2006 (UTC)

You also reverted my changes to the lead paragraph, which I supported with citations above.  [[User:Ideogram|Ideogram]] 14:54, 13 June 2006 (UTC)

: There are people + books that say programming languages must be Turing complete.  There are people + books that do not require programming languages to be Turing complete.  Everybody can find a citation to backup their POV.  The existing definition points out that there is no consensus and lists common definitions.  [[User:Derek farn|Derek farn]] 15:11, 13 June 2006 (UTC)

::If everybody can find a citation, please give us one, and one for each included definition.  I have provided a citation for mine.  [[User:Ideogram|Ideogram]] 15:19, 13 June 2006 (UTC)

:::I really wish we could somehow remove the "delete" key from Ideogram's keyboard.  Sorry, Ideogram, this was the same problem as over at functional programming.  It's just bad manners to delete whole sections without '''first''' discussing it.  I'm not necessarily all that partisan in support of the section, but I definitely cringe whenever I see multiple paragraphs deleted at once, and cringe again when I see that they are of at least clearly arguable relevance and quality.

:::I haven't really been all that fond of the presentation style in the "definitions" section, the bullets don't really seem to make up a list in a helpful sense.  But there are definitely good and relevant concepts in there.  Clarifying them is great.  Even restructuring a bit is great.  But broad deletion is a very anti-social approach. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 18:07, 13 June 2006 (UTC)

::::Okay, okay, I respect your input.  I will avoid broad deletion without  prior discussion in the future.  [[User:Ideogram|Ideogram]] 19:07, 13 June 2006 (UTC)

== history section ==

Any opinions on trimming the history section since there is now a separate article that duplicates it?  [[User:Ideogram|Ideogram]] 12:02, 13 June 2006 (UTC)

:I would agree with that idea.  The child/sibling article seems to cover all the details (but we should resolve the merge notice).  In my opinion, two or three narrative paragraphs without further subsections could give a broad sense of the history of programming languages, with the details fleshed out in the child article.  But as above, let's make sure there's consensus on this before chopping. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 18:11, 13 June 2006 (UTC)

== purpose edits ==

I'm not sure what you mean by "can be performed using an interface which uses only the variable inputs as free parameters"?  [[User:Ideogram|Ideogram]] 05:02, 14 June 2006 (UTC)

:Command line with inputs? [[User:Jaxad0127|Jaxad0127]] 06:13, 14 June 2006 (UTC)

:: More general than that -- when you write a program some things are going to always be the same, and some things are free parameters that you need to pass in.  For instance if you're writing an email using some (non-command-line) program, the recipeient, the text, etc. are free parameters, but how to talk to the IMAP server, or the cute little annoying graphics and sounds are fixed -- you don't need to respecify them.  [[User:Saccade|kraemer]] 10:35, 14 June 2006 (UTC)

:::This phrase is hard to understand.  You need to word it so that someone who doesn't know what a programming language is can understand it.  [[User:Ideogram|Ideogram]] 09:06, 15 June 2006 (UTC)

== definitions section discussion ==

Again, I do feel this section is weak and want to discuss it.  My problems with it are noted above.  Certainly I prefer that the definitions listed be sourced, we will never achieve featured article status if they aren't.  LotLE, you say there are "good and relevant concepts in there" can you list what you think should be kept and what can be cut?  How do you think my concerns above should be addressed?  Everyone else please comment as well.  [[User:Ideogram|Ideogram]] 08:21, 15 June 2006 (UTC)

== Turing-complete POV ==

In his revert Derek farn comments that requiring a programming language to be Turing complete is a POV.  Of course the opposing position is also a POV; my POV has a citation and his does not.

Nevertheless I do expect he will eventually produce a citation, so on that assumption the next question is how to write the lead paragraph with a NPOV accommodating the two positions.  Any thoughts?  [[User:Ideogram|Ideogram]] 08:24, 15 June 2006 (UTC)

I would definitely agree that we should not state Turing completeness as a ''requirement'' for programming languages.  Most (sort of) are, but if some language technically only modelled a push-down automoton, how many programmers would ''really'' know the difference?  Moreover, some things, like the C++ pre-processor or XSLT turn out to be Turing complete via some obscure hackery, but the point is non-obvious.

But thinking about it some more, I thought about the hyper-pedantic point that, e.g. C '''is not''' Turing complete as a language.  If you want to be really technical, C only gets you a simple state machine.  That is, pointers in C are of some finite size, say 32-bit.  After that, addresses have no way of being named.  But 32-bit pointers to 8-bit bytes only gets you 2^40 states.  A machine with a trillion states is a pretty complex one, but it's ''not'' a Turing machine.  Notice that file-system access ''is not'' part of C proper.  However, even if you include STDIO here, common filesystems are themselves ''finite''.  So if a given filesystem can access, say 2^64 addresses, that still allows only a finite number of states of the filesystem.  Now this might give you a state machine with, e.g. 2^(2^64) states in it... which is reasonable to call "a hell of a lot".  But it's still '''finite''', e.g. not Turing complete. 

Some other languages actually ''are'' Turing complete ''qua'' languages.  But as run on actual machines, they are as finite as the machines.  So, for example, the ''specification'' of Python makes long integers unbounded.  But on a given machine, there is still a largest long that can concretely be stored (a ''very large'' such number, but not infinite).  Well, as a purely language question, unbounded integers gets you Turing complete (or you could use the fact the length of strings is formally unbounded, etc).  Now certainly that doesn't mean in any practical sense that Python is "more powerful" than C; but in computational theory, it actually ''is'' (which is of no real-world interest at all). <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 08:34, 15 June 2006 (UTC)

:Does C's STDIO require a 64-bit filesystem?  If it doesn't, you can expand the filesystem as much as you want and C is as Turing complete as Python is.

::Doesn't really matter since STDIO is part of the standard library, not part of the language spec itself.  C is often used on platforms with no filesystem at all, which is generally the reason for the distinction.  But the filesystem is external to STDIO, even at the library level: A C call doesn't "know" whether it's reading from a file on HFS+, NTFS, RFS, FAT12, etc.  In contrast, Python as a language spec includes unbounded types rather than only finite-sized pointers. You could certainly create a language called "Just-slightly-more-than-C" that was also theoretically Turing complete (it might even by syntactically equivalent). <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 16:57, 15 June 2006 (UTC)

:I think that when Turing-complete is applied to languages it is generally understood that the finite memory size of actual computers is not considered a limitation.  C certainly is used on 64-bit machines and probably will be used on 128-bit machines.  The fact that all real machines are finite is really a hyper-pedantic point.

::It's also used on 8-bit machines where the actual limits "matter" in some sense.  The distinction between a computation you can't perform because a machine isn't technically Turing complete, and one you can't peform because the universe will experience heat death before it is done, is not of any practical importance.  But mathematically they are different.

::But likewise, this is the reason we should definitely '''not''' have a sentence like "All programming languages are Turing complete", which I believe you advocated, Ideogram.  A programming language that implements a push-down automata at a ''theoretical'' level is strictly less powerful as a language definition (even if you could have infinite hardware to run it on), but it could just as well "feel like" a programming language to 99% of users.  Or probably even one that implemented only a finite state machine, if you could allocate a reasonably large number of states (not heat-death-of-the-universe orders like a mention, but just say hundreds). <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 16:57, 15 June 2006 (UTC) 

:::Verifiability, not truth.  All your reasoning is not as important as a citation, which I have.  [[User:Ideogram|Ideogram]] 17:12, 15 June 2006 (UTC)

::::I haven't the foggiest idea what point you hope to make with the sentence "verifiability not truth".  Obviously that's one of the WP policies, but I can't really ferret out any connection to this discussion thread. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 17:23, 15 June 2006 (UTC)

:::::We're not here to determine the facts by reasoning amongst ourselves.  We're here to report on what the literature says.  Do you remember my argument about the flat-earth theory on [[functional programming]]?  Even if you are correct, it doesn't matter as much as what the published literature says.  [[User:Ideogram|Ideogram]] 17:27, 15 June 2006 (UTC)

::::::I still can't figure out what point you're trying to make.  I'm not suggesting adding the sentence "C isn't Turing complete" to the article; did you think I suggested that?! If I wanted to, for some strange reason, obviously I'd give a citation (which would be easy enough for the commonplace fact).  Talk pages, of course, precisely ''are'' about "reasoning among ourselves".... that's what the entirety of all the discussion threads are. 

::::::The mantra about "verifiable not true" isn't to be taken with absurd literalness.  If some reliable source makes a claim that can be shown to be self-evidently wrong when taken literally, we grant a certain spirit of generosity to the source.  Perhaps they were writing more informally, or making a point in some specific context by allowing temporary imprecision.  So if some reputable text book write "All programming languages are Turing complete", we allow for the fact that they are writing for a certain introductory audience, and being deliberately fuzzy as a first-approximation of the truth.  We don't do original research in articles, but we also don't entirely throw common sense out the window. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 17:42, 15 June 2006 (UTC)

(outdenting) I have two citations, quoted in full, at [[Talk:Programming language/Archive 2#Definitions]] which define programming languages to be Turing-complete.  They were quickly archived which is why you probably missed them.  ''Common sense'' tells me that the very intelligent authors of those definitions are not here to defend their positions against your very clever reasoning, and I'm not going to try to do it for them.  [[User:Ideogram|Ideogram]] 17:51, 15 June 2006 (UTC)

:Anyway we are not debating ''truth'' here, we are debating ''verifiability''.  [[User:Ideogram|Ideogram]] 08:43, 15 June 2006 (UTC)

:: The idea of Wikipedia is that although it may take an expert to find a citation from a reliable source, anyone can check it. It's a bit like RSA - it takes exponential time to factorise a number, but polynomial time to check it. Of course, you won't find a cite for this because no one can prove it, but this is the talk page, so different rules apply. Anyway, here's [[WP:V]], [[WP:CITE]], [[WP:RS]] and [[WP:NOT]] which you can check very easily. [[User:Stephen B Streater|Stephen B Streater]] 17:39, 15 June 2006 (UTC)

You might all consider the [[BlooP programming language]], a slightly-less-than-Turing complete language designed by [[Douglas Hofstadter]].  While not a practical language (it was devised for pedagogical purposes), it is a language capable of computing [[primitive recursive]] functions, but not all recursive functions.  (In other words, it cannot compute [[Ackermann's function]]).  Despite not being Turing-complete, it '''can''' solve most mathematical problems of interest.  --[[User:EngineerScotty|EngineerScotty]] 17:49, 15 June 2006 (UTC)

:Hmm am I the only one pushing the Turing-complete definition?  If all of you really disagree with me even after reading the quoted citations, I will yield.  [[User:Ideogram|Ideogram]] 17:55, 15 June 2006 (UTC)

::Yep, you're the only one pushing it.

:::Let's hear from Stephen B Streater and Allan McInnes before you jump to that conclusion.  [[User:Ideogram|Ideogram]] 18:36, 15 June 2006 (UTC)

::I'm not sure which author in the archived thead you were trying to refer to,

:::The authors I'm referring to are the authors of Principles of Programming Languages, Bruce J. MacLennan (used at Stanford) and Programming Linguistics, David Gelernter (surely you've heard of him) and Suresh Jagannathan.  [[User:Ideogram|Ideogram]] 18:36, 15 June 2006 (UTC)

::::Of those, only the latter mentions the Turing-equivalence, at least as quoted in the archive. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 19:12, 15 June 2006 (UTC)

:::::I left off a footnote.  The sentence "We reserve the term ''programming language'' for a computer language that can be used, at least in principle, to express any computer program." has the footnote "This is not a vague notion.  There is a precise theoretical way of determining whether a computer language can be used to express any program, namely, by showing that it is equivalent to a universal Turing machine.  This topic is beyond the scope of this book."

::but I'm certain all such very-smart authors present those types of blurbs in the spirit of "first approximation of the truth".  Certainly at a "first approximation", C is a very Turing-style language (though the cleverness of my reasoning that it's otherwise is very minimal).

:::Note that we are supposed to be writing for a general audience here, that is even ''less'' interested in hair-splitting correctness than the readers of the textbooks I cited.  [[User:Ideogram|Ideogram]] 18:36, 15 June 2006 (UTC)

::::Right, which exactly why the Turing-complete thing is even less relevant to include.  A lot of readers have no idea what computation complexity is at all, so trying to make a pedantic point that goes over there head is of no help (especially when it's actually false, if you are still more pedantic than that).  Gelernter is writing more for an audience of CS students who have either already heard of Turing machines, or will before the semester's over.  As a first approximation, it's worth telling those CS students that "all general-purpose programming languages are Turing-equivalent" so they don't go off into an unneeded digression of wondering which languages are more powerful (e.g. ordinary ones like C vs. Python vs. Lisp).  But someone like Glernter (no, I don't know him, but I assume he's a CS guy from your tone) is crossing his fingers or adds a little tiny implicit footnote... obviously he ''knows'' that fixed pointer sizes theoretically limit the state space (to something very large). <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 19:12, 15 June 2006 (UTC)

:::::I am not by any means suggesting we include the term "Turing-complete".  Instead it is possible to assert that "all general purpose programming languages are equally powerful in a mathematical sense".  This is the wording that Derek farn reverted [http://en.wikipedia.org/w/index.php?title=Programming_language&diff=58398922&oldid=58398250 here]; it was '''he''' who used the term Turing-complete in his edit summary.  [[User:Ideogram|Ideogram]] 19:34, 15 June 2006 (UTC)

=== Other models of computation ===
The problem is that the assertion that "all general purpose programming languages are equally powerful in a mathematical sense" is either meaningless (equally powerful in ''what'' mathematical sense?) or flat out misleading (if by "mathematical sense" you implicitly mean Turing-equivalent - see for example [http://www.cs.brown.edu/people/pw/papers/bcj1.pdf Peter Wegner's work] on equivalence models for interactive programs). --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 23:49, 15 June 2006 (UTC)

:Some notes on this paper:
:* It is highly theoretical and hard for me to understand.
:* Although it claims there are more powerful models of computation than Turing Machines and that object oriented languages implement these models of computation, nowhere is there an explicit definition of programming language that could be cited for our purposes.
:* It is work in progress, not a published peer-reviewed paper and therefore OR.
:::This narrow point is definitely wrong.  There's nothing wrong with citing a generally circulated draft of a scientific paper.  None of the textbooks mentioned are peer-reviewed either, nor are 99% of all the sources used on WP. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 17:31, 17 June 2006 (UTC)
::::This was the precise argument used to reject most of Carl Hewitt's edits.  Back me up here please, Allan.  [[User:Ideogram|Ideogram]] 18:05, 17 June 2006 (UTC)
:* I personally have problems with claims like object oriented programming makes structured procedural programming obsolete.  [[User:Ideogram|Ideogram]] 08:45, 17 June 2006 (UTC)

::Some responses:
::* I agree that it gets a bit dense in places. My apologies for that. But I think that the basic message (Turing machines do not model interactive or concurrent computation, other mathematical models are necessary) is fairly clear. Nor is it original with Wegner. It's the same thing that drove people like [[Carl Hewitt]], [[Robin Milner]], and [[C.A.R. Hoare|Tony Hoare]] to develop things like the [[Actor model]], the [[pi-calculus]], and [[Communicating sequential processes|CSP]]. Wegner just happens to provide (IMHO) a good summary of the issues.
::* The reason I pointed to that paper was ''not'' because it contained a definition of "programming language", but because the paper refutes the notion that "all general purpose programming languages are equally powerful in a mathematical sense", since there are several different "mathematical senses" that we might consider and not all languages are "equally powerful" in these different "mathematical senses".
::* You are correct that the paper I linked to is labelled a "work in progress". It also dates from 1999. [http://www.cs.brown.edu/people/pw/ Wegner's website] contains more recent work, some of which has been published in places like CACM and LNCS. And as I pointed out above, these ideas are not original to Wegner. The paper I linked to just happens to be (I think) a pretty good summary. I'd be happy to dig up other cites if you want them.
::* I personally don't like such statements either. I happen to believe in selecting the appropriate computational model for the problem at hand. But neither my feelings nor yours on Wegner's ''opinions'' detract from the basic point of the paper, which is that Turing machines are a limited computational model and Turing equivalence is not the only possibly equivalence between general purpose programming languages &mdash; so claiming that all languages are "equally powerful" is misleading since it the truth of the assertion depends on the way you determine "equal".
::--[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 14:59, 17 June 2006 (UTC)

:::Thank you Allan for having by far the most patience with me of anyone in the debate.  Please see the section "Lead paragraph trying again" below for a summary of my position.  [[User:Ideogram|Ideogram]] 16:12, 17 June 2006 (UTC)

:::Moreoever, there are many other possible meanings to a claim like "All PLs are equally powerful in a mathematical sense".  While I definitely feel strongly we shouldn't introduce the false precisision of claiming "All PLs are Turing-equiv" (if only because that's gobblety-goop to many readers), trying to find a statement that's more friendly to the common vernacular introduces other points of failure.  For example, if langauge A could do a certain type of operation in O(N), while language B took O(2^N) to complete the same type of operation (stipulating that this is a fact of the language definition level, not just of implementations), it would be quite accurate to say that "A is more powerful than B, in a well-defined mathematical sense".  Of course A and B could still both be Turing-complete, but that's not the only concept within mathematics (complexity theory is another such area well within the PL lingo). <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 17:41, 17 June 2006 (UTC)

::::We can do exactly as my cited sources did, and add a footnote.  We have to add an in-line citation anyway to reference where I got the definition from.

::::Now this page is getting kind of long.  Can we move discussion to the bottom and archive the rest?  [[User:Ideogram|Ideogram]] 18:05, 17 June 2006 (UTC)

=== Ramblings on languages and their formal power ===
Actually, this thread also got me thinking about Postscript.  It's sort of a mantra to point out that Postscript is Turing-complete (since many people think of it as "just a page-layout description").  I don't know PS well, but thinking on it slightly more, I realize that it's "stack based"... which would ''seem'' to make it formally a push-down automaton not a Turing-machine.  I can't find anything in the [[Postscript]] article; can anyone tell me in 20 words how PS achieves random-access rather than a strict FILO stack only?

:I'm pretty damn sure Postscript is Turing-complete.  I've never programmed it and I have no citations, but I'd advise you not to waste your time on that score.  [[User:Ideogram|Ideogram]] 18:36, 15 June 2006 (UTC)

::Oh, I'm pretty sure it is too since I've heard it so often.  I'm just wondering "how".  I'm pretty sure whatever then answer is, it's something pretty simple: like "The so-and-so command accesses a data structure in a random rather than stack way" (or along those lines).  I don't want this digression in this article, it's just for my edification. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 19:12, 15 June 2006 (UTC)

:But along those lines, I'm pretty sure those programmable calculators with a stack-based syntax are also limited to push-down computation abilities, but I think it reasonable to call the languages used on programmable calculators "programming languages". <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 18:17, 15 June 2006 (UTC)

::Reverse Polish Lisp as used in HP calculators is Turing-complete, modulo memory size.  [[User:Ideogram|Ideogram]] 18:36, 15 June 2006 (UTC)

:::Is it? I never had one of those calculators, nor looked closely at the language they use.  But are you sure of that? Can you do generalized recursion on them? (modulo memory size) <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 19:12, 15 June 2006 (UTC)

::::Again, I haven't programmed them, and have no citations, but I have friends who were into it, and it is called Reverse Polish ''Lisp'' after all.  [[User:Ideogram|Ideogram]] 19:34, 15 June 2006 (UTC)

=== Back to what phrase to use as definition ===
:I'd yield.  While all practical general-purpose languages are Turing-complete; there are several pedagogical languages which aren't.  In addition, there are quite a few domain-specific languages which aren't Turing complete, either. --[[User:EngineerScotty|EngineerScotty]] 18:18, 15 June 2006 (UTC)

::Well that's the issue, are pedagogical and domain-specific languages general-purpose programming languages?  My sources say no.  [[User:Ideogram|Ideogram]] 18:36, 15 June 2006 (UTC)

:::The question isn't really if they are "general-purpose programming languages" but if they are "programming languages".  The latter is the topic of '''this''' article. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 19:12, 15 June 2006 (UTC)

::::My sources ''define'' programming languages as general-purpose programming languages.  This is just a choice of definitions, you aren't going to prove anything by reasoning from first principles.  [[User:Ideogram|Ideogram]] 19:34, 15 June 2006 (UTC)

This argument's gone on too long.  Nobody denies that FORTRAN is a programming language, but old-style FORTRAN had neither a stack nor a heap, and was therefore not Turing-complete.  Nobody denies that the simply-typed lambda calculus is a programming language, but STLC is strongly normalizing, i.e. all programs terminate and STLC is therefore not Turing-complete.  Non-Turing-complete programming languages are proposed at top PL research conferences all the time, for reasons that any PL researcher can explain at length --- take, for example, the stackless, heapless language [http://doi.acm.org/10.1145/378795.378862 ESP].  Turing-completeness is a theoretical property that has almost no relevance to whether any language should be considered a "programming language" or not. [[User:K.lee|k.lee]] 18:41, 15 June 2006 (UTC)

: I think the article ought to note that ''practical'' general-purpose languages, modern ones especially, are all Turing Complete.  However, Turing-completeness isn't, and shouldn't be claimed to be in the article, a ''prerequisite'' for a programming language. --[[User:EngineerScotty|EngineerScotty]] 18:58, 15 June 2006 (UTC)

I don't understand why everyone here thinks they are smarter than three full professors with published textbooks.  [[User:Ideogram|Ideogram]] 19:08, 15 June 2006 (UTC)

:Actually, I ''am'' smarter than ''most'' full professors with published textbooks :-) (I'm not a professor, but I am a Ph.D. and have written a CS textbook; still, there are lots of folks a lot smarter than me).  But that's not at all the point.  We're trying to write an encyclopedia for a certain readership; not everything any smart person wrote in any context is necessarily equally germane in the different context we're writing for.  A textbook is a different format than an encyclopedia, and follows somewhat different stylistic goals.

:The particular statement you like—let's abstract it as "All general-purpose programming languages are Turing-complete"—has a somewhat different "truth status" at different readership levels:
:# To a "general readership" the statement is gibberish since it uses terms they have no sense of.
:# To a CS 101 student the statement is "true (enough)", and makes a good point about what is and isn't relevant to contrast among familiar programming languages.
:# To a CS graduate student or professor (or even more-so, to a mathematician) the statement is ''false'', since it confuses a "very large" state space with an infinite one.
:# To a programming language expert the statement is false not just in the mathematical sense, but because there are many "edge case" languages (old FORTRANs, special domain languages, research languages, etc).
:Statements come in more shades than just "true" and "false", and good writers (like those textbook authors you cite) know that. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 19:27, 15 June 2006 (UTC)

::See my note above about not using the term "Turing-complete".  A large portion of this debate could have been avoided if you had just seen my edit before Derek farn reverted it.  [[User:Ideogram|Ideogram]] 19:38, 15 June 2006 (UTC)

My 2c: I don't think "Turing completeness" should be used to ''define'' "programming languages". As others have pointed out, there are some things that are generally considered programming languages that are ''not'' Turing complete (e.g. [[Charity programming language|Charity]]). Conversely, even languages like [http://www.muppetlabs.com/~breadbox/bf/ Brainf**k] are technically Turing complete, but are not all that useful for any practical purpose. I think it's probably worth ''mentioning'' Turing completeness somewhere within the article. But not as a defining characteristic. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 20:00, 15 June 2006 (UTC)
* Of course, as an aside, it's probably worth mentioning that [[Brainfuck]] has an article here on Wikipedia.  :) --[[User:EngineerScotty|EngineerScotty]] 20:02, 15 June 2006 (UTC)

:But Allan, don't you see my point about verifiability, not truth?  [[User:Ideogram|Ideogram]] 20:08, 15 June 2006 (UTC)

::I do. I even agree with it. My point is that while it's certainly valid and verifiable to say that "Authors X, Y, and Z define programming languages as Turing complete languages", that is not the same as directly asserting that "all programming languages are Turing complete" since (a) the verifiable fact is that certain authors have made a definition, not that a particular definition is in some sense "true", and (b) it is a verifiable fact that some people define certain non-Turing complete languages (such as [[Charity programming language|Charity]]) as programming languages. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 23:42, 15 June 2006 (UTC)

:::I'm treading on thin ice here since I don't want to piss off LotLE, but let me just note that I had all this in mind when I made my comments in the section above, "Turing-complete POV" which no one seems to have noticed.

:::Now, I really don't think I should post on this subject anymore, as we all need a chance to cool down.  [[User:Ideogram|Ideogram]] 23:58, 15 June 2006 (UTC)

I've got to sort out may baby RSN, so I've just skimmed the hundreds of closely argued technical points, but here is my view pending a thorough analysis:
* A language like C has a fixed pointer size (as mentioned above). The size is not defined by the language, but sizeof(ptr) is defined to be fixed once the program starts. This means that, technically, you cannot implement a Turing machine in C, as a Turing machine has an infinite number of possible states.
* The meaning of ''Turing machine'' is vague in popular speech, and includes a normal general purpose computer.
* A programming language is a language you can write programs in.
* Cites are important, but cites for contradictory things will be easy to find when the concept is used widely by non-technical people.
* Who is this article aimed at?
* Baby has woken up now! [[User:Stephen B Streater|Stephen B Streater]] 21:13, 15 June 2006 (UTC)

:Thank you for your time Stephen, I hope we're not wasting it.  As I noted above, I am not proposing using the term "Turing-complete", rather I want a phrase something like "all general purpose programming languages are equally powerful in a mathematical sense".

:I feel this article should be aimed at a general reader who doesn't even know what a programming language is.  [[User:Ideogram|Ideogram]] 21:26, 15 June 2006 (UTC)

:: Thank for your thoughtfulness. I like the idea that all programming languages are basically equivalent. I'll have to look into markup languages and other restrictive languages to see whether they count as programming languages. What about a calculator with a 36 instruction memory? Or 1 instruction? Clearly, in practice, for two implementations, it is likely that only one can emulate the other as one will run out of memory first. But does this matter ''in practice'', which is what computing is about. After all, a faster computer is only one upgrade away. [[User:Stephen B Streater|Stephen B Streater]] 21:41, 15 June 2006 (UTC)

=== Many sources ===
I feel that we should be reporting definitions as used in the literature rather than trying to figure it out for ourselves, thus my constant repetition of "verifiability, not truth".  [[User:Ideogram|Ideogram]] 21:51, 15 June 2006 (UTC)

:But what do we report? I'm assuming a 5k word article doesn't have enough room in it to blindly copy every word in each of several 300k word books.  Actually, probably hundreds of 300k word books.  Heck, even if we could blindly copy, that would by copyvio.  So in fact, what we do isn't very much at all like what you are claiming here.

:What we actually do is make lots of judgements about relevance, organization, selection, balance, reliability, etc.  As well we need to make judgements about mellifluousness and other stylistic qualities.  All of that requires using our own judgement and intelligence, and knowledge, as editors, not act as photocopiers or card catalogs.  Wikipedia's not Google either.  Or in other words, editors need to do a whole lot of thinking, and very little reporting.

:The familiar mantra about "verifiability not truth" has a certain purpose, but it is very much an '''edge case'''.  It's basically there to curtail arguments of stunning new conclusions by editors.  We don't want original research, but that doesn't mean editors are brain dead.  It means... well, that editors don't do research in the sense of primary scientific results.  And also that the argument that some esoteric minority idea doesn't "need to be presented because it's true" (even though the conspiracy of majority opinion persecutes the poor suffering truth).  Essentially the "verifiability not truth" mantra is a shortcut around paranoid delusions, not a demand to throw out common sense and background expertise.  

:And in this case at hand, none of the stuff about languages that are and are not Turing-equivalent (with or without mentioning Turing's name) is any sort of novel new result.  It's CS 301 or something, and the basic stuff of hundreds of textbooks.  But there's no one sentence in those hundreds of textbooks (such as the one or two you've suggested) that leaps out of its own volition as more important or more verifiable than the rest of the academic field.  Yeah, a couple smart people have no doubt decided that it was a reasonable pedagogical shortcut to tell students that "All programming langauges are Turing-complete"; and dozens or hundreds of other smart people have decided on slightly different pedagogical organizations (for example, the few dozen definitions we've seen that don't use this formulation).  

:Stephen B Streater gets this point exactly right above: the terms involved are used by many different people—both experts and non-experts—in slightly different ways.  I don't think it matters whether we use the phrase "Turing-complete" (or "Turing-equivalent") or just "equally powerful mathematically".  In either case, we are pretending to have a greater precision and exactness than actually exists in the use of "programming language" as a term.  I'm quite happy (as we have now) to put in something along the lines of "Most widely-used general-purpose programming languages are equally powerful in a mathematical sense".  Clearly, to a very rought first-order approximation, that's right.

:I do find the mechanistic repetition of a not-particularly-relevant WP policy as if it "proves" you're right on some stylistic discussion a bit dissimulative, and annoying.  I'm still trying to figure out if somehow in your own head [[WP:V]] seems to mean something different than anything I've been able to decipher.  It sure doesn't mean that we must quote Smith rather than Jones, as you seem to reduce it to. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 21:55, 15 June 2006 (UTC)

::I suggest we take a break from discussion.  You are getting cranky.  I hope you realize this does not diminish my respect for you in any way.  [[User:Ideogram|Ideogram]] 22:31, 15 June 2006 (UTC)

:::Nah... I started out cranky :-).  Or maybe crankish? Don't take my crotchety nature too seriously, if you can avoid it.  I do endorse the points I'm trying to make, of course, but I should really learn to be a little more happy-joy-joy in my manner of expressing them.  <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 01:19, 16 June 2006 (UTC)

::::Thank you for a much needed laugh.  Unfortunately now I'm the one feeling cranky.  I'm taking a break from this page for a while.  [[User:Ideogram|Ideogram]] 01:26, 16 June 2006 (UTC)

----
(following in response to Ideogram)
*The author list for ESP paper (cited above) includes a full professor at Princeton (Kai Li).  The [http://www.acm.org/sigs/sigplan/pldi/pldi2001/cfp.htm program committee] that accepted it to the ''ACM Conference on '''Programming Language''' Design and Implementation'' in 2001 had about a dozen former or current professors, as well as the vice-chair of ACM SIGPLAN.
*The simply-typed lambda calculus is described in the textbook ''Types and '''Programming Languages''' '' by U. Penn. prof. Benjamin Pierce.
*Even one of the textbooks you cite (''Programming Linguistics'') counts FORTRAN as a programming language, even though FORTRAN-77 clearly is not Turing-complete.
Furthermore, I am not certain that your citations would be dispositive even if they weren't contradicted by clear practice in the literature.  Sometimes textbook authors will define a term in a particular way for convenience within the lexical scope of the textbook, even though in practice that term is used in a different sense in the broader discipline.  [[User:K.lee|k.lee]] 22:25, 15 June 2006 (UTC)

Here are some ideas this morning:
* Citing sources is definitely good.
* To me, ''programming language'' is an English term usually defined by giving examples so there may be no consistent definition which everyone who uses the term agrees with.
* A definition which includes a range of alternatives (all cited if possible) would be better than a narrow definition. Alternatively "PL can be defined as ...". This will avoid alienating people with their own pet version.
* On [[Mathematics]] we spent a lot of effort coming up with a consensus definition (uncited but there's an extensive discussion on derivation). At least programming languages are relatively recent.
* A glance at [[Language]] and [[Formal language]] and [[Computer language]] may be instructive.
* Although many programming languages have finite memory, a cited definition along Turing lines with a caveat is one solution.
[[User:Stephen B Streater|Stephen B Streater]] 06:36, 16 June 2006 (UTC)

:This all sounds pretty good to me.  Sorry I can't be more specific but I'm kind of burned out on the topic.  [[User:Ideogram|Ideogram]] 06:56, 16 June 2006 (UTC)

== fully specified behavior ==

"The combination of the language definition, the program, and the program's inputs fully specify the external behavior that occurs when the program is 'executed'."

Correct me if I'm wrong, but don't all language definitions have sections where they say "if you do this the resulting behavior is unspecified"?  Should we mention this?  [[User:Ideogram|Ideogram]] 09:13, 15 June 2006 (UTC)

We could change this to:

"The combination of the language implementation, the program, and the program's inputs fully specify the external behavior that occurs when the program is 'executed'."  [[User:Ideogram|Ideogram]] 09:24, 15 June 2006 (UTC)

: While your statement is true this is an article about programming languages, so they ought to get a mention.  In fact your sentence really belong in the article on programs.  There is quite a bit of the Purpose section that would probably go better in the Program article.  [[User:Derek farn|Derek farn]] 10:14, 15 June 2006 (UTC)

::Please elaborate.  [[User:Ideogram|Ideogram]] 10:20, 15 June 2006 (UTC)

:: Which bit requires eloboration?   The Purpose section could read "The purpose of programming languages is to enable [[program]]s to be written."  A rather pointless statement, but then (as you know) I have never been a fan of this subsection  [[User:Derek farn|Derek farn]] 16:20, 15 June 2006 (UTC)

:::If you wish we can go back to the list of topics covered that I provided earlier and go over them one by one.  We can also consider alternative titles for the subsection.  [[User:Ideogram|Ideogram]] 16:27, 15 June 2006 (UTC)

== untyped and typed ==

I'm not sure about the phrase "semantically meaningless".  I don't understand what it means in formal semantics, since I don't understand formal semantics, but if you are using the term "semantically" in a general sense then the programmer certainly has a meaning in mind (assuming it is not an error).

In assembly language the results are usually not unspecified since it has no types and everything is just bits.  The results depend on the representation used by the assembly language which is certainly visible to the assembly language programmer.

Forth is an untyped language; Forth programmers wouldn't consider such operations "meaningless" with "unspecified results".  [[User:Ideogram|Ideogram]] 09:22, 15 June 2006 (UTC)

== unicode ==

That's a very good point, anonymous editor at 213.41.137.29.  You should create an account and join us.  [[User:Ideogram|Ideogram]] 17:15, 15 June 2006 (UTC)

== verifiability, not truth ==

There's some discussion of this issue at [[User talk:Lulu of the Lotus-Eaters#verifiability, not truth]] that you might want to read.  If we want to discuss this issue in earnest we should probably take it to the Village Pump.  [[User:Ideogram|Ideogram]] 20:59, 15 June 2006 (UTC)
:I'm not sure the meta-debate is necessary.  It is [[WP:V|verifiable]] that there exist non-Turing complete languages in the literature (some with implementations); it is also veriable that there is a noted absence of modern production general-purpose languages which aren't Turing-complete.  The latter point is hard to verify, as "proving" it would require an enumeration of all such languages (whereas a single example suffices in the former case).  At any rate, I think we're presently debating minutaie, when there are much bigger fish to fry in this article.  --[[User:EngineerScotty|EngineerScotty]] 21:10, 15 June 2006 (UTC)
::No no you're missing my point.  The '''definition''' I'm pushing is verifiable, so far all of this debate has missed that point.  The actual facts as to which languages are Turing-complete or not is completely irrelevant.  None of you pushing the other definition have ''verified the definition''.  It has nothing to do with the facts you are asserting.  [[User:Ideogram|Ideogram]] 21:22, 15 June 2006 (UTC)

::As for the bigger fish to fry, I have the last post on just about all of them, but it's ''this'' one that everyone responded to.  [[User:Ideogram|Ideogram]] 21:28, 15 June 2006 (UTC)

== reverting without discussion ==

I have had it beaten into my head not to make controversial changes without discussing them first.  Derek farn seems to feel this rule does not apply to him and feels free to revert anything he likes without discussion.  From previous comments it is clear that Derek farn holds me in utter contempt.  I earnestly request the mediator to step in.  [[User:Ideogram|Ideogram]] 23:22, 15 June 2006 (UTC)

: [[User:Ideogram|Ideogram]] Please read the links referred to by material.  This will enable you understand why the material makes sense.  Also I notice that you rarely add links in your own material.  Please do so as this enables people to follow up on what you have written.   [[User:Derek farn|Derek farn]] 23:38, 15 June 2006 (UTC)

* Without commenting on the personalities involved in this debate; Derek's edit appears to be the more correct one.  Many languages not supporting Unicode will happily accept the full Latin-1 character set, allowing most European languages to be encoded.  Unicode also extends beyond non-English alphabets, allowing other cool symbols like &le; or &larr; to easily be encoded, rather than having to use approximations such as <= or <-.  (I don't know of any language off the top of my head which allows such Unicode operators, and most keyboards don't have keys for such things, but the HTML-4 escape sequences like <tt>&lt;le;</tt> for &le; are easy enough to generate).  
* Turning to the personalities... might I suggest that oil and water appear to be mixed here?  I intend this in the most polite tones possible, but both of you gentlemen seem to be very defensive of your positions on minute details.  I propose the following language as a compromise:
:
:*  Support for [[Unicode]] so that [[source code]] is not restricted to those characters contained in the [[ASCII]] character set; allowing, for example, use of non-[[Latin (language)|Latin]]-based scripts or extended punctuation.

If you don't like the "or extended punctuation" part due to lack of practice, feel free to strike it.

--[[User:EngineerScotty|EngineerScotty]] 23:40, 15 June 2006 (UTC)

: Looks good to me.  [[User:EngineerScotty|EngineerScotty]] most languages handle Unicode at the [[lexical]] level, ie before operators 'exist'.  Some languages allow Unicode everywhere (eg, [[Java]]) while others are more restrictive (eg, C).   [[User:Derek farn|Derek farn]] 23:46, 15 June 2006 (UTC)

All I wanted was to talk about it.  Was it really necessary to have an edit war to reach this point?

Scotty, your proposal looks good, but I would like to propose that we replace "source code with "program text".  [[User:Ideogram|Ideogram]] 23:50, 15 June 2006 (UTC)
* Fine by me. --[[User:EngineerScotty|EngineerScotty]] 23:52, 15 June 2006 (UTC)

:Waiting for your approval, Derek farn.  Scotty if he approves I think you should make the edit.  I think both of us should lay off editing for a while.  [[User:Ideogram|Ideogram]] 00:01, 16 June 2006 (UTC)

: [[Source code]] is a well known term and the subject of an article that discusses what might otherwise be called 'program text'.  Why invent another term for something that already has a well known name?    [[User:Derek farn|Derek farn]] 00:18, 16 June 2006 (UTC)

:: Egads.  I smell another somewhat inelegant compromise coming.  :)  Will change the article forthwith.  --[[User:EngineerScotty|EngineerScotty]] 00:21, 16 June 2006 (UTC)

::I really think we should be aiming this article at a person who doesn't know what a programming language is and for whom "source code" is not a well known term.  The meaning of "program text" is self-evident.  I don't think it's a good idea to make many readers click on a link to understand the sentence; it breaks their concentration.  [[User:Ideogram|Ideogram]] 00:23, 16 June 2006 (UTC)
:::I've made my change.  If you two wish to argue over two words, be my guest.  I withdraw for now.  --[[User:EngineerScotty|EngineerScotty]] 00:25, 16 June 2006 (UTC)

::::I think "source text" is unacceptable to both of us.  [[User:Ideogram|Ideogram]] 00:26, 16 June 2006 (UTC)
:::::Good, you agree on something.  :)  Feel free to change it to whatever '''is''' acceptable to both of you.  --[[User:EngineerScotty|EngineerScotty]] 00:30, 16 June 2006 (UTC)

::::I think that "source text" is ok, "source code" would be better, but I am happy with things as they are.  At least it makes it clear we are talking about source.   [[User:Derek farn|Derek farn]] 00:33, 16 June 2006 (UTC)

:::::Someone who doesn't know what a programming language is isn't going to understand the term "source".  Why won't you address my objections?  [[User:Ideogram|Ideogram]] 00:38, 16 June 2006 (UTC)

::::::I really feel like I should refrain from editing for a while.  I can only hope that Derek farn will do the same.  [[User:Ideogram|Ideogram]] 00:31, 16 June 2006 (UTC)

Should we have a straw poll?  Am I (once again) the only one who feels this way?  [[User:Ideogram|Ideogram]] 00:32, 16 June 2006 (UTC)

I have a brilliant suggestion:

*  Support for [[Unicode]] so that [[source code]] (program text) is not restricted to those characters contained in the [[ASCII]] character set; allowing, for example, use of non-[[Latin (language)|Latin]]-based scripts or extended punctuation.

[[User:Ideogram|Ideogram]] 00:41, 16 June 2006 (UTC)

** Looks fine to me. --[[User:EngineerScotty|EngineerScotty]] 00:48, 16 June 2006 (UTC)

[[User:Ideogram|Ideogram]] please follow your own suggestion and let's leave this issue alone.  [[User:EngineerScotty|EngineerScotty]] has worked out a compromise (thanks to him, from me).  [[User:Derek farn|Derek farn]] 00:59, 16 June 2006 (UTC)

Here we see further evidence of Derek farn's total contempt for me:
[[User talk:Cobaltbluetony#from derek_farn]].  [[User:Ideogram|Ideogram]] 01:01, 16 June 2006 (UTC)

At this point I cannot work with Derek farn until the mediator returns.  [[User:Ideogram|Ideogram]] 01:08, 16 June 2006 (UTC)

:And as if by magic, the shopkeeper appeared.  Sorry, crap UK old childrens TV program joke. TIME OUT guys, calm down, have a beer, and relax.  This situation keeps arising because you seem determined to aggravate each other.  Here's a proposal - if someone does something to the article you don't like, DON'T revert it, bring it to the talk page to discuss it.  And actually discuss it.  By the nature of the wikipedia, articles need to be written in language that is ''acceptable'' to everyone, ''not'' necessarily the exact wording each editor would choose.  If the language of the text does the job, but isn't the wording you would have used, let it go - other bits of the article will be in your language.  The above argument is a prime example - source code would be perfectly fine.  Sure, some people may be a bit confused, but would have done the job perfectly well.  Before objecting to language, try and think ''putting aside who made the edit, does it do the job reasonably well'' (note, not perfectly, just well enough), if so let it be and move on.  You're both skirmishing with the 3RR, which isn't a good idea, please be cautious with your reverts. [[User:kcordina|Kcordina]] <sup> [[User talk:Kcordina|Talk]] </sup> 08:48, 16 June 2006 (UTC)

::Well said, well said. Maybe we could put program text in paras after the first use od source code to help aliviate confusion. [[User:Jaxad0127|Jaxad0127]] 17:17, 16 June 2006 (UTC)

:::That was my suggestion.  Derek farn doesn't want to discuss it.

:::I'd like to point out that I am always the one who wants to discuss things, and Derek farn always ignores me.  [[User:Ideogram|Ideogram]] 23:32, 16 June 2006 (UTC)

== Jaxad's merge ==

Jaxad, I don't know if that merge was a good idea.  It's bound to confuse anyone coming upon the discussion later trying to figure out what happened.

Ah, who am I kidding.  No one is bored enough to wade through all that crap.  [[User:Ideogram|Ideogram]] 00:08, 16 June 2006 (UTC)

:The reason I did that was because the discussion was split between two topics. SOmeone looking at just one wouldn't get everything. [[User:Jaxad0127|Jaxad0127]] 00:14, 16 June 2006 (UTC)

::It's ok, not a big deal.  Thanks for trying to help.  [[User:Ideogram|Ideogram]] 00:19, 16 June 2006 (UTC)
{{talkarchive}}

== Lead paragraph trying again ==

Okay I've slept on the matter.  Let me try to summarize my position.

It really would be best to provide a simple citation, as I have done.  All the evidence presented so far is indirect.  Nevertheless, I expect to be shouted down on this point, so I will yield.

The next question is how to write the lead paragraph to be NPOV between the two positions.  This is the question I tried to bring up before that was universally ignored.  I hope no one disputes this, as I really can't see how you can possibly argue that the Turing-complete POV should be completely ''ignored'' as my POV, having two citations, is by Wikipedia policy in a stronger position than your POV, having none.  [[User:Ideogram|Ideogram]] 01:36, 17 June 2006 (UTC)

===Citations===
Ideogram, it is somewhat frustrating that you keep insisting that the other POV has no citations.  I have provided a number of citations where the term "programming language" is used to refer to a non-Turing complete language.  I am not sure what would satisfy you.  Sources that does not think that Turing-completeness is not a prerequisite for a programming language will not necessarily have a sentence saying "a programming language need not necessarily be Turing-complete"; if an author believes that Turing-completeness is irrelevant, then that author will most likely simply not mention it.  In a similar fashion, sources that do not consider intelligent design relevant to evolutionary biology will not mention the ''absence'' of a designer; they will simply discuss evolutionary biology.  Nevertheless, I will humor you and provide a few ''more'' citations, in addition to the ones I have ''already'' provided.

:''Programming languages'' are notations.  They are used for specifying, organizing, and reasoning about computations.  Just as English compositions range from notes to sonnets, programs range from prototypes that are used once and forgotten to production tools that are shared and supported.  This range of needs has motivated the creation of hundreds of programming languages.
:Language designers balance
:*making computing convenient for people with
:*making efficient use of computing machines.
:Convenience comes first.  Without it, efficiency is irrelevant.
:---[[Ravi Sethi]], ''Programming Languages: Concepts and Constructs''
Nothing about Turing-completeness there, nor in the whole textbook ("Turing" does not even appear in the index.)  Also consider this:
:Programming languages are the medium of expression in the art of computer programming.  An ideal programming language will make it easy for programmers to write programs succinctly and clearly.  Because programs are meant to be understood, modified, and maintained over their lifetime, a good programming language will help others read programs and understand how they work.
:---John C. Mitchell, ''Concepts in Programming Languages''
Nothing about Turing-completeness there either.  Mitchell does write, later:
:Computability theory establishes some important ground rules for programming language design and implementation.  ...[deletia]... All standard general-purpose programming languages give us the same class of computable functions (p.16)
However, note that Mitchell felt the need to qualify this statement with the adjective "general-purpose".  Mitchell could easily have omitted this qualifier, but then his statement would have been false.  At best, the above statement only claims that ''general-purpose'' programming languages need to be Turing complete (although I still insist that this is a rather curious claim in the face of FORTRAN-77, which had neither a heap nor a stack).
[[User:K.lee|k.lee]] 22:23, 19 June 2006 (UTC)

p.s. See also [http://www.acm.org/sigs/sigplan/sigplan_bylaws.htm SIGPLAN bylaws], cited by Allan below:
:The scope of SIGPLAN is the theory, design, implementation, description, and application of computer programming languages - languages that permit the specification of a variety of different computations, thereby providing the user with significant control (immediate or delayed) over the computer's operation.
Note that SIGPLAN represents the combined authority of virtually every serious programming language researcher on the planet.  If there is any reasonable citation for a "consensus" definition of programming languages, SIGPLAN's definition is it.  There is nothing about Turing-completeness here. [[User:K.lee|k.lee]] 22:28, 19 June 2006 (UTC)

:I'm not trying to exclude your POV.  I'm asking you not to exclude mine.  [[User:Ideogram|Ideogram]] 22:41, 19 June 2006 (UTC)

===Including my POV===

That's not quite what I had in mind.  I was talking about the lead paragraph.  Here's a clunky first draft that might give you the idea:

:A programming language is an artificial language intended to be usable for controlling the behavior of a machine (often a computer).  Some authors require a programming language to be general-purpose, that is, able to express any computer program (in mathematical terms, Turing-complete).

:Like human languages, programming languages have syntactic and semantic rules used to define meaning.

:Thousands of different programming languages[1] have been created and new ones are created every year. Few languages ever become sufficiently popular that they are used by more than a few people, but professional programmers are likely to use dozens of different languages during their career.

BTW we need a two to three paragraph lead that adequately summarizes the article for FA status.

Thank you for your patience and being willing to discuss.  [[User:Ideogram|Ideogram]] 23:05, 19 June 2006 (UTC)

Why must we mention Turing-completeness in the article lead? [[User:K.lee|k.lee]] 23:31, 19 June 2006 (UTC)

:We could footnote it if you prefer.  [[User:Ideogram|Ideogram]] 23:35, 19 June 2006 (UTC)

::Please note that "Turing-complete" is emphatically ''not'' the same as "able to express any computer program". Turing machines expressly exclude the possibility of input during computation. Quoting from [http://informatik.unibas.ch/lehre/ss06/cs105/_Downloads/OnComputableNumbers.pdf Turing's original paper]:
:::''If at each stage the motion of a machine (in the sense of §1) is completely determined by the configuration, we shall call the machine an “automatic machine” (or a-machine). For some purposes we might use machines (choice machines or c-machines) whose motion is only partially determined by the configuration (hence the use of the word “possible” in §1). When such a machine reaches one of these ambiguous configurations, it cannot go on until some arbitrary choice has been made by an external operator. This would be the case if we were using machines to deal with axiomatic systems. In this paper I deal only with automatic machines, and will therefore often omit the prefix a-.''
::Languages which include the capability to receive input during computation (i.e. most general-purpose languages) are capable of expressing programs that ''cannot'' be reduced to a Turing machine (but might be expressed as a "choice machine"). --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 16:11, 20 June 2006 (UTC)
:::Good point. Since no language (at least that I've heard of) absolutely requires user input durring processing, Turing completeness still holds.  Note that input before processing (like arguments) would still keep it in the automatic category, because the program doesn;t have to wait for input, it already has it. [[User:Jaxad0127|Jaxad0127]] 16:30, 20 June 2006 (UTC)

::::You (I think) misunderstand my point. I'm not claiming that it isn't possible to write programs that conform to the Turing machine model of computation. I'm saying that there are programs that ''cannot'' be expressed as Turing machines, but ''can'' be expressed in programming languages (such as programs that involve interaction). As a result, the claim that Ideogram makes in his proposed leader (''...able to express any computer program (in mathematical terms, Turing-complete)...'') is false, since "Turing-completeness" != "able to express any computer program". It's perhaps true that "Turing-completeness" == "able to express any ''non-interactive'' computer program", but even that is questionable. See [http://plato.stanford.edu/entries/church-turing/ here] for more. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 16:39, 20 June 2006 (UTC)

:::::What if we change the wording to say algorithm instead of program? Algorithms are non-interactive, which would remove any those problems. We could also say that programs are made of algorithms. [[User:Jaxad0127|Jaxad0127]] 20:24, 20 June 2006 (UTC)

== The Turing bit in "Definitions" ==

I still think a footnote is better, but I yield to Derek on his preference for inline text.

: I suspect that most readers will be surprised by these examples.  Also I have seen instances where people have jumped in and edited material without reading the footnotes.  An 'idiot proof' article cuts down on the maintenance.  [[User:Derek farn|Derek farn]] 02:04, 18 June 2006 (UTC)

However, I want to not that I think something like [[sed]] is important to list in the examples.

: I think Joe Smoe will have heard of html, might have heard of sql and is very unlikely to have heard of sed (care to bet that an 'expert' windows programmer edits out that entry within 24 hours?).  [[User:Derek farn|Derek farn]] 02:04, 18 June 2006 (UTC)

::If so, I'll restore it.  Readership is mixed; it's general audience sure, but use of *nix systems is not "non-general".  I don't want to belabor the issue of the exact computational power of 'sed' (which I believe should be equivalent to a regular grammar; or maybe even more than that), but mentioning something fairly well-known and at a meaningfully "intermediate" level of power is worthwhile.  It's only a half-dozen words, if readers want to know more, they can follow the [[sed]] link. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 04:12, 18 June 2006 (UTC)

:::As it turns out, sed is apparently [http://sed.sourceforge.net/grabbag/scripts/turing.txt Turing complete]. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 20:29, 19 June 2006 (UTC)

::::Oh, that seems right.  I had forgotten about the 'b' instruction since... well, when I use sed it's almost always just 's/foo/bar/'. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 20:41, 19 June 2006 (UTC)

In particular, my own use of "programming language" would almost certainly exclude HTML or similar markup-only languages, though I recognize PL is sometimes used by non-experts of HTML.  On the other hand, I would myself almost certainly call sed scripts "programming language" (knowing full well their limited computation power).

: Which of the definitions of programming language would you apply to sed scripts?   [[User:Derek farn|Derek farn]] 02:04, 18 June 2006 (UTC)

::Of the bullets, the first three ''all'' clearly apply to sed scripts, especially to scripts that are more than one-liners.  The last bullet isn't exactly a definition: it says there are these different levels of computational power, and lots of things are Turing-equivalent, but it doesn't realy ''define'' the language in terms of computability. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 04:16, 18 June 2006 (UTC)

An important difference is that sed ''does something''.  That is, you can run a sed script to perform relatively sophisticated and complicated modifications to files, and in a way you might want to repeat against different input files.  In that, it serves a very similar role to Perl, Python, Bash, etc. (Is Bash Turing-complete if you exclude all the standard file/text utilities it typically utilizes? The answer isn't immediately obvious to me, though I would lean toward "yes" in my intuition).

SQL has a little bit of the same quality.  It performs meaningful manipulations on a special object, an RDBMS.  But something that tweaks texts and files has much more of the "feel" of a regular programming language, quite apart from details of syntax or formal computational power. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 00:45, 18 June 2006 (UTC)

=== Digression on branching and loops ===
It's not a terribly important point, but the third bullet in "Definitions" lists [[flow control]] as part of the description.  On might be inclined to think that [[sed]] does not include flow control.  However, this is not so.  While you cannot ''loop'' in sed, you ''can branch''.  For example, let's implement this pseudo-code IF block:

 FOR LINE in FILE:
   IF contains_digits(LINE):
     use_ampersand(LINE)

Here's my sed version:

 $ cat test.data 
 Spam and 37 eggs
 Spam and twenty-one eggs
 $ cat test.sed
 s/\(.*\)\([0-9]\)/(HAS NUM)\1\2/
 s/^\((HAS NUM)\)\(.*\)\(and\)\(.*\)/\2\&\4/
 $ sed -f test.sed test.data 
 Spam & 37 eggs
 Spam and twenty-one eggs

In particular, I create a placeholder prefix on the line in order to effectively have an "IF" test on the next line of the sed script.  More complex arrangements are possible with such placeholders, but this shows the concept.

Also, as written, the article describes the need for a looping construct to be Turing complete.  While something like a loop (including recursion, though calling that a loop feels a bit pedantic to me) is ''necessary'', it is not ''sufficient''.  You need a specific kind of loop.  The example [[BlooP and FlooP programming languages|BlooP]] was constructed specifically to show that a loop can be "too weak" for Turing completeness.  This isn't the article to get into a lot of detail on that, but I wonder if maybe a word or two couldn't be changed to be slightly more accurate (what it says isn't ''false'', but it's slightly ''misleading''). <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 05:09, 18 June 2006 (UTC)

:As I recall the BlooP/FlooP discussion had nothing to do with Turing completness (I cannot recall whether it was about [[Chomsky]]'s four levels of grammar or [[first order logic]] vs. [[propositional calculus]].  I will have to go and dig my copy of GEB out from under a big pile of boxes in the garrage.  Look at the definition of [[Turing machine]] to see that a test and jump loop is all that is needed (plus of course store/recall).  [[User:Derek farn|Derek farn]] 20:38, 19 June 2006 (UTC)

::BlooP has a loop, but it's something like "Loop no more than N times".  N is itself unbounded, but must be specified in the construct.  That's enough to make it not-quite-Turing.  Obviously, if it had a GOTO, that would also be strong enough, but it doesn't. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 20:44, 19 June 2006 (UTC)

== Frankly, the article lacks some critical points ==

"program" is not defined in the article (A list of instructions performed by a computing machine). "Programming" is not defined in the article (The creation of such a list of instructions).  "Language" is defined early but reference to it is preceed by "artificial" which is wholly insubstantial because there is nothing artificial about a list of instructions.  A programming language is the most direct and best method of communicating with a machine and the purpose of a language is always communication.  "Artifical" should be struck from the first line.  "Program" should be placed first in the list of definitions.  The article also mispresents, I believe, the commonality of modernly used languages.  Its first paragraphs create a confusion of "thousands of languages" with no starting point for a person to begin to understand that a programming language is a method by which a person instructs a machine to perform a series of operations. [[User:Terryeo|Terryeo]] 08:58, 19 June 2006 (UTC)

== Spurious "citation needed" ==

There were {fact} tags recently added to all the bullet points in "Definitions" (in what I certainly hope is not [[WP:POINT]]).  I'm having a bit of trouble making sense of those tags.  I removed the last of these since it seems only to accompany a brief summary of what's in the linked article [[theory of computation]] (the latter is, or should be, sufficiently cited).

The first three bullets have their {fact} tags right now.  But I can only just barely make sense of what's being requested, and only if I kind of squint my eyes a bit.  Most neutral summaries of uniform consensus opinions do not require a specific footnote.  And it's hard for me to see where any actual dispute or doubt applies to the bulleted items.  By analogy, the first sentence does not read:

:A '''programming language''' is an [[artificial language]]{{Talkfact}} intended to be usable for controlling the behavior of a machine (often a [[computer]]{{Talkfact}}).  Like [[natural  language|human languages]], programming languages have [[syntax|syntactic]]{{Talkfact}} and [[semantic]]{{Talkfact}} rules used to define meaning.

...because no one seriously doubts or disagrees that PLs are artificial languages; often used on computers; have a syntax; or have a semantics.  Some editors I come across seem to have a confusion between the idea that WP is not original research, and the wrong idea that WP is the same thing as a photocopier.

So what's actually in dispute about the bulleted definitions? <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 17:53, 19 June 2006 (UTC)

:I'm not disputing them, nor is this a [[WP:POINT]].  I think they need citations (see below).  [[User:Ideogram|Ideogram]] 19:06, 19 June 2006 (UTC)

::So it's just a random sprinkling of "citation needed" tags because you think the ''total number'' should be higher?! That's just plain wrong-headed, I'm afraid.  And it sure sounds a lot like [[WP:POINT]] to me... a better approach would be to actually add a concrete citation where you think it is useful and relevant.

:::Don't accuse me of [[WP:POINT]], or I will get cranky.  I specifically mentioned earlier that I wanted citations for these alternate definitions.  [[User:Ideogram|Ideogram]] 19:21, 19 June 2006 (UTC)

::FWIW, I do think more footnotes would be desirable.  But the last time I tried to add one, Derek farn took it out on the grounds that "readers don't look at footnotes".  So I ceded on that, and let the material go in the main text. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 19:15, 19 June 2006 (UTC)

:::Not footnotes.  Citations.  References to secondary sources backing up included material.  See [[Wikipedia:Featured article candidates/Forth]].  [[User:Ideogram|Ideogram]] 19:21, 19 June 2006 (UTC)

=== Be specific ===
Leaving aside warring pointillism or crankishness, can you please explain with specificity, Ideogram, what you feel needs citation in the following... and what would constitute relevant citation:

*''The language's users and audience.''  For example, a programming language differs from [[natural language]]s in that natural languages are used for interaction between people, while programming languages allow humans to communicate instructions to machines.{{Talkfact}}
*''The language's constructs.'' For example, a programming language may contain constructs for defining and manipulating [[data structure]]s or for controlling the [[control flow|flow of execution]].{{Talkfact}}

I'm quite honestly and sincerely at a loss to understand how those differ from the lead sentence ''reductio ad absurdum'' I mention.  What type of publication might be relevant to supporting such broad and commonplace summaries?  Actually, let me back-pedal slightly... I can ''slightly'' make sense of how the data-structures/flow-control might be a non-universal characterization.  The "interacting with machines" part I can't get at even that level. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 19:44, 19 June 2006 (UTC)

:Derek farn claimed that there were different definitions in use.  I want to see citations stating those definitions like the citations I provided stating my definition.

:But if you don't want to do it, don't let me stand in your way.  I've been advised, by the mediator no less, to leave this article entirely and let you guys work it out.  No, I'm not bitter.  [[User:Ideogram|Ideogram]] 20:22, 19 June 2006 (UTC)

:::I didn't actually; what I said was "Leaving the article be is one solution" ([[User_talk:Kcordina#Derek farn]]) which is very different.  If you're going to quote me, do it correctly. [[User:kcordina|Kcordina]] <sup> [[User talk:Kcordina|Talk]] </sup> 10:05, 20 June 2006 (UTC)

::::Sorry I misquoted you.  [[User:Ideogram|Ideogram]] 12:51, 20 June 2006 (UTC)

::"The mediator"? Is that something like Erdos' "the Book"? Or is it just what you call the voices in your head :-) (don't worry... I call the voices in my head "Gertrude", which is no better). <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 20:47, 19 June 2006 (UTC)

:::The mediator is Kcordina, the user who took my Mediation Cabal request.

:::The many voices in my head never stop arguing with each other, so I call them Usenet.  [[User:Ideogram|Ideogram]] 21:59, 19 June 2006 (UTC)

== FAC premature ==

I guarantee this FAC nomination will fail.  I recently tried a FAC nomination and was told I need as many as one citation ''per paragraph''.  This article is nowhere near that.  [[User:Ideogram|Ideogram]] 19:04, 19 June 2006 (UTC)

:FAC commentators make lots of different comments, often contradicting each other.  I'm not ''per se'' disagreeing with the ">1 citation/para" guideline, but someone suggesting that isn't the same as it being an actual WP guideline.

::Several commentators noted the need for more citations in my nominee.  This article has a similar level of citation.  [[User:Ideogram|Ideogram]] 19:17, 19 June 2006 (UTC)

:In any case, I imagine we can benefit from whatever FAC commentators suggest.  There's nothing particularly wrong with failing a FAC nomination; and it's even a good thing if it generates useful suggestions (there's no restriction on renominating later).

::I agree we can benefit from their suggestions, but I could have told you what they would say.  [[User:Ideogram|Ideogram]] 19:17, 19 June 2006 (UTC)

:Actually, the truth is that I really could hardly care less whether or not this article becomes an Featured Article.  Ideogram—and I think a couple other editors—have suggested that would be a desirable thing.  So I figured some outside input on where it might fall short of that would be helpful. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 19:12, 19 June 2006 (UTC)

::Again, I do feel FA status is desirable, but if you had asked me I would have told you what that requires.  Certainly a Peer Review first would have been a good idea.  [[User:Ideogram|Ideogram]] 19:17, 19 June 2006 (UTC)

:::Opinions vary, but I've had a number of editors comment that Peer Review rarely generates as much, or as relevant, commentary as FAC nomination. That's pretty much been my experience as well. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 19:34, 19 June 2006 (UTC)

::::<Shrug>.  It helped me.  See [[Wikipedia:Peer review/Forth/archive1]].

BTW we will need to wait a month after the failed nomination to renominate.  It's ok, we will need the time.  [[User:Ideogram|Ideogram]] 16:00, 20 June 2006 (UTC)

==HTML as programming language==

HTML is not a programming language; as its name says, it is a "markup language" designed to indicate the structure of data.  Though it isn't really a data structure either, it is reasonable to treat the DOM tree that it describes as a data structure.  Javascript operating on HTML to make "dynamic HTML" is not a new programming language; it is the Javascript programming language operating on the DOM data structure.  It is like the difference between S-expressions and Lisp programs:  (((a . b) c) (x) (23 4.5)) is a Lisp S-expression (a piece of data), while (cond ((atom x) x) (t (cons (cdr x) (car x)))) is a program fragment.  In Lisp, of course, the program is expressed using the S-expression data structure.  But then, there are *other* programming languages (such as, say, Planner) which use S-expressions as the representation of programs. --[[User:Macrakis|Macrakis]] 20:05, 19 June 2006 (UTC)

:While I haven't wanted to rock that particular boat, I second Macrakis' comments and his edit in removing HTML as an example.  I wonder though if it might not be possible to add something along the lines of: ''Non-computational [[markup language]]s are sometimes informally referred to as programming languages.''  I agree the equation is a mistake, but it's one that's made fairly often by laypeople. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 20:12, 19 June 2006 (UTC)

::I also agree with [[User:Macrakis|Macrakis]]. PLs are a ''subset'' of [[computer language]]s. The key distinction is (I think) the ability to express some kind of computation. Many introductory PL texts start with a simple language of arithmetic. AFAIK HTML cannot be used to express even simple arithmetic. The semantics of HTML are structural rather than computational. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 20:25, 19 June 2006 (UTC)

:::And before anyone jumps on me for not providing a citation for the use of "ability to express computation" as a criteria for defining programming languages, I quote from the scope section of the [http://www.acm.org/sigs/sigplan/sigplan_bylaws.htm Bylaws of the ACM SIGPLAN]:
::::''The scope of SIGPLAN is the theory, design, implementation, description, and application of computer programming languages - languages that permit the '''specification of a variety of different computations''', thereby providing the user with significant control (immediate or delayed) over the computer's operation.'' (emph. mine)
:::--[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 20:44, 19 June 2006 (UTC)

The issue is not whether we think HTML is a programming language (I don't), but that lots of other people think that it is.  A definition of any term is decided by the poeple who use it.  A subset of people may choose to define it one way (eg, Turing completeness), but that will not stop other people using it in other ways.  If we are to write a truely unbiased article then we need to reflect views other than our own.  If you go back through the logs you will see that there have been discussions about defining a [[General-purpose_(programming_languages)|general purpose]] language as one that is Turing complete.

So HMTL is a [[markup language]], so is [[postscript]] and nobody claims that postscript is not a programming language (ok, perhaps a few people do). [[User:Derek farn|Derek farn]] 20:47, 19 June 2006 (UTC)

:But you can ''express computations'' in Postscript, or LaTeX.  You cannot do so in HTML/XML/troff/etc. (wait, someone will come along and tell me I forgot some wrinkle in troff :-)). <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 20:51, 19 June 2006 (UTC)

::Postscript is ''not'' a markup language, that is, a language intended to define the structure of string data.  It actually computes the display in very general ways and is in fact Turing-complete (see WP article).... --[[User:Macrakis|Macrakis]] 20:55, 19 June 2006 (UTC)

:::The line ''is'' slightly fuzzier than Macrakis suggests.  TeX is also Turing complete, yet clearly the primary ''use'' of (La)Tex is to "markup documents".  So it's not completely irrational for lay audiences to conflate the cases, given the overlap. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 20:58, 19 June 2006 (UTC)

::::I agree that the line is not crystal clear, but it is not all that fuzzy.  If the language is intended primarily to specify structure which can be used in various ways, then it is a markup language.  If it is primarily intended for execution, then it is a programming language.  Of course, you can do various things with programs (analyze them statically, etc.), so that is where some of the fuzziness comes in.  The example of TeX vs. Latex is actually instructive.  TeX is pretty clearly a programming language; Latex is a layer on top of TeX which is supposed to make it look more like a markup language, although it really does have TeX inside, so it is a programming language masquerading as a markup language.  Brian Reid's Scribe was clearly supposed to be a markup language.  The syntax is not the issue here: clearly you can define a programming language with S-expression or HTML-like syntax. --[[User:Macrakis|Macrakis]] 21:11, 19 June 2006 (UTC)

:Just because some people get programming languages and markup languages confused doesn't mean that we need to propagate the confusion here. If anything, I would think this article provides a perfect opportunity to ''inform'' those who are confused as to the distinction between markup and programming. I think that LotLE's suggestion to point out that some people incorrectly call markup languages programming languages is a good one. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 20:59, 19 June 2006 (UTC)

::Sounds good. That distinction is very important. [[User:Jaxad0127|Jaxad0127]] 21:10, 19 June 2006 (UTC)

== Ada ==

I note that [[User:Macrakis|Macrakis]] has again reverted the mention of Ada as a general-purpose programming language. In order to forestall another revert war, I'd like to point out the following, which support [[User:Macrakis|Macrakis]]:
# The [[Ada programming language]] article specfically states that Ada was originally created for embedded systems.
# The Ada [http://en.wikisource.org/wiki/Steelman_language_requirements Steelman language requirements document] contains the following, which also confirms [[User:Macrakis|Macrakis]]' assertion that Ada was created a an embedded language rather than a general-purpose language
::''The technical requirements for a common DoD high order programming language given here are a synthesis of the requirements submitted by the Military Departments. They specify a set of constraints on the design of languages that are appropriate for '''embedded''' computer applications (i.e., command and control, communications, avionics, shipboard, test equipment, software development and maintenance, and support applications).'' (emph. mine)
--[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 20:20, 19 June 2006 (UTC)

== Citation format ==

For your reference, templates like {{[[Template:Cite web|Cite web]]}} and {{[[Template:Cite book|Cite book]]}} may be useful.  [[User:Ideogram|Ideogram]] 14:13, 20 June 2006 (UTC)

Please see [[User:Spangineer/inline citations]].  This user is a very active FAC commentator.  [[User:Ideogram|Ideogram]] 15:41, 20 June 2006 (UTC)

== Revised leader ==

I have two concerns about the recently revision to the leader:
# As I [[Talk:Programming_language#Including_my_POV|pointed out above]], in the last dialogue on Turing completeness, "Turing complete" is not the same as "able to express any computer program", since Turing machines are non-interactive. Turing explicitly stated this in his original paper, as the quote I gave above shows.
# The present wording of the leader strikes me as odd. Are there truly authors that really require all programming languages to be "general-purpose"? Or do these authors require that "general-purpose" programming languages be Turing complete?
--[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 16:26, 20 June 2006 (UTC)

Here is the quote I presented earlier, copied from the archive:

:A programming language is a language intended for the description of programs.  Often a program is expressed in a programming language so that it can be executed on a computer.  This is not the only use of programming languages, however.  They may also be used by people to describe programs to other people.  Indeed, since much of a programmer's time is spent reading programs, the understandability of a programming language to people is often more important than its understandability to computers.

:There are many languages that people use to control and interact with computers.  These can all be referred to as ''computer languages''.  Many of these languages are used for special purposes, for example, for reserving seats on airplanes, conducting transactions with a bank, or generating reports.  These special-purpose languages are not ''programming'' languages because they cannot be used for general programming.  We reserve the term ''programming language'' for a computer language that can be used, at least in principle, to express any computer program.  Thus, our final definition is:

:''A programming language is a language that is intended for the expression of computer programs and that is capable of expressing any computer program.''

:--Principles of Programming Languages, 2nd ed.

There is a footnote.  The sentence "We reserve the term ''programming language'' for a computer language that can be used, at least in principle, to express any computer program." has the footnote "This is not a vague notion.  There is a precise theoretical way of determining whether a computer language can be used to express any program, namely, by showing that it is equivalent to a universal Turing machine.  This topic is beyond the scope of this book."

It seems quite clear.

I of course would agree with your adding your POV to the article, with the citations you have provided.  [[User:Ideogram|Ideogram]]

:I have modified the wording to say "algorithm" instead of "computer program". This is a more accurate statement, since algorithms are explicitly non-interactive, while still retaining the spirit of what the PoPL quote says. Is this acceptable to you? --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 16:49, 20 June 2006 (UTC)

::I think your clarification is excellent, better than my wording.  [[User:Ideogram|Ideogram]] 16:55, 20 June 2006 (UTC)

== formatting bug ==

I notice you removed the breaks I inserted.  I don't know about your browser, but on mine (firefox) there seems to be a formatting bug that runs all three paragraphs in the lead into one paragraph.  I don't know how to fix this.  [[User:Ideogram|Ideogram]] 17:11, 20 June 2006 (UTC)

:This appears to be a problem cause by the CSCOTW template. Since it's been more than a week since this article became CSCOTW I've simply removed the template. Not sure exactly what the problem was though. I'll have to take a look at the template. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 17:19, 20 June 2006 (UTC)

::I suspect when you moved the footnote ahead of the period it fixed the bug.  I've noticed this before when a footnote ends a paragraph.  [[User:Ideogram|Ideogram]] 17:27, 20 June 2006 (UTC)

::I don't know how to remove Programming language from the box on [[Wikipedia:WikiProject Computer Science/Collaboration of the Week]].  [[User:Ideogram|Ideogram]] 17:47, 20 June 2006 (UTC)

:::Ok, I've made the fix. I've also added a "change current CSCOTW" link to the template in question, so any time you want to chnage the article to a new one you can just click the link and make your edit. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 18:40, 20 June 2006 (UTC)

== Changes to lead ==

I don't like Lulu's changes to the lead.  [[User:Ideogram|Ideogram]] 18:43, 20 June 2006 (UTC)

:They look good to me. What precisely are you objecting to? --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 19:22, 20 June 2006 (UTC)

::*<s>I don't understand why my added sentence should be at the end of the lead para instead of the second sentence.</s>  On second glance, I see that the notion of algorithm is introduced in the previous sentence, so this makes some sense.  Let me think about this.
::*I don't like "every", I don't see why that's better than "any", and I don't like it italicized.  [[User:Ideogram|Ideogram]] 19:29, 20 June 2006 (UTC)

I really detest italics.  It yells "look at me", almost as bad as capitalization.  [[User:Ideogram|Ideogram]] 20:23, 20 June 2006 (UTC)

"every algorithm" is just plain incorrect here.  It implies a programming language can express every algorithm ''all at the same time''.  [[User:Ideogram|Ideogram]] 20:29, 20 June 2006 (UTC)

:No, it doesn't imply that.  Trust me, I get paid good money to write, and to understand the nuance of words.  ''Any'' really fails to get at the contrast the sentence needs to make.  It's ambiguous and restrictive, rather than appropriately expansive.  E.g. "Is there ''any'' algorithm you can express in FlooP?" <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 20:51, 20 June 2006 (UTC)

::Trust me, I won a national high school English award and did my Humanities concentration in Creative Writing at MIT.  I gave you "conceives" over "views", why don't you give me "any" over "every"?

::E.g. "You can express ''any'' algorithm in FlooP" vs. "You can express ''every'' algorithm in FlooP"

:::Right, the first one is tin-eared, the second one better expresses the intention. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 22:06, 20 June 2006 (UTC)

::I'm sorry to have to do this to you, but you also thought you knew more about FA status than I did, and you were proven wrong.  I do take care to know what I'm talking about.  [[User:Ideogram|Ideogram]] 21:11, 20 June 2006 (UTC)

:::Honestly, Ideogram, you're not ''that'' new to Wikipedia anymore.  It's time to grow past this Usenet-ish habit of turning every irrelevant thing into the most tortured argument, carried on to the lengthiest degree possible. (and no, I never expressed any opinion about whether I or you "knew more about FA status"). <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 22:06, 20 June 2006 (UTC)

::::You really should comment on the content and not the contributor.  And if it's irrelevant, you could just let me have my way, like I let you have your way on FP. [[User:Ideogram|Ideogram]] 22:36, 20 June 2006 (UTC)

::''There's no contrast''.  You just think there's a big contrast since we had a big argument about it.  It's a minor detail hardly noticeable to someone new to the subject.  [[User:Ideogram|Ideogram]] 21:18, 20 June 2006 (UTC)

:::If there was no contrast, there would be no need for the final sentence.  It's not some ideological war, it's just the development of the paragraph.  It flows from a weaker, or more expansive, definition to a stronger or more restrictive one.  The final sentence of the lead about ''every computation'' is a verbal '''contrast''' with the plain "some  computation".  But it needs to be highlighted, or it just reads like redundancy (yes, I realize that a reader paying very close attention can draw out the distinction, but we're not posing a puzzle, rather conveying a meaning). <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 22:06, 20 June 2006 (UTC)

::::I'm tired of arguing about this.  [[User:Ideogram|Ideogram]] 22:36, 20 June 2006 (UTC)

== Thanks for ISBN Allan ==

Thanks for that ISBN.  I really should have done it myself since I have it right in front of me. [[User:Ideogram|Ideogram]] 18:56, 20 June 2006 (UTC)

== Definitions section ==

The fourth entry is like Euclid's parallel lines postulate:  it's way longer and more clunky than the others.  [[User:Ideogram|Ideogram]] 19:49, 20 June 2006 (UTC)

== punct then ref ==

The style guideline I read said both are acceptable.  However, since both are acceptable, and the bug I was trying to avoid doesn't seem to be happening, I'll leave it.  Personally I like it better this way too, I was just worried about the bug.  [[User:Ideogram|Ideogram]] 20:18, 20 June 2006 (UTC)

:COTW template's gone, so no bug.  See [[Wikipedia:Footnotes#Style recommendations]] for style guide: i.e. normally "word-punct-ref", with exception only when footnote refers only to specific term or clause inside a sentence.  The example given is:

::Many editors prefer citations to follow punctuation,[6] like this.[6] However, if there are instances when there are two[7] terms that need a footnote[8] within the text of one sentence, then it is advisable to place the references right next to those terms.

:Notice especially the absence of extra space between punctuation and note. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 20:24, 20 June 2006 (UTC)

== SQL ==

SQL is not a computational language.  It's a query language.  [[User:Ideogram|Ideogram]] 22:47, 20 June 2006 (UTC)

:Charity is not a computational language. It's a programming language. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 23:34, 20 June 2006 (UTC)

::Well I don't know what adjective applies to them both.  I tried "artificial", feel free to suggest something.  [[User:Ideogram|Ideogram]] 23:53, 20 June 2006 (UTC)

:::Er. "Programming language"? Recall that ''some'' authors restrict the term "programming language" to Turing complete languages, not ''all'' authors. That's the whole point of giving those examples in the first place. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 23:58, 20 June 2006 (UTC)

::::There is disagreement whether they are programming languages.  A NPOV wouldn't take sides by calling them programming languages.  [[User:Ideogram|Ideogram]] 00:00, 21 June 2006 (UTC)

:::::Perhaps the "expressive power" bullet-point needs to be modified to make it more clear that although some people consider Turing-completeness a criteria for being called a "programming language" there are things like SQL and Charity that are considered by many to be programming languages but are not Turing complete. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 00:01, 21 June 2006 (UTC)

::::::Ok I took a stab at it.  See what you think.  [[User:Ideogram|Ideogram]] 00:10, 21 June 2006 (UTC)

Oh, I hadn't seen this discussion yet, and used the word "computational" again.  I think it's the right word, but I didn't do it to step on any toes.  SQL-92 ''is'' computational: you can filter, you can aggregate, you can do math, you can effectively "map()", etc.  It does many of the things normally referred to as "computations".  E.g. what do you call "<code>SELECT AVG(Age) FROM Persons WHERE Income > 50000</code>" if not a computation? I'd be up for a different adjective, if someone can think of something good... but the main point is to contrast with "markup" or "annotational". <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 01:27, 21 June 2006 (UTC)

:The ANSI/ISO thing is very good.  Specific and informative.  But I do have a problem with "and some other computational languages"; it seems vague, wordy, and hard to understand without adding much.  I'd really prefer just to delete (I know you hate that word) it.  [[User:Ideogram|Ideogram]] 01:51, 21 June 2006 (UTC)

::Well, five words.  I don't necessarily find that exact phrase mellifluous, but I think it's important to let readers know that the list that includes SQL, Charity is not meant as an exhaustive one.  As it read, it felt like a suggestion that only those two languages were "not-Turing".  I don't really care about the specific examples (though SQL is pretty familiar), but only about the indefinite-size quality of the list.  Other examples might include some macro languages, or RPN calculators (I'm pretty confident on that case now that I've read a bit more), or the deliberately limited BlooP, etc. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 02:46, 21 June 2006 (UTC)

:::Try that.  [[User:Ideogram|Ideogram]] 02:52, 21 June 2006 (UTC)

::::Looks good.  "Examples" is a nice word (I think it was there before, but in a slightly different sentence). <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 02:54, 21 June 2006 (UTC)

:::::Works for me! Nice job, both of you. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 03:02, 21 June 2006 (UTC)

::::::It's nice to see Lulu and I can still agree on something :-).  [[User:Ideogram|Ideogram]] 03:03, 21 June 2006 (UTC)
{{talkarchive}}

== Lead section again ==

Again, I'm not a big fan of italics, but it's good enough so I won't quibble.  [[User:Ideogram|Ideogram]] 01:46, 22 June 2006 (UTC)

== FAC ==

I feel this article is in good shape now and all outstanding issues have been resolved.  The only major obstacle to FAC status now is the paucity of citations.  [[User:Ideogram|Ideogram]] 02:09, 22 June 2006 (UTC)

Actually the lead could use some work.  Needs to adequately summarize the article.  [[User:Ideogram|Ideogram]] 02:12, 22 June 2006 (UTC)

I think it needs considerable work.  Flaws/needs in the article:
*Citations (agreeing with Ideogram)
*Illustrations (I will start a talk section below for illustration suggestions)
*Section length: syntax and type systems seem out of proportion to the rest of the article
*Some intro text at the beginning of the "Elements" section, before "Syntax" subsection, giving an overview of that section.
*"Instruction and control flow" section feels underdeveloped and perfunctory.  I would much rather see this become part of some more general notion of execution model ("dynamic semantics"), though I'm not sure how to fold this into the article yet.

:I agree this section is too short.  Unfortunately I don't know what "dynamic semantics" means.  I don't know what else you want to say here.  [[User:Ideogram|Ideogram]] 19:50, 22 June 2006 (UTC)

::It's not clear to me what that section is even trying to say. It seems to conflate several ideas: the notion of "keywords" and program structure (which is basically syntax), and operations that might be performed. I think it might be useful to have something that discusses the basic elements of a language (sequence, selection, iteration/recursion, procedural/functional abstraction, etc.). But I don't think the current version of the section does that. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 20:15, 22 June 2006 (UTC)

*Prose needs general improvement: better "flow" from section to section.  Reading through the article from beginning to end feels a bit choppy to me.
My personal recommendation would be for most of the regular editors to take a week or so break from the article and come back to it with fresh eyes.  The flaws will be more apparent.  I don't see any hurry to get this article to featured status.
[[User:K.lee|k.lee]] 19:43, 22 June 2006 (UTC)

:After the FAC nom process is over we can list it for peer review.  [[User:Ideogram|Ideogram]] 19:46, 22 June 2006 (UTC)

== Bullets? ==

I saw K.lee just re-bulletized the languages discussed in the History/Refinements section.  I took out bullets because... well, I find them yucky.  Maybe that's not a precise word, but it sort of suggests "Powerpoint" to me rather than "Professional article"; or more specifically, it's not quite the sort of logical enumeration that I might actually want in bullets (there is something enumerated about it, I confess, but it still somehow feels like an arbitrary enumeration).

However, K.lee is an excellent contributor, and I'm certainly not just going to change back.  Do other editors have a preference between bullets and paragraph text? <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 19:03, 22 June 2006 (UTC)

:I have a ''slight'' preference for the paragraph-text version. However, I think that version would need a little work, since it did have an enumerated feel to it even without the bullets. That said, I'm happy enough with the bulleted version. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 19:26, 22 June 2006 (UTC)

:I don't care one way or another about bullets vs. paragraph text, but ''nested bullets'' -- yuck.  [[User:Ideogram|Ideogram]] 19:27, 22 June 2006 (UTC)

Bullets are easier to read than paragraphs for list-structured data.  They are easier to parse and to skim.  The Wikipedia style guidelines used to say explicitly to use bullet lists and other structured markup in preference to long blocks of text, but I can't find it (the style guidelines have grown a lot bigger since I last read them).  I like a good paragraph of prose as much as anybody, but in general [http://www.useit.com/alertbox/reading_pattern.html people do not read long blocks of text on the web] and (for various reasons) it is really hard to produce a really good and enduring prose paragraph on Wikipedia anyway.  Hence, bullets.  [[User:K.lee|k.lee]] 19:32, 22 June 2006 (UTC)

:Oh well, I still disprefer the bullets... but there seems to be a slight tilt in their favor.  Actually, reading through the whole article again with this in mind, I realized how much I'd rather remove most of the bulleted lists.  I only actually did it that one place because I condensed the History section a bunch (since there's a more expansive child).  Then again, I wrote a long book on programming that consists of basically headings, paragraphs, and code samples.  150K words of eschewing bullets, cutesy graphics, decorations, font changes, etc... of course, Knuth is up to something like a million such words worth of dry paragraphs in TaoCP :-). <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 19:48, 22 June 2006 (UTC)
::I certainly understand your distaste.  Nevertheless, web readers are not TAoCP readers, the web is (currently) a medium typographically inferior to print, and we are not Knuth.  Best to be realistic.  [[User:K.lee|k.lee]] 19:58, 22 June 2006 (UTC)

:In [[Wikipedia:Peer review/Scheme programming language/archive1]] someone commented that most lists should be in prose form.  [[User:Ideogram|Ideogram]] 19:54, 22 June 2006 (UTC)
::The exact comment there was "This article may be a bit list-weighty; in other words, some of the lists should be converted to prose (paragraph form)."  If the article begins to feel like a collection of lists rather than a coherent article, then OK, we can revisit which lists should be converted into prose.  The commenter did not say that ''most'' lists should be in prose form, nor did (s)he reference any Wikipedia policy saying that most lists should be in prose form.  Judicious use of bullets to reflect list structure is OK.  [[User:K.lee|k.lee]] 20:01, 22 June 2006 (UTC)

[[User:203.135.12.118|203.135.12.118]] 16:24, 17 December 2006 (UTC)== Writing C in C++ ==

I took out my comment in a footnote about many Sourceforge C++ projects really being minimal C supersets.  Nothing really hangs on it... but it ''is'' sort of obviously true.  I mean, the below isn't ''technically'' a C program, but C++ (at least prior to C99):

 #include <stdio.h>
 int main(void) {  
   printf("hello, world\n");  // The output
   return 0; }

A lot of compilers just gloss over the little superset issues, so programmers need not think about niggles. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 19:39, 22 June 2006 (UTC)

== Illustrations ideas ==

OK, here's the talk section to discuss illustrations.  In my experience PL people prefer writing code to drawing pictures, but some pictures could give this article a lot more visual appeal, so... ideas? [[User:K.lee|k.lee]] 19:50, 22 June 2006 (UTC) <small><span class="autosigned">—Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[User:K.lee|K.lee]] ([[User talk:K.lee|talk]] • [[Special:Contributions/K.lee|contribs]]) </span></small><!-- Template:Unsigned -->

:That would be helpful.  What about a state-diagram? That's pretty much only for imperative programming, but it's easy to understand.  Or photos of important people in PL history? <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 19:58, 22 June 2006 (UTC)

:A few possibilities:
:* An image of syntax-highlighted source code
:* A graphical parse tree
:* A (simple) language evolution graph depicting the different languages mentioned in the history section, and their relationships
:--[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 20:08, 22 June 2006 (UTC)
::Something like this? <http://www.oreilly.com/news/graphics/prog_lang_poster.pdf>  :-) <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font>

:::There was a reason I inserted the parenthetical "simple", and mentioned restricting the graph to "languages mentioned in the history section" :-) --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 20:30, 22 June 2006 (UTC)

::Re: the parse tree idea, I think it would be nice, under the syntax section, to show a 3-part figure with (1) an array of characters, (2) the corresponding token stream, and (3) the AST.  LISP would probably be best here, as it has the simplest grammar.  And it would be especially nice if the parse that we illustrate were a substring of a larger syntax-highlighted code image we show elsewhere.  [[User:K.lee|k.lee]] 20:17, 22 June 2006 (UTC)

:::The drawback of LISP would be that there's not a lot of syntax to highlight ;-) --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 20:30, 22 June 2006 (UTC)

::::What about something easy for nonprogrammers like a BASIC language? [[User:Jaxad0127|Jaxad0127]] 20:33, 22 June 2006 (UTC)

:::::For reader simplicity, I'd vote Python over Basic... but then, I'm vested :-). <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 20:37, 22 June 2006 (UTC)

::::::True, but BASIC is more verbose than Python. [[User:Jaxad0127|Jaxad0127]] 20:41, 22 June 2006 (UTC)

::::What about XSLT? It's regular enough that it doesn't need a super-complex parser (we can ignore all the edges of XML for the example, e.g. whitespace normalization rules).  But it's special enough to have meaningful syntax to highlight. Of course, as PLs go, it's a heck of a lot less ''readable'' than are Algol-family languages. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 20:35, 22 June 2006 (UTC)

:::::I think I'd prefer Python. It's likely to be much less confusing to lay readers than something like XSLT. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 21:38, 22 June 2006 (UTC)

[[Image:Python_add5_parse.png|thumb|right|392px|Parse tree of mk_dot.py with inline syntax highlighted code]]

Here's a quick example that I just whipped up, using Python's parser module to produce an AST for a simple function (hooray for REPLs). This could easily be turned into a diagram of the sort that k.lee suggested:
<pre>
 import parser
 ast = parser.suite("def add5(x): return x+5")
 listast = parser.ast2list(ast)
 ... elided function def to map integer AST codes to symbol names ...
 ['file_input', 
   ['stmt', 
     ['compound_stmt', 
       ['funcdef', 
         ['NAME', 'def'], 
         ['NAME', 'add5'], 
         ['parameters', 
           ['LPAR', '('], 
           ['varargslist', 
             ['fpdef', 
             ['NAME', 'x']]], 
           ['RPAR', ')']], 
         ['COLON', ':'], 
         ['suite', 
           ['simple_stmt', 
             ['small_stmt', 
               ['flow_stmt', 
                 ['return_stmt', 
                   ['NAME', 'return'], 
                   ['testlist', ['test', ['and_test', ['not_test', ['comparison', ['expr', ['xor_expr', ['and_expr', ['shift_expr', 
                     ['arith_expr', 
                        ['term', ['factor', ['power', ['atom', ['NAME', 'x']]]]], 
                        ['PLUS', '+'], 
                        ['term', ['factor', ['power', ['atom', ['NUMBER', '5']]]]]]]]]]]]]]]]]], 
     ['NEWLINE', '']]]]]], 
   ['ENDMARKER', '']]
</pre>
Obviously, the parse tree might need to be simplified some for a graphical depiction (for example, the whole nested "testlist" could probably be reduced to just the relevant arithmetic expression tokens). --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 22:16, 22 June 2006 (UTC)

As for tokenization:

 >>> open('add5.py','w').write('def add5(x): return x+5')
 >>> d = open('add5.py')
 >>> tokenize.tokenize(d.readline)
 1,0-1,3:        NAME    'def'
 1,4-1,8:        NAME    'add5'
 1,8-1,9:        OP      '('
 1,9-1,10:       NAME    'x'
 1,10-1,11:      OP      ')'
 1,11-1,12:      OP      ':'
 1,13-1,19:      NAME    'return'
 1,20-1,21:      NAME    'x'
 1,21-1,22:      OP      '+'
 1,22-1,23:      NUMBER  '5'
 2,0-2,0:        ENDMARKER       ''

If other editors are happy with the example and language, I can work up graphs and syntax highlights later tonight. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 22:28, 22 June 2006 (UTC)

=== Parse tree image ===
I worked up a parse tree image of Allan's code.  Actually, I wrote a utility to generate a [[DOT language]] representation of an arbitrary Python program.  But the image I put above is actually a slight manual simplificaton of the actual parse tree.  Does the image seem usable? I can tweak options like fonts and layout style.  For example, there's a wild looking "energy minimized" layout; but the top-down hierarchical seems more usual.

''Later:'' Since there was so much whitespace in the parse tree image, I stuck syntax highlighted code in the middle of it, including highlighting the part that's actually parsed.  As a little self-referential joke, the code I put around it was the actual utility used to generate the parse tree.

Anyway, the code to generate the graphics is below.  Btw. Allan: where did you get the symbol names for your parse tree.  I found that <code>symbol.sym_name</code> had ''some'' but not ''all'' the names, so I had to improvise by copying from your output.

 # mk_dot.py
 import parser, symbol, sys
 symbol.sym_name[0] = 'ENDMARKER'
 symbol.sym_name[1] = 'NAME'
 symbol.sym_name[2] = 'NUMBER'
 symbol.sym_name[4] = 'NEWLINE'
 symbol.sym_name[5] = 'INDENT'
 symbol.sym_name[6] = 'END'
 symbol.sym_name[7] = 'LPAR'
 symbol.sym_name[8] = 'RPAR'
 symbol.sym_name[11] = 'COLON'
 symbol.sym_name[14] = 'PLUS'
 N = 0
 def getNodename():
     global N
     N += 1
     return 'node%s' % N
 def dotwrite(ast):
     nodename = getNodename()    
     label= symbol.sym_name.get(int(ast[0]), ast[0])
     print '    %s [label="%s' % (nodename, label),
     if isinstance(ast[1], str):
         if ast[1].strip():
             print '= %s"];' % ast[1]
         else:
             print '"]'
     else:
         print '"];'
         children = []
         for n, child in enumerate(ast[1:]):
             children.append(dotwrite(child))
         print '    %s -> {' % nodename,
         for name in children:
             print '%s' % name,
         print '};'
     return nodename 
 if __name__=='__main__':
     ast = parser.suite(sys.stdin.read())
     l_ast = parser.ast2list(ast)
     print 'digraph L0 {'
     print '    size = "8,8";'
     print '    ordering=out;'
     print '    node [shape = box];'
     dotwrite(l_ast)
     print '}'

The tokenization is simple enough I'd just do it by had.  Well, it wouldn't be tough to write a similar DOT output utility. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 01:21, 24 June 2006 (UTC)

:The other symbols come from the <code>tok_name</code> dictionary in the <code>token</code> module. Sorry should have made that clear before. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 19:18, 25 June 2006 (UTC)

== Practice section good ==

The new practice section and placing the specification and implementation subsections there is very good.  [[User:Ideogram|Ideogram]] 02:58, 23 June 2006 (UTC)

== [[Natural language processing]] ==

I'm skeptical about this addition.  At the least, it needs to be sourced.  There's a big gap between ''understanding'' natural language, and ''writing programs'' in it.  My own feeling is that no matter how good NLP parsers might get in the future, ordinary speech simply does not have the built-in disambiguation or precise concepts to express most algorithms.  Even if a machine could pass the Turing test, that doesn't mean you could ask it to carry out an exact program without resorting to describing it in a special-purpose artificial language.

Much is the same with mathematics, which is thousands of years older than programming languages are.  Math has developed specialized vocubularies and symbologies to discuss the areas of concern to mathematicians.  Even when mathematics is discussed vocally, mathematicians use special words outside of "normal" natural language, and often combine those words in ways that do not precisely follow the grammatical conventions of natural language. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 20:20, 23 June 2006 (UTC)

:Most every technical discipline has terms and grammatical forms that specialize the meaning of the corresponding natural language constructs in order to improve precision of expression. Outside of math, "legalese" is an obvious example of this kind of thing (and yet it's ''still'' subject to interpretation). --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 20:31, 23 June 2006 (UTC)

::True.  Legal language, however, is mostly about special words or special senses of words, and not so much about changes in grammar.  Of course, legal documents might seem like somewhat ''contorted'' grammar compared to many documents: but basically you can parse the noun clauses, predicates, paratactic modifiers, etc. in the same way you would ordinary speech. Math is "more special" in this regard. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 20:36, 23 June 2006 (UTC)

:::Why is math so special? You can just as easily parse a mathematical equation. And describe math in natural language, just like legalesse or any other specialized grammer. [[User:Jaxad0127|Jaxad0127]] 20:51, 23 June 2006 (UTC)

::::Really?! Try saying this in English:

::::<math>\Sigma = \begin{bmatrix}
\begin{matrix}0 & \lambda_1\\ -\lambda_1 & 0\end{matrix} &  0 & \cdots & 0 \\
0 & \begin{matrix}0 & \lambda_2\\ -\lambda_2 & 0\end{matrix} &  & 0 \\
\vdots &  & \ddots & \vdots \\
0 & 0 & \cdots & \begin{matrix}0 & \lambda_r\\ -\lambda_r & 0\end{matrix}
\end{bmatrix}</math>

::::To me it sounds a lot less like natural language than does anything I ever read in a contract or court opinion.   And that's not really the most "obscure" or technical thing I could come up with, just something I semi-randomly grabbed from another article. YMMV. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 21:00, 23 June 2006 (UTC)

::::: The ''r''-fold direct sum of the matrix representation of the complex numbers &lambda;<sub>''k''</sub>i? [[User:Dysprosia|Dysprosia]] 07:55, 26 June 2006 (UTC)

:::Oh, I wasn't disputing your point. In fact I completely agree with you. The fact that things like legalese exist is evidence that pure natural language is insufficiently precise for saying anything that needs to avoid ambiguity. I have no doubt that its possible to develop programming languages that "feel" more like natural language, but I believe that those languages will inevitably still have specialized terms and grammatical forms. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 21:01, 23 June 2006 (UTC)

::::My intent in adding the sentence was very limited, and I expressed it badly, giving the impression of a stronger claim than I intended, which is why I didn't expect any objection.  I apologize.  The limitation that computers cannot execute instructions in natural language is not known to be essential.  In the past, some researchers naively expected to be able to program computers to understand natural langauage, thereby removing specialized computer languages to a very specialized and behind-the-scenes roll.  COBOL was actually touted as a first step in this regard.  I don't expect to ever see a computer that can carry out nearly-arbitrary instructions in standard English, but I've been wrong before.   I'll see if I can find an appropriately-cited remark to insert.  In the meantime, I prefer the article without the ugly {{tl|fact}} template, and so approve of deleting the sentence. 

::::But, as to Lulu's point, consider a machine that can pass the Turing test.  By hypothesis, if we pass a response to both it and to a human, we must not be able to reliably distingush the two.  We pass a set of instructions for an action within the terms of the test: if the natural response of a qualified human would be to carry them out, and the machine fails to do so, we can distinguish, in violation of hypothesis.  If the machine carries them out, we have eliminated the need for a specialized language, except insofar as it is needed to construct the machine.

:::::But I don't believe that I could communicate most algorithms to Robert A West without using a specialized artificial language.  Not with specificity.  And that despite the fact that I tend to believe that Robert is made of cells and bones rather than of transisters and chassis. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 21:46, 23 June 2006 (UTC)

::::Now we get to the part that I didn't mention, because I felt a citation would be needed, there is a problem (considered in science fiction, see Asimov and Niven for examples) when the instructions are ambiguous, as they often are in the real world.  By the fact that it can pass the Turing Test, the machine should make the same types of mistakes, with the same probability, as a human possessing similar information about context.  If we want the machine to make no mistakes, we must use a specialized language and make no mistakes ourselves.  If we are content to permit mistakes, an AI will do.

::::All this must have been said by someone qualified to say it (or do you consider Asimov and Niven qualfied?) -- and a nod, as Lulu says below, would seem worthwhile.  I won't have time this weekend -- real life intrudes -- but I'll see what I can do. [[User:Robert A West|Robert A.West]] ([[User talk:Robert A West|Talk]]) 21:14, 23 June 2006 (UTC)

::::As for mathematics, it was expressed in natural language for centuries.  Remember back to reading [[Apollonius of Perga]] or [[Nicomachus of Gerasa]].  It makes my head hurt, but it can be done.  [[User:Robert A West|Robert A.West]] ([[User talk:Robert A West|Talk]]) 21:20, 23 June 2006 (UTC)

:::::Oh, damn!  The whole thing was in five paragraphs down!  Now I feel like an idiot. [[User:Robert A West|Robert A.West]] ([[User talk:Robert A West|Talk]]) 21:28, 23 June 2006 (UTC)

::::::I like Gazpacho's rephrasing of the concept better.  Not just because it's presented mainly in the negative, but the expression seems clearer too.  And s/he added some nice footnotes even, which enhances the article. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 21:42, 23 June 2006 (UTC)

:::::::No argument.  [[User:Robert A West|Robert A.West]] ([[User talk:Robert A West|Talk]]) 22:11, 23 June 2006 (UTC)
=== [[Literate programming]] ===

Somewhat along the line of the NLP thing, I wonder if we should have a bit of a nod to literate programming here.  I think the idea that programming languages are, in fact, as much about communicating concepts among people as actual instructions to machines, is worth noting.  It's not entirely excluded from the existing text, but I think it's underplayed.  I'm not sure the literate programming itself is the main point: many languages emphasize readability, and good programs that aren't "LP" as such, still have clear and extensive comments.  Something like Python's ''doctest'' is interesting as what I find a better fulfillment of the original goals of LP.  But Java's Javadoc has some of this idea as well... or even Perl's POD.  Actually, there's "Literate Haskell" too, which is a funny creature. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 20:28, 23 June 2006 (UTC)

== picture ==

It looks good and is informative, but it's so ... ''big''.  Is this the simplest example you could come up with?  I think the size of it might intimidate a layman.

Maybe a step-by-step explanation, since it does pack a lot of information in.  [[User:Ideogram|Ideogram]] 03:18, 24 June 2006 (UTC)

:It's a pretty darn simple chunk of code (look at the highlighted bit in the inset code).  The BNF just has a lot of rules, so winds up "over parsing" (the quite small utility mk_dot.py winds up with something like a thousand nodes in the tree!... that's not my doing, it's what the Python parser does).  We could perhaps prune it a bit more—I actually simplified it already: I can't see any harm to the concept if we pretend the parse tree is simpler than it actually is, as long as it is a possible BNF grammar (of a simpler language).  Try it out yourself, see if something seems better.  You'll need a Python interpreter; the utility I provide in full; and a DOT renderer like Graphviz. 

:Oh, small note: I just looked at the graphic on a different computer.  On my MacBook Pro, the color highlight around the 'add5()' function is almost too much contrast.  But on my desktop machine, I can't even see the highlight at all (I can if I manually increase gamma on the image).  Weird.  In any case, the parse tree is of the one-line add5() function. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 03:44, 24 June 2006 (UTC)

::Uhm, I've never used Python or Graphviz, and I'm not really motivated to start right now.  I just want to throw peanut shells at you :-).  [[User:Ideogram|Ideogram]] 03:56, 24 June 2006 (UTC)

:::Both are really cool though.  Not that you'd have to do anything much special though: the little utility I give above just take Python code on STDIN, and outputs DOT graphics on STDOUT.  It's already programmed.  You do need a DOT renderer; but at least the OSX Graphviz version I use is a regular GUI app: just open a .dot file, and it renders.  You can select other options using a property sheet (such as what logic to use in arranging nodes).

:::The really cool thing about DOT is that it's an ultra-high level description of a graph (that's also simple text that's easy to generate programmatically).  Rather than needing to give some exact coordinates and sizes of everything, you just say what's connected to what, and the engine figures out how to render it (with various options to tell it to use different techniques.  E.g. http://www.graphviz.org/Gallery/undirected/process.html:

 graph G {
    run -- intr;
    intr -- runbl;
    runbl -- run;
    run -- kernel;
    kernel -- zombie;
    kernel -- sleep;
    kernel -- runmem;
    sleep -- swap;
    swap -- runswap;
    runswap -- new;
    runswap -- runmem;
    new -- runmem;
    sleep -- runmem;
 }

:::It definitely appeals to the programmer in me. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 04:17, 24 June 2006 (UTC)

::::This could be very useful for a visual programming tool.  [[User:Ideogram|Ideogram]] 04:21, 24 June 2006 (UTC)

Actually, if anyone gets the crazy idea of actually trying to map the interrelationships of the PLs mentioned in the article (as Allan suggested as a possible picture), the example here could be a good starting point: http://www.graphviz.org/Gallery/directed/crazy.html (or more plainly: http://www.graphviz.org/Gallery/directed/unix.html).  That's not of PLs, but Unix versions, but the idea and graph type are similar.  Moreover, being a textual description of the relations, it's almost laughably easy to add or remove languages, or change relationships.  The source text of the graph can be posted for discussion and joint editing (someone needs to render it, but that's simple). <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 04:26, 24 June 2006 (UTC)

Thanks for your hard work.  My high-level comments on the picture are as follows:
#It depicts the Concrete Syntax Tree (CST), not the Abstract Syntax Tree (AST) with nodes for intermediate productions removed.  Personally I think the AST is more likely to convey the point to a lay reader.
#It depicts not only the syntax tree of the add5 function, but also the whole parser.
Either or both of these might be appropriate in the parser article, but IMO it's too much detail for this article.  My recommendations would be to make the figure depict just the add5 function and the resulting AST.  (Also, while I'm wishing, the token stream would be nice too.)  [[User:K.lee|k.lee]] 02:44, 25 June 2006 (UTC)

:I'm afraid I actually don't understand what you mean.  FWIW, what I provide actually ''is'' simplified from the actual parser output.  Are you saying you'd like all the intermediate productions removed, but the rest kept (with the same names, etc.).  I imagine that's doable, but I'd like to be clear on the goal.  I agree it's sort of shockingly much detail for such a simple function (I was surprised myself, having not really played with the Python parser before): when I write parsers, I tend to get fancy with the regexen, and have fewer productions as a result (which isn't necessarily free of its own drawbacks).

:Does anyone know if there's a way to generate an AST for a Python program?  The tokenization is much simpler.  I give it above, and we could inset that in the same graphic, I imagine.  Of course, all of this is niggly work.  DOT is great, but even given that, you have to make some decisions on export formats, and choose sizes, figure out how to preserve anti-aliasing, massage the graphic a bit in a raster editor, etc.  I'm willing to go through some steps to make something different, but I'd rather avoid doing it a lot of times, given the need for manual effort (my script automates some stuff, but it's a first brush). <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 03:04, 25 June 2006 (UTC)

::Er... the tree in question ''is'' for just the add5 function. And it ''is'' the AST (at least the Python docs refer to the output of the parser module as an AST). I agree that it could stand some simplification (although LotLE has apparently done some). But that will require producing a diagram that isn't "real". Perhaps a language other than Python would be a better choice? --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 19:28, 25 June 2006 (UTC)

:::I don't see any harm in using a "not real" parse tree for the illustration.  Python doesn't guarantee the exact same BNF productions between versions (I don't know, for example, if IronPython or Jython are compatible at this level, even though they should run the same example program fine).  But the distinction between AST and CST seems a bit fuzzy to me; and indeed, the parser module describes the complicated version as an AST.

:::I ''did'' start working on a utility to remove all the single chains of productions from the DOT files.  That is, if a production node points to exactly one other node, remove it and "promote" the target.  However, the thing I did last night produces a weirdly random graph: I have some logic bug to resolve in my pruning algorithm.  But I should be able to produce a "minimal production" version of any given parse pretty soon. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 19:43, 25 June 2006 (UTC)

::::Sounds good to me (although it might be worth noting somewhere that the AST is for illustration purposes only, rather than a "real" Python AST). Thanks for all of your work on this! --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 20:06, 25 June 2006 (UTC)

=== Simplified ===

[[Image:Add5t.png|thumb|right|250px|Tokenization of add5() function]]
[[Image:Add5b.png|thumb|right|250px|Parse tree with pruned intermediate productions of add5()]]
[[Image:Add5.png|thumb|right|250px|Raw CST of add5() function]]
Sorry, I wasn't clear.  First, the inset depicts the code to invoke the Python parser.  This isn't necessary.  The point is to illustrate a piece of code and its syntax tree, not the Python parser API.  The inset should just have add5.  Second, the Python docs may call the result an AST, but it's much more like a CST in the [[Compilers: Principles, Techniques, and Tools|Dragon Book]] sense (although admittedly the distinction between a CST and an AST does not have a precise technical definition).  To make the tree more AST-like I would:

:I added the extra code inset to illustrate syntax highlighting, as was suggested above.  The fact the code hightlighted happens to be the same as used to generate the parse tree is just one of those recursive jokes.  However, the one-line suite of 'add5()' seemed too short to illustrate syntax highlighting.  If there's some other bit of "famous" or "notable" source code, we could highlight that, I just like self-reference.

:Anyway, here's two more things for discussion.  The one is the actual complete parse tree as generated by Python's parser module (more CST-like, I recognize).  The second is the minimized version that I generate by automatically removing single-linked intermediate productions.  It still includes some terminals like parens that you may consider superfluous, but I like the idea of having a moderately robust looking tree. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 23:44, 25 June 2006 (UTC)

::I think this minimized version is good enough.  Let's put it in.  [[User:Ideogram|Ideogram]] 23:59, 25 June 2006 (UTC)

::Agree.  However, I think that we should demonstrate syntax highlighting in a separate figure somewhere higher up in the article.  It's fine (actually, sort of cool) if the syntax highlighted code example is also the code that generates the parse tree shown in the later figure.  I just don't want this one figure to be too crowded.  [[User:K.lee|k.lee]] 22:22, 26 June 2006 (UTC)

*remove at least the following intermediate productions: compound_stmt, stmt, simple_stmt, small_stmt, flow_stmt, varargslist, fpdef, testlist, term, factor, power, and atom.
*remove the following terminals: NAME = def, NEWLINE, INDENT, ENDMARKER, COLON = :, LPAR = (, RPAR = ), END, and NAME = return.
Basically, if I were building the figure, I'd make the parse tree look something like this:
 file -- function --+-- name=add5
                    +-- params -- formal_name=x
                    +-- body -- return_stmt -- binary_op --+-- op_name=PLUS
                                                           +-- variable=x
                                                           +-- numeric_literal=5
This communicates roughly the same point, but with less complexity.  If you were explaining ASTs in an introductory PL course, this is roughly what you'd show students.

Lastly, I agree that it doesn't matter whether the parse tree is the one that some particular Python parser implementation generates.  As long as the result corresponds to the tree that some sensible parser would generate, it seems be OK.  There is no such thing as the "real" Python AST, since the language definition does not specify how implementations may represent the program internally (nor should it).

Anyway, these are just my suggestions.  I don't have time to build an alternate figure, so do as you will. [[User:K.lee|k.lee]] 20:11, 25 June 2006 (UTC)

:I meant "real" in the sense that the AST (or CST) is actually something generated by an existing Python interpreter or compiler. I'm fine with using a a notional AST of some kind. I just think it needs to be clear that the AST in question ''is'' notional, and created specifically for the article: the reader will not be able to recreate the AST in a Python interpreter. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 21:49, 25 June 2006 (UTC)

::It seems I spoke too soon. Although I haven't played with it, it seems likely that [http://docs.python.org/lib/module-compiler.ast.html this module] might provide a way to get a Python AST that is more abstract than the so-called ASTs produced by the parser module. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 22:00, 25 June 2006 (UTC)
{{talkarchive}}

== Charity ==

I notice that an anon editor keeps removing references to the [[Charity programming language]] from the article, claiming that Charity is obscure. I'm not particularly wedded to using Charity as an example, if someone can come up with a better one. HTML is not a better example, since it is not a computational language

: I don't understand the problem with HTML not being a computational language (whatever that might be).  There are lots of people who believe that HTML is a language.  Charity is well known in programming language circles?  I think not.  [[User:67.62.122.162|67.62.122.162]] 20:16, 28 June 2006 (UTC)

::The problem with HTML is that not only is it not Turing complete, it can't be used to compute ''anything''. Even the toy languages provided as introductory examples in PL texts can do simple arithmetic evaluations. Regular expression languages can do string processing. HTML simply provides structural markup (hence the name Hyper-Text ''Markup'' Language). What we're looking for is an example of a language that is commonly referred to as a "programming language" (which eliminates things like regexps), even though it doesn't provide Turing completeness. As I have already said, I happy to use an example other than Charity, if you can come up with one. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 21:25, 28 June 2006 (UTC)

it defines structure rather than computation. OTOH, Charity is (at least in programming language circles) one of the better-known examples of a non-Turing-complete general purpose language. For an example, see [http://www.accesscom.com/~darius/ Darius Bacon's] comment in [http://lambda-the-ultimate.org/classic/message12481.html this thread] on Turing-completeness at the [[Lambda the Ultimate]] programming language weblog. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 02:44, 26 June 2006 (UTC)

:What about office suite macros? [[User:Jaxad0127|Jaxad0127]] 03:35, 26 June 2006 (UTC)

::VBscript is a pretty crappy language, but it's a Turing-complete one.  Same is true for most other macro languages: I remember way back writing WP5.1 macros which was cumbersome, but technically had the usual loop/conditional/storage constructs. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 05:09, 26 June 2006 (UTC)

:::What uses VBScript? MS Office uses VBA. Batch files? [[User:Jaxad0127|Jaxad0127]] 05:39, 26 June 2006 (UTC)

::::I think it's exactly the same thing, modulo a little bit of marketing-speak.  I may have the sequence wrong, but I think MS originally called VBA "VBscript", then decided to use the VBA name later.  In any case, not quite as ancient as my WP 5.1 macro days, I also once wrote some VBA scripts to process some Excel sheets... and it definitely had the minimal statements necessary to implement a Turing machine (in a way just barely less ugly than the "Turing-machine in sed" link Allan found). 
::::In any case, Charity is a perfectly good example.  It's definitely not in widespread use, but as an academic exercise it is well understood.  It's not that a lot of Charity programmers are wondering what Charity is, it's just a clear case of something that almost anyone would call a programming language, while formally having less power than Turing-complete. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 07:41, 26 June 2006 (UTC)
:::::For reference, VBA was the original name, dating back to (I think) Excel 3.  VBscript is the name of the reimplementation used by [[Internet Explorer]] and [[Windows Scripting Host]].  As I understand it, they are pretty similar to each other. [[User:JulesH|JulesH]] 13:42, 3 July 2006 (UTC)

: An example is an example is an example -- just because it is obscure doesn't make it any less of an example. [[User:Dysprosia|Dysprosia]] 07:49, 26 June 2006 (UTC)

== [[Plankalkül]] ==
A major flaw - the article does not even mention the first programming language!  [[Konrad Zuse]]'s [[Z3]] (1941), the first functional program-controlled computer, used [[Machine code|machine language programs]]. But just a few years later, between 1943 and 1945, Zuse designed the first high-level programming language [[Plankalkül]]. Even today notes survive with scribblings about such a plan calculation dating back to 1941.  By 1946 Zuse had written a book on the subject but this remained unpublished. Heinz Rutishauser, one of the founders of [[ALGOL]], wrote: "The very first attempt to devise an algorithmic language was undertaken in 1948 by K. Zuse. His notation was quite general, but the proposal never attained the consideration it deserved." [[User:Science History|Science History]] 11:57, 19 July 2007 (UTC)

:It is not appropriate to mention Plankalkul in the article.  It was an interesting effort that was never used, and had little if any direct influence on later languages.  It's always possible to find some neat lesser known pioneer, and do a bit of hagiography around him/her.  But this amounts to a footnote at most, and not really one for this particular article.  Probably in something like "List of Programming Languages", maybe some other specialized articles. 

:I saw the same editor had previously added quite a bit of this hagiography of Zuse in this artilce (and I think a couple others).  While Zuse was indeed an interesting guy, the point of an article isn't to "discover" the underemphasized significance of favorite figures. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 21:47, 19 July 2007 (UTC)

::Well, are you able to find "some neat lesser known pioneer" who designed a programming language prior to Zuse? Then tell us about him. The section is about the history of programming languages. How could you possibly justify the omission of the very first documented design of a programming language?  Could any decent history article about the discovery of America  ignore those who discovered it before Columbus did?  [[User:Science History|Science History]] 14:29, 30 July 2007 (UTC)

==FORTRAN==
I have always seen FORTRAN-77 listed among Turing-complete languages, and the article on [[Turing completeness]] lists it as complete.  Can we have a source that the conventional wisdom is mistaken? [[User:Robert A West|Robert A.West]] ([[User talk:Robert A West|Talk]]) 01:42, 27 June 2006 (UTC)

:FORTRAN-'''77''' (and earlier versions) had neither recursion nor dynamic memory allocation; as the [[Fortran]] article says, it was a big deal when these were added to FORTRAN-90.  There can be at most one activation of any given procedure on the stack at a time in FORTRAN-77; all scalar values occupy a predefined number of "storage units" (1 unit for integers and reals, 2 units for double-precision reals, etc.); and all compound data values (e.g., arrays) must have statically defined bounds.  Therefore, any given FORTRAN-77 program is finite-state, unless you include I/O (which, IMO, does not count; if you include I/O, then any other non-Turing language at least as expressive as FSMs, including presumably [[Charity programming language|Charity]], can also be Turing-complete).  There is, in short, no way to express the following program in FORTRAN, without using the I/O backdoor:
 fun f(x) = let y = 1::x in f(y);
 f(nil)
:I believe that these facts are common knowledge among compiler writers, so I am having trouble finding a reference (other than the FORTRAN-77 standard, but I assume you want a more concise reference addressing exactly this issue).  If you think I/O is sufficient to call FORTRAN-77 Turing-complete (some people do, I admit; it ''is'' included in the language definition) then feel free to revert.  It would be nice, though, to find a nontrivial programming language that is better-known than Charity and yet not Turing-complete. [[User:K.lee|k.lee]] 06:52, 27 June 2006 (UTC)

::I was somewhat wondering what you meant too.  I figured you were assuming READ TAPE was omitted from the meaning of FORTRAN-77, which is somewhat reasonable, since a machine might not have a tape drive (or equivalent).  I sort of like the example, but we can't rely on "widely known" or "common sense".  To use the example, I think we really need to cite someone else who specifically observes what you do.

::For that matter, by somewhat similar reasoning (that I've given on the talk page archives), C is also not Turing-complete unless you count I/O (i.e. fixed, finite pointer size). <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 07:03, 27 June 2006 (UTC)

:::OK, fair enough.  I'm not going to argue this point further.
:::BTW, this has nothing to do with anything, but my reading of the C standard says that the amount of space that a pointer takes up when stored in an object must be statically fixed and finite, but it says nothing about how the hardware must interpret these bit patterns.  Therefore, although there are a ''finite number of live pointer values'' in a program at any given time, there is no particular reason that the hardware for a conformant C implementation could not keep a table mapping each live pointer bit pattern to a bignum.  (There are only k possible bit patterns and an infinite number of bignums, but who cares, as long as there are never more than k pointer values live at once?)  To construct a Turing machine, define a function that calls itself recursively when it needs more tape, and use a single static pointer for the tape head.  To move left and right on the tape, use pointer arithmetic to move the head between stack frames; this is not guaranteed to be defined, but it is also not prohibited, so an implementation that supports it is still technically standards-conforming. [[User:K.lee|k.lee]] 08:45, 27 June 2006 (UTC)
::::Bah.  Right after I wrote the above, I realized that you could probably make FORTRAN integers hold bignums via the same trick. [[User:K.lee|k.lee]] 08:59, 27 June 2006 (UTC)

:::::C doesn't have unbounded integers in the language spec, does it?! If you have an unbounded integer, you only need two of those to implement a Turing machine: One to represent the "tape", and one to represent the pointer.  Say you have an m-symbol alphabet, consider the "tape-number" to hold one tape position per base-M digit.  Since the "tape" can be indefinitely long, you might need more than a bounded 32-bit (or 128-bit, etc) number to point to the right position.  Anyway, operations on the Turing machine can just be changes to the value of "tape-number".  However, I really don't think C has an inherent type of "unbounded integer" (you need something like the GNU MP library, I think).  Finite pointers to finite data types gets you a (really big) FSM, but not a TM.
:::::In any case, for whatever language, our own analysis in [[WP:OR]].  I don't think it needs a really fancy source, just ''someone'' outside WP who makes the point.  That was the advantage of Charity.  It's own website make the computational power issue direct and straightforward.  We don't have to rely on our own analysis of what the language does. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 16:40, 27 June 2006 (UTC)

::Well, I never thought Postscript was Turing-complete either, but I am really rusty on the subject.  At minimum, there should not be a contradiction between Wikipedia articles.  It has been a long time since I used FORTRAN II, but I seem to recall that the language definition did not require that the same unit be usable for both input and output.  Would that rescue the example? [[User:Robert A West|Robert A.West]] ([[User talk:Robert A West|Talk]]) 12:46, 27 June 2006 (UTC)

:::Take it or leave it, but I almost never ''failed'' to hear the mantra "Postscript is Turing complete".  It feels like a commonplace to me. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 16:41, 27 June 2006 (UTC)

::::I seem to recall reading that the Turing-completeness of Postscript was demonstrated only after the language had been in use for some years.  Perhaps I am remembering wrongly?  Not that it really matters -- the expressive power of Postcript is not in dispute.  I'll see if I can find some authority on the Turing-completeness, or lack thereof, of FORTRAN II, or possibly COBOL.  At least those languages were widely used.  [[User:Robert A West|Robert A.West]] ([[User talk:Robert A West|Talk]]) 22:04, 28 June 2006 (UTC)

It seems that the [http://www.macs.hw.ac.uk/~greg/hume/ Hume] language - at least the levels below "full" Hume - are not Turing-complete. But Hume is probably even more obscure than Charity. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 21:56, 28 June 2006 (UTC)

== float right images bad ==

The float right images were overlying the code box and that looked bad.  I made an attempt to fix it, but I think what we really want is two columns with images that stretch to fit whatever size the browser window is.  Does anyone know how to do this?  [[User:Ideogram|Ideogram]] 19:55, 27 June 2006 (UTC)

:Aliasing.  I find that sizing image as an integer ratio reduction of the originals, where reasonable for an article, tends to produce better rendering of line-art.  Continuous tone images like photos tend to respond to various sizes better.  So I sized the two images I recently put in at exactly 1/2 their original size, rather than some complex ratio; this seems like OK sizes for WP articles (the originals are around 600-800 pixel width). <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 20:11, 27 June 2006 (UTC)

::You mean you don't have SVG output?  [[User:Ideogram|Ideogram]] 20:14, 27 June 2006 (UTC)

:::Of course I do.  But many readers will not be able to render SVG, so providing PNG images is better.  If you want SVG versions of the iamges... well, actually, I don't have the touched up ones.  I added the captions and inset the tokenization using a bitmap editor.  But I am happy to upload the SVG of the parse tree and tokenization if you feel you have a need for them. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font>

::::I didn't realize that was an issue.  I'll leave it up to you.  [[User:Ideogram|Ideogram]] 20:28, 27 June 2006 (UTC)

I am concerned with the most common browser window sizes.  1280 and 1024 are fine. 800 is ok except there are some orphans in the text.  640 is bad but maybe we don't have to worry about that.  [[User:Ideogram|Ideogram]] 20:14, 27 June 2006 (UTC)

:The parser tree is a little wider than I'd want, I think something like 390 pixels as reduced.  For the most part, I prefer images in articles not to exceed 300 pixels, or 350 tops.  However, reducing it further—either to 1/3 the original size, or to some non-simple ratio—just doesn't seem legible if you don't zoom in.  Still, even in a 640 width screen, the image will ''fit'' on screen, it will just make the text very narrow.  With 800x600 screens, it should be fine. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 20:21, 27 June 2006 (UTC)

::At 640 the image overlays some of the text for some reason.  The image is already too small to read at the current size; I think the thumb should just give the shape of the tree and assume the reader will click on it if they want to read the text.  [[User:Ideogram|Ideogram]]

:::You're not by chance using an archaic browser like IE, are you? In any case, 640x480 will cause difficulties in a lot of articles... we should ''not'' strive for causing difficulty, but neither should we primarily consider plain VGA nowadays. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 20:37, 27 June 2006 (UTC)

::::I'm using firefox.  I like to have two side-by-side windows on the screen; on my current (old) computer at 1280x1024 that gives a browser width of 640.  [[User:Ideogram|Ideogram]] 20:40, 27 June 2006 (UTC)

::::: Luxury ;-) On my phone, the screen is tiny (though pictures are shrunk too, so it amazingly still works). Luckily my Mac has 2560x1600 (though no doubt this will look small when people look back at this in the archive). So I have to adjust between 15 lines sigs and one line paragraphs. The idea with thumbnails is that you can set a user-default size so people can adjust their experience without affecting anyone else. [[User:Stephen B Streater|Stephen B Streater]] 20:45, 27 June 2006 (UTC)

::::::When I get my main machine back from the shop I will have two 2048x1536 screens.  Now ''that's'' what I'm talkin' 'bout.  [[User:Ideogram|Ideogram]] 20:49, 27 June 2006 (UTC)

::::::: Sounds good :-) I forgot to mention that with Safari, the code boxes were overwritten on the right hand side, but no actual code was unless I made the browser window very narrow - in which case the right hand image did overwrite the code text as you described with your Firefox browser. [[User:Stephen B Streater|Stephen B Streater]] 20:53, 27 June 2006 (UTC)

== separate tokenization box ==

I think we should take the tokenization box out of the parse tree image.  It is already too small to be readable.  [[User:Ideogram|Ideogram]] 20:30, 27 June 2006 (UTC)

:I disagree.  I don't want an article dominated by ''too many'' images, and an image that is mostly whitespace wastes space on the page.  It's true that you need to zoom in on the image to really read the tokenization.  But even at the condensed size, you can see the general form of it: namely just a tape of symbols.  The tokenization isn't exactly ''all that'' interesting in its details; but they aren't hard to see if you do click on the image to zoom in.  Of course, I've given editors all my working parts here on the talk... you can cut-and-paste as well as I can.  In fact, you even have all the source code used in the production process too.  So have at it. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 20:34, 27 June 2006 (UTC)

::The tokenization is pure text.  Making it an image isn't even necessary.  You can embed it in the text if you like.  [[User:Ideogram|Ideogram]] 20:37, 27 June 2006 (UTC)

:::Well, yeah... but it looks better like I did it. Just look earlier on this page to see you can also do the parser tree as text, if you really want. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 20:38, 27 June 2006 (UTC)

::::I don't really see the need to "fill up" the whitespace in the tree diagram.  But it's not that important to me so I'll leave it for now.  [[User:Ideogram|Ideogram]] 20:42, 27 June 2006 (UTC)

== Congrats ==

Congratulations on the work on this article. It is looking very good. Hope that editors can continue contributing to it and making it one that they can all feel proud about it, and while doing that having both fun and respect for each other's effort. I will keep an eye on this article and assist with any disputes that require a non-involved third-party. [[User:Jossi|≈ jossi ≈ ]] <small>[[User_talk:Jossi|t]] • [[Special:Emailuser/Jossi|@]]</small> 04:33, 28 June 2006 (UTC)

== citations ==

Lulu, what is with you and [[WP:POINT]]?  You really need to drop your prejudice about me.

As for the fact tags, it does take some effort to tag what needs a citation and it does help to have them in there so that people know what is needed and can contribute.  For FA status we need this level of citation, I've been trying to tell you that.  On other articles I've had success getting people to add citations by adding fact tags.  [[User:Ideogram|Ideogram]] 10:49, 28 June 2006 (UTC)

:There is no need to add {{tl|fact}} to each sentence. There is already a tag {{tl|citations missing}} at top. You can invite editors to find some citations for each segment, if there are any disputed statements. If some statements are not disputed, as these may be facts rather than  opinion, we do not need a specific citation.  [[User:Jossi|≈ jossi ≈ ]] <small>[[User_talk:Jossi|t]] &bull; [[Special:Emailuser/Jossi|@]]</small> 16:06, 28 June 2006 (UTC)

::I didn't add fact to every sentence.  I added it to sentences that I felt we could find citations for.  And if you try to get FA status the commentators will tell you to get citations for ''every'' fact in the article, not just the disputed ones.  [[User:Ideogram|Ideogram]] 16:38, 28 June 2006 (UTC)

Please use this talk page to indicate facts you feel need additional citational support.  If it were a matter of adding one or two at a time, it would be reasonable to try to address the questions.  But looking at dozens or hundreds of inappropriately used tags makes it impossible to discern which might cover genuine concerns, and which are plainly [[WP:POINT]].  In the large majority of cases, I cannot make heads nor tails of ''what'' about a sentence might be thought to need a citation, nor why.  A disruptive tag, bordering on vandalism, doesn't provide any such explanation... in fact, it makes it far less likely that any  ''actual'' issues will be addressed when their lost in the noise.  

We have been through this several times before, Ideogram.  I appreciate all your good work, but you and I both know perfectly well that 90%+ of these tags are utterly meaningless (and apparently some sort of ego thing on your part), and concern sentences for which a specific citation is neiter needed nor even desirable.  If I'm wrong (but I'm not), ''explain'' why here on this talk page, in sufficient detail to understand ''what'' it is you think needs citation.  If you honestly believe there is some dispute, e.g. about the fact that Fortran was developed in the 1950s, the burden on you is to explain why such a doubt about apparently undisputed material exists. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 17:28, 28 June 2006 (UTC)

:I don't know why you keep accusing me of WP:POINT.  You seem to have some kind of paranoia about it.  I never have, and never will, engage in WP:POINT.  Can we lay that to rest?

:I refer you again to [[User:Spangineer/inline citations]] for the need for citations.  I refer you to [[Wikipedia:Featured article candidates/Forth]] for a page that failed FAC for not enough citations.  Go ahead and read [[Forth (programming language)|Forth]] if you don't understand how many citations we need.

:Believe it or not, I usually know what I'm doing, and it's not WP:POINT.  Despite appearances, I did not "randomly" sprinkle fact tags throughout the article.  I spent significant effort thinking about every sentence to determine whether it was desirable and possible to find a citation for it.  It ''certainly'' took me more effort than it will to remove the tags if we determine we don't need them.

:I don't understand why I have to repeat this, but fact tags are not about disputes.  They are about providing backup for ''every'' fact in the article, because no matter how smart you think you are, you are not a real expert.  [[User:Ideogram|Ideogram]] 18:03, 28 June 2006 (UTC)

* Ideogram, I hate to be rude... but you have butted heads with '''several''' editors of this page now.  At least one of the editors whom you have butted heads with, appears to be the irascable, confrontational sort.  But several others, include LotLE, are not.  May I suggest that you may be taking personally things that you ought not get upset about?  LotLE is an expert in these matters, and he seems to be a quite reasonable fellow.

:Lulu can be irascible too.  Just ask him.  And he's not an expert, certainly not on FAC requirements.  As for butting heads, I do pick my battles carefully.  You just don't notice the battles I choose not to fight.  And I'm not taking anything personally.  I have patiently explained my reasoning several times, but if Lulu keeps accusing me of WP:POINT I may take ''that'' personally.  [[User:Ideogram|Ideogram]] 18:06, 28 June 2006 (UTC)

* Regarding FA criteria concerning citations.  My understanding (which could be wrong), is that all claims of a FA must be backed by appropriate references.  This doesn't, however, mean that every sentence in such an article should  have a &lt;ref> tag after the period; rather, it means that some source listed in the article should cover the topic at hand and provide evidence for the point.  Articles with zillions of footnotes are generally poor style and difficult to read.  Inline footnotes are best reserved for claims which are of key importance, or are surprising or controversial.  IMHO, the appropriate level of footnoting for an encyclopedia article should be similar to that which is found in an academic paper or a scientific textbook (perhaps moreso as we have to assume an audience with general knowledge), but not egregiously moreso.  Considering the case of Fortran; it's likely true that all relevant claims about Fortran can be attributed to a single source; there are likely several such sources to be found in [[Fortran]].  
* --[[User:EngineerScotty|EngineerScotty]] 17:50, 28 June 2006 (UTC)

:See the links I provided above for why this is not true.  [[User:Ideogram|Ideogram]] 18:06, 28 June 2006 (UTC)

*Talking procedurally, everything mentioned in Wikipedia should be cited. However placing a couple of references in every sentence will unnecessarily clutter the article. What I prefer is that references should be provided to all claims and any possible controversial statement (something that anyone can attempt to refute). However for most of the information present (whose source is necessary), I prefer {{tl|inotes}}. To the reader, they are invisible, and at the same time help editors in following up to the sources as well as fulfil the requirements of GFDL about attributing sources. Also, if anyone thinks the statement/information is controversial enough to warrent sources, while trying to add the {{tl|fact}}, s/he will notice the source and can convert to a reference. As an example, you may wish to see [[Indian Institutes of Technology]] article's "Education" section in edit mode, which I believe contains about a dozen inotes. In most the cases the decision of what to add as reference and what as an inote is largely arbitary and I have only provided my opinion. Also, I don't say that each and every sentence need to be cited in every way. Many things are no-brainer (like the capital city of a country, or specifically in this article's context like Fortran being a Programming Language), and need not be referenced in any way. &mdash; [[User:Ambuj.Saxena|Ambuj Saxena]] ([[User_talk:Ambuj.Saxena|talk]]) 06:25, 29 June 2006 (UTC)

:Please explain why [[Forth (programming language)|Forth]] did not have enough citations, even though there were no statements left that anyone could attempt to refute.  [[User:Ideogram|Ideogram]] 06:29, 29 June 2006 (UTC)

== can we stop editing while we resolve this dispute ==

The more work we do now the more work it will be later to put the fact tags back in if that is what we decide.  [[User:Ideogram|Ideogram]] 18:16, 28 June 2006 (UTC)

:A shotgun spray of dozens and dozens of {fact} tags are ''never'' going to become acceptable.  I am ''going to'' revert any such indiscriminate application on sight.  Adding these is extremely disruptive, and shows real bad faith.  

::How many times do I have to tell you it wasn't a shotgun spray?  And don't think you [[WP:OWN]] the article.  And you must assume good faith.  

:::Well, likewise.  In complete sincerity, I believe that ''every tag'' I removed was attached to a sentence that ''did not'' need any citation beyond those provided by the general resources listed at the bottom of the article.  If you disagree about a specific case, explain why on this talk page, explicitly and in relation to the particular sentence. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 22:16, 28 June 2006 (UTC)

::::I never accused you of bad faith.  I never accused you of WP:POINT.  I never said you "stomped your feet,"  Those comments are violations of Wikipedia policy.

::::We need a citation for every fact, at least one per paragraph.  That's what the FAC commentators are telling me, don't get mad at me, I'm just the messenger.  If you don't care about FAC status that's fine, but don't get in the way of those of us who do.  [[User:Ideogram|Ideogram]] 22:26, 28 June 2006 (UTC)

:::::I cannot believe you misunderstand the purpose of citations so badly.  In fact, I ''do not'' believe it.  Individual citations are not a quota thing.

::::::Why don't you argue with [[User:Spangineer]], [[User:Wackymacs]], and [[User:Ambuj.Saxena]], because that's what you're going to have to do to get FA status.  [[User:Ideogram|Ideogram]] 03:11, 29 June 2006 (UTC)

:::::You are not "the messenger", you are simply disrupting the article out of some sort of [[WP:POINT]] agenda, or to show off, or just to tilt and windmills for its own sake.

::::::I absolutely refuse to talk to you as long as you keep accusing me of WP:POINT.  [[User:Ideogram|Ideogram]] 03:11, 29 June 2006 (UTC)

:::::But in the meanwhile, you essentially destroyed the article by making it unusuable for readers.  It pisses me off for an editor to vindictively destroy an article I've worked pretty hard on.  I'd hope that the fact you've also worked hard on it to would make you not desire destruction... but I guess not.

::::::I absolutely refuse to talk to you as long as you are incapable of assuming good faith.  [[User:Ideogram|Ideogram]] 03:11, 29 June 2006 (UTC)

:::::You cannot achieve quality by doing a word count and quota count, and decide that a certain ratio means high quality.  As EngineerScotty put it (and I've repeated already): ''Inline footnotes are best reserved for claims which are of key importance, or are surprising or controversial.''  As near as I can tell, '''no single claim''' you added scattershod tags to was surprising, controversial or of key importance.  Or inasmuch as some may have been of key importance, they are perfectly well supported by the several general reference texts given as general source materials. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 03:02, 29 June 2006 (UTC)

:Feel free to add tags to one or two narrow and specific points at a time; and accompany it with specific discussion here on the talk page.  For example, recently Robert A West raised a very reasonable concern when FORTRAN-77 was added as an example of not-quite-Turing languages.  He added one tag to that specific claim, and it was productively discussed on this talk page.  That's what the tags are meant for.  Or better still, just add citations yourself, rather than stomp your feet about their need (in what is, quite frankly, going to continue to be a [[WP:POINT]] violation).

::You are failing to be civil.  This is really annoying.

:Still, it's never going to be appropriate or desirable to have footnotes on every sentence.  Most sentences are non-controversial, and are supported in a more general way by the broad sources provided in this article.  EngineerScotty characterized matters exactly right with: ''Inline footnotes are best reserved for claims which are of key importance, or are surprising or controversial.''  In other words, 90%+ of the places you put the tag aren't remotely relevant. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 18:33, 28 June 2006 (UTC)

::Lulu, if you don't care about FP ever becoming a FA, that's fine, I'm not going to fight you on that.  But I want PL to become a FA, and the citations are the largest chunk left to be done.  What do I have to do to convince you?  Did you even read any of the links I provided?  Read the article by Spangineer.  Read the Forth FAC discussion:  "One per subsection is sort of a minimum... ideally, there should be a citation for every fact, which might be around one per paragraph, maybe more."  Read the previous nomination for similar comments by [[User:Wackymacs]] and [[User:Spangineer]].

::You are not going to close out discussion on me.  I will do whatever it takes to get you to listen to me.  [[User:Ideogram|Ideogram]] 22:11, 28 June 2006 (UTC)

:::I think this article becoming FA would be good.  I am ''absolutely certain'' that your shotgun random disruption makes that goal ''much'' farther from being achieved, not closer.  The user space essay you mention looks fine, but it says nothing advocating misuse of tags to disrupt articles. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 22:18, 28 June 2006 (UTC)

::::Stop calling it random and a disruption.  That is your opinion and it shows a failure to assume good faith.  I have used this tagging process very successfully on [[Forth (programming language)|Forth]] and [[Scheme programming language]] to get people to add ''specific'' references where a general call for "more references" acheived nothing.  [[User:Ideogram|Ideogram]] 22:28, 28 June 2006 (UTC)

== Nice point about programs writing programs ==
I like that addition by EngineerScotty.  The main use of Postscript in machine-to-machine communication is piquant.  Actually, my whole effort above with drawing the diagrams was possibly an example of this.  Of course, DOT is not really a ''programming language'', but a "graph description language".  Nonetheless, I've seen people use DOT descriptions to schematically extract FSMs.  It's not hard to imagine an actual "DOT2FSM" compiler being written in the future... at such time, a syntactically identical language could go from being a "markup language" to being a "programming language".  Curious.  Maybe I'll write that.<font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 19:11, 28 June 2006 (UTC)

:Along those lines, you might be interested in taking a look at [http://www.ece.concordia.ca/~tahar/pub/CCECE04-FSM.pdf this paper]. It discusses the use of graphviz and the dot file format as a frontend for the development of FSMs that ultimately get translated into [[VHDL]]. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 20:06, 28 June 2006 (UTC)

::Oh well, someone beat me to it.  I was sort of contemplating using DOT as a higher level description of the semi-coroutine based Python state machine I present in some articles (and in my book).  My idea was that DOT might be something like an embedded language there.  My state machine framework is a little bit funny though: my states actually ''do something'' when they run; passing control to another state is just one option, they can also process for a while inside the state.  So it's sort of a hybrid between a FSM proper, and regular control branching.

::Since the compiler exists, does this mean that DOT is a programming language now? :-).  Btw. The paper seems incorrect to me: at least my OSX version of Graphviz just renders the DOT files, it doesn't ''output'' them.  Are other OS version more capable? (it's not hard to imagine one that allowed Visio-style drag-and-drop arrangement... but my version doesn't do that). <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 20:57, 28 June 2006 (UTC)

:::IIRC there's a tool that comes as part of the graphviz distribution that allows the editing of dot graphs. ''After a quick googling'': it's called [http://www.graphviz.org/cgi-bin/man?dotty dotty]. I don't see dotty (or the supporting lefty) anywhere inside Graphviz.app, so I guess it hasn't been made part of the Mac version. 

:::I suppose it could be argued that DOT is a PL. A non-turing-complete one at that :-) --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 21:14, 28 June 2006 (UTC)

Someone removed Postscript as an example, claiming that machine control is not programming.  I put it back, because:
* Postscript meets all definitions of a programming language
* Being emitted by machine does not disqualify something.  There are many translators and such which produce C or another "classical" programming langauge as an output, to further control a downstream subsystem--would anybody argue that C isn't a programming language for that reason?  
* In [[metaprogramming]], the whole ''point'' is for programs to write programs.
--[[User:EngineerScotty|EngineerScotty]] 21:07, 28 June 2006 (UTC)

== butting heads ==

BTW I don't recall butting heads with '''several''' editors.  And even if I had, it's hardly relevant to my point.  Comment on the content, not the contributor.  And I really can't understand what I said that makes you think I'm taking anything personally.  If anything, Lulu, by constantly accusing me of WP:POINT, is taking things much more personally than I am.  [[User:Ideogram|Ideogram]] 18:27, 28 June 2006 (UTC)

: Yes. Don't take things personally. I added lots of references to the [[FORscene]] article to get it through notability at AfD, but they were almost immediately moved to the list of external links to stop them cluttering up the article. I usually make one edit before moving to talk to find out more. This is a great opportunity to learn as well as to teach. [[User:Stephen B Streater|Stephen B Streater]] 19:09, 28 June 2006 (UTC)

== 67.62.122.162 ==

I invited {{user|67.62.122.162}} to participate in our discussion; characterizing his edits as "vandalism" is probably inappropriate.  (In Wikipedia parlance, "vandalism" is always used to refer to things like blanking articles or inserting profane comments about someone's mother into the middle of one; not to disputes over content).  It's good to [[WP:AGF]] until a good reason is found to do otherwise; 67.62 doesn't have a significant edit history here and may not be familiar with Wikipedia practice.  (Remember [[WP:BITE]]).  --[[User:EngineerScotty|EngineerScotty]] 21:20, 28 June 2006 (UTC)

:OK, I apologize for my bitiness.  But nonethless, the additions read like rants, and really need to be removed. I think maybe the citation can be added to the GOTO mention (in proper footnote style), but not the "streetcorner preacher" tone. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 21:33, 28 June 2006 (UTC)

:: I thought the edits were quiet reasoned and balanced, expressing things in a very non-judgemental fashion.  I may have been out of place in deleting the postscript sentence.  While a valid comment it is completely out of context in its current position.  ([[User:67.62.122.162|67.62.122.162]] 22:32, 28 June 2006 (UTC) in a coffee shop, I don't normally do this kind of thing).

:Btw, EngineerScotty, if you know {{user|67.62.122.162}}, maybe you can convince her/him to stop removing your own very nice addition about metaprogramming that both myself and Allan McInnes have explicitly expressed our pleasure with on this talk page.  Newcomer is one thing... but obnoxious is, well obnoxious. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 21:40, 28 June 2006 (UTC)

::I don't know him any more than I know any of the rest of you; I've discussed the matter on his talk page.  --[[User:EngineerScotty|EngineerScotty]] 21:42, 28 June 2006 (UTC)

The metaprogramming point is very interesting and relevant (and is discussed on the PL talk page).  Postscript is a good example, but it's not unique.  Postscript is a Turing complete language than some people indeed do write by hand.  But it's ''mostly'' written by machines.  In contrast DOT (which may or may not be a PL) is about half-and-half.  In producing the graphs on PL, I generated some of the DOT language sources using Python programs, and edited others by hand.  At the other extreme, I know many people who programmatically generate Lisp source code, or Python source code, or C source code ([[Pyrex]] is an interesting example of generating C based on a Python superset language); but clearly, those languages are ''usually'' written by humans directly. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 21:57, 28 June 2006 (UTC)
===Response to RFC===
I see no reason why not keep the sentence about Postscript and on machine programming another. [[User:Ανδρέας|<span style="color:white;background:#227">&nbsp;<span style="background:#338">&nbsp;<span style="background:#449">A<span style="background:#55a">n<span style="background:#66b">d<span style="background:#77c">r</span>e</span>a</span>s</span>&nbsp;</span>&nbsp;</span>]] <sup><font size="-2">[[User talk:Ανδρέας|(T)]]</font></sup> 22:41, 28 June 2006 (UTC)

== Regarding questions of definition ==

I'm sure this has been brought up before, but plenty of knowledgable people have argued for a long time about what does or does not constitute a programming language. It's not Wikipedia's job to resolve this question - different definitions should be examined, along with the people who hold them and the languages which do or do not qualify under such definitions. Cases that are borderline or controversial like Postscript should be described as such. But watch out for original research - if a case is borderline or controversial, just say it's a programming language "according to verifiable source X, who uses definition Y" rather than "because it does Y which is ''the'' definition of a programming language". [[User:Deco|Deco]] 22:40, 28 June 2006 (UTC)

== Tags used for disruption ==

On this talk page, I saw Ideogram make the claim that adding a ton of {fact} tags "worked" on the [[Forth (programming language)|Forth]] article to bring it to Featured Article status.  Of course, that article is not an FA, but more generously lets just assume the goal is improvement of that article, which genuinely is better than it was a month ago.

I was pretty certain that had Ideogram (or any editor) done anything so disruptive on that article as he did here, editors there would have screamed bloody murder about it.  However, I decided to look at this more closely; I examined every change to the Forth article since Ideogram joined Wikipedia.  During that time, Ideogram added ''eleven'' {fact} tags (actually, the {citation needed} synonym) over the course of five edits.  However, Ideogram himself filled in references for some of those before adding more, so there were never a whole eleven such tags at once.  I do think that many tags is a bit on the indiscriminate side, but it was during a couple day period, with Ideogram filling in many of his requests himself.

In contrast, on this article, Ideogram added '''eighty-seven''' {fact} tags during a single edit! Moreover, he reverted removal of this huge number of tags '''three times''' after different editors removed them.  At almost exactly the same time  he added a similar number of these tags to the [[Functional programming]] article (that I happen to watchlist).  

To my mind, there is just no way to read this action as good faith.  What it does is make the article effectively unusable to readers who might want to read it ''today'', rather than in some gloriously prophesied future when it reaches FA status (even assuming such is the noble intent).  The word for disrupting an article in order to make a point about goals for its eventual status is... [[WP:POINT]]. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 05:34, 29 June 2006 (UTC)

:You have your facts all wrong.  But I'm not talking to you anyway.  [[User:Ideogram|Ideogram]] 05:59, 29 June 2006 (UTC)

::The diffs are as follows:
::* http://en.wikipedia.org/w/index.php?title=Programming_language&diff=60923159&oldid=60901418
::* http://en.wikipedia.org/w/index.php?title=Programming_language&diff=next&oldid=60957828
::* http://en.wikipedia.org/w/index.php?title=Programming_language&diff=next&oldid=61037198

::It's one shy of a 3RR violation, but definitely not good behavior.  I suppose it's conceivable that I counted the 87 tags wrong when I eyeballed it—anywhere from 85-90 is probably plausible for my counting error, though I think I counted right. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 06:19, 29 June 2006 (UTC)

::Oh, I went and counted in [[Functional programming]].  It was indeed "only" ''forty-six'' {fact} tags there, so that's fewer than here.  I think it just seemed like more because the article is shorter, so the density struck me more. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 06:24, 29 June 2006 (UTC)

:::You haven't even considered your biggest errors.  But I'm not here to explain them to you.  [[User:Ideogram|Ideogram]] 06:32, 29 June 2006 (UTC)

::::I suppose it's conceivable I made an off-by-one error in counting the Forth article too.  The point about disruption being bad remains the same.  You also added several useful references to the Forth article ''without'' first adding the citation tag, which is quite exemplary behavior.  I would not object at all to you adding concrete citations rather than disruptive {{Tl|Fact}} tags here.  Eighty-seven of them would still be a bit superfluous, but we have a long way to go before needing to worry about that. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 06:41, 29 June 2006 (UTC)

::::All I'm really looking for here, Ideogram, is an absolute and steadfast promise by you that you won't engage in this type of disruption again.  You have been an extremely valuable and productive editor on a number of CS articles, and clearly you are both knowledgeable and able to write.  I value that, and if you'd promise to avoid deliberate harm to articles, I'd easily be able to assume good faith again. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 06:45, 29 June 2006 (UTC)

:::::'''YOU''' have no right to demand '''ANYTHING''' from me.  Assuming good faith is not conditional, that's why it's '''ASSUMED'''.  And I'm not going to have a ridiculous argument with someone bent on proving I'm engaged in WP:POINT.  [[User:Ideogram|Ideogram]] 06:47, 29 June 2006 (UTC)

::::::I'm a relative newcomer and have no involvement with this article (I just happened to see the issue on the village pump:policy page and was curious), so I'm not sure how involved I should get in this. I didn't read the whole discussion, but I think I got a decent idea of what is going on and wanted to share my opinion.
::::::User A thinks that virtually every sentence requires a citation (and everyone else should assume that this is a genuine effort to improve the quality of the article). User B thinks that User A is trying to make a point (and User A should step back and assume that User B is looking out for the integrity of the article and wikipedia in general by helping to enforce established policies). It looks to me like everyone is getting defensive, which is just snowballing the whole issue.
::::::How many citations are actually needed, based on policy and comparable articles? I'm certainly no expert on wikipedia policies with regarded to sources, but I would think that citing every word is excessive, and the citations would be as disruptive to the reader as the {fact} tags are. Of course, credit to the sources is due, and will improve the article by allowing the reader to check the sources for more information and to verify the content of the article. At least every general idea, as long as it is not common sense, should be attributed to a source. That doesn't mean everything needs to be cited, does it? For example, I noticed that in the course of this "edit war", there was a {fact} tag with information regarding programming languages ncessarily needing more structure than other human languages- this to me seems as though it would be intuitive (although I may be biased, having some programming educational background). Inclusion of {fact} tags even with intuitive or common sense information does ''seem'' like it's being used merely to make a point and go over the top with it, whether that is the goal or not. My suggestion for anyone who thinks (insert large number) {fact} tags are needed should voluntarily step back and try to see what the article really needs, or let someone else do it. Perhaps it would be better to add the bare minimum (assume that any broad statements are general knowledge, for example), wait for the improvements to be made, then re-evaluate it, and add more then if it is still necessary. Like I said, adding them all at once does come across the wrong way, even if it is well-intentioned (and Rome wasn't built in a day, right? Why bombard an article with notes about every little thing it needs all at once?)
::::::Just my 2 cents, take it or leave it.
::::::--[[User:Dan128|Dan128]] 08:04, 29 June 2006 (UTC)

:::::::Some featured articles I have read with their citation counts:  [[Global warming]]: 27.  [[Absinthe]]:  27.  [[Kylie Minogue]]:  36.  [[OpenBSD]]:  40.  [[AIDS]]: 108.  [[Forth (programming language)|Forth]] had 20 citations and this was not enough.  87 fact tags may have been excessive, but currently we have only 13 citations in [[Programming language]].  [[User:Ideogram|Ideogram]] 08:23, 29 June 2006 (UTC)

And just when it looked like it had all calmed down and I was pondering closing the mediation case....

To take the issues in turn:-

:[[User:Ideogram]], you skated perilously close to violating the 3RR with your reversions of the fact tags, you know the rule, discuss it on the talk page.

::I reverted exactly twice, Lulu was incorrect in his count, he counted the initial edit as a reversion.  I reverted twice because after I reverted, a different, and new, editor reverted my changes, and I directed him to the talk page.  When Lulu reverted a second time, I stopped reverting.  [[User:Ideogram|Ideogram]] 08:31, 29 June 2006 (UTC)

:[[User:Ideogram]] said "But I'm not talking to you anyway" - I say, grow up.  If you're not willing to discuss edits, don't make any.  Comments like that help no-one and will simply lead to the article turning into an edit war.

::I don't see why I should continue to talk to someone who won't stop accusing me of [[WP:POINT]] and is manifestly unable to assume good faith.  Talking to someone who can't assume good faith about you is a waste of time.  [[User:Ideogram|Ideogram]] 08:31, 29 June 2006 (UTC)

:[[User:Ideogram]] - no-one "DEMANDED" anything from you.  [[User talk:Lulu of the Lotus-Eaters|talk]] "looked for" something, but didn't demand - don't twist quotations to make your comments sound stronger.

::I don't see that Lulu had the right to "look for" that something either.  His "request" was still founded on the assumption that my actions were "disruptive" and "deliberate harm".  Furthermore he has no right to impose conditions on any other contributing editor.  [[User:Ideogram|Ideogram]] 08:31, 29 June 2006 (UTC)

:Right, and now on to the actual problem at hand = {fact} tags.  In my humble opinion, there is absolutely no need for as many as you inserted.  Simple sentances which state a fact do not require a citation.  There is no right answer to how many, but in my opinion, less is often more for citations - get the good ones and far fewer do a better job.  If you're are that certain that many citations are needed, spend your time finding citations rather than edit warring over a request for them.  I'm sure editors will have far less of a complaint if citations appear rather than just tags saying "I think there should be something here, but can't be bothered to find it".  All of which has already been said very well by [[User:Dan128|Dan128]] above, but I repeated it for no apparent reason.

::Now I have to argue with the moderator about how many fact tags are required for FA status?  Read the links I provided.  [[User:Ideogram|Ideogram]] 08:31, 29 June 2006 (UTC)

So to sum up, [[User:Ideogram]], back-off and discuss your edits.  You know full well there is tension around this article, don't excacerbate it by refusing to discuss things - either talk them through, or leave the article alone.  [[User:kcordina|Kcordina]] <sup> [[User talk:Kcordina|Talk]] </sup> 08:14, 29 June 2006 (UTC)

:I will be happy to discuss anything with Lulu once he stops accusing me of [[WP:POINT]] and is able to assume good faith about me.  I am not happy that you chose to direct all your comments at me and failed to note Lulu's offences against Wikipedia policy.  [[User:Ideogram|Ideogram]] 08:31, 29 June 2006 (UTC)

::There wre no comments about the behvaiour of [[User:Lulu of the Lotus-Eaters|LotLE]] because I couldn't see anything they had done wrong.  They only mentioned [[WP:POINT]] once, and have attempted to discuss the matter, but have been met by you stating ''I'm not talking to you''.  What this matter needs is rational discussion.  The simple solution to this, as suggested by [[User:Lulu of the Lotus-Eaters|LotLE]] above, is to insert the references you think are desperately needed.  I miscounted the reverts, for which I apologise.  No, you don't have to argue with me about how many citations are needed - I provided ''my opinion'', that does not mean you have to argue, I was simply offering an outsiders view. [[User:kcordina|Kcordina]] <sup> [[User talk:Kcordina|Talk]] </sup> 08:46, 29 June 2006 (UTC)

:::Count again.  I see four mentions of WP:POINT on this topic, and two in the edit summaries.  Quotes:  "disruptive tag, bordering on vandalism", "some sort of ego thing on your part", "I am ''going to'' revert ... on sight", "disruptive ... shows real bad faith", "disrupting ... to show off", "destroyed the article ... making it unusable", "pisses me off ... vindictively destroy", "I'd hope ... (you would) not desire destruction... but I guess not", "rather than stomp your feet", "random disruption".  That about covers it.

:::And that's not counting all the times Lulu has accused me of WP:POINT before.  I was trying ''very hard'' to have a rational discussion with Lulu but the fourth WP:POINT accusation, after repeated denials by me, was really too much.

:::I am not capable of adding all the references needed.  I already added five of the thirteen current citations.  I thought it would be helpful to tag the places I thought citations could be used, since I have used this tactic successfully before.  To be accused of WP:POINT and vandalism in response is way over the top.  [[User:Ideogram|Ideogram]] 09:00, 29 June 2006 (UTC)

== Proposed compromise ==

Since the minimum number of citations I have seen on a FA is 27, and we currently have 13, I propose to add ''exactly'' 14 fact tags to this article, and wait for them to be filled before adding more.  Is that acceptable to everyone?  [[User:Ideogram|Ideogram]] 09:19, 29 June 2006 (UTC)
:Reference counting is as bad as edit counting. There is no minimum or maximum number of references required. Though people oppose articles for not having enough references, theoretically it is still possible to have an FA with just a couple of them or even ''none''! I am yet to see this possibility but it is possible. For example, it might be possible for article on a not-so-well-known novel, in which the article deals mostly with the plot of the novel. It would be absurd to say that Mr. so-and-so in the novel had 3 children (as the statement is directly sourced from the book and may be un-necessary even as an {{tl|inote}}). While other controversial topics like AIDS would need a lot more. It all depends on the scope of the article and the claims made in it. Every reference should be added on its own merit. &mdash; [[User:Ambuj.Saxena|Ambuj Saxena]] ([[User_talk:Ambuj.Saxena|talk]]) 10:08, 29 June 2006 (UTC)

::I am confused.  During the FAC nom for [[Forth (programming language)|Forth]] I was repeatedly advised I needed one citation per section, or one citation per paragraph, or one citation per fact.  I added one citation per section, which resulted in me tagging some painfully "obvious" facts like the basic features of the interpreter and compiler, and was told, by you, that the level of citation was still not good enough.  Most of the citations added could have been directly sourced from the introductory programming text in the references section, and yet I was told I did not have enough citations.  What is left for me to do but to cite obvious facts?  [[User:Ideogram|Ideogram]] 15:19, 29 June 2006 (UTC)

:::I disagree with [[User:Armedblowfish]] in the FAC. To me, everything that can be attempted to be refuted, or any claim, needs referencing; not every sentence or fact. Most of the important facts could do with {{tl|inotes}}, while the less important and non-controversial ones can be left unreferenced unless they require attribution. I never told you that the level of citation is not good enough. I just told you to get citations for all sentences tagged with {{tl|fact}}. My other concern was use of peacock terms and unencyclopedic words. I think the article was moving in the right direction and could have been featured if more people took part in the discussion. You may wish to contact [[User:Armedblowfish]] for clarification over his standards for FAC. Anyway, whatever we say is our own opinion. If you want expert opinion, ask for Taxman's help, and if needed very desparately, Raul's. &mdash; [[User:Ambuj.Saxena|Ambuj Saxena]] ([[User_talk:Ambuj.Saxena|talk]]) 15:48, 29 June 2006 (UTC)
:I'm sorry Ideogram, but I have to agree with the others here. The best strategy in the short term is to focus on just a few places where citations would be really helpful and/or necessary, such as questionable or central facts. Once these refs are in place, more tags can be added. Covering the article in a dense fog of tags just serves to disrupt the flow of reading. [[User:Deco|Deco]] 11:29, 29 June 2006 (UTC)

::Fine.  I can admit I'm wrong, as long as you don't accuse me of WP:POINT or bad faith.  [[User:Ideogram|Ideogram]] 15:19, 29 June 2006 (UTC)

:::Don't worry, I'm confident that you're just trying to improve the reference quality of the article, and I would encourage others to not levy bad faith accusations against you. [[User:Deco|Deco]] 16:54, 29 June 2006 (UTC)

Citations are needed, but 'citation needed' tags don't help a whole lot, especially adding 87 of them in one go. Reverting them back in after different editors have removed them is disruption plain and simple, even though it seems clear you were trying to help. Admitting you were wrong is a good step, but heading it off at the pass is better. Discuss and gain consensus, don't revert &mdash; and yes be willing to be the first and the only person to do that, something that if everyone did, would make this a more enjoyable project to work on. Furthermore once the citation needed tags are put in and then reverted out, their full value is left in the edit history: every fact that has been marked as needing a citation can be seen if needed. There is no need to repeatedly clutter the article up with them. Now in general ''every'' fact in the article should be supported by a reliable source, but that doesn't mean every fact needs a footnote or similar inline citation. Prioritize the most important and potentially contentious facts and cite those, along with any specific quotes or data points. Then make sure you have high quality references that can support the rest of the material. - [[User:Taxman|Taxman]] <sup><small>[[User talk:Taxman|Talk]]</small></sup> 16:44, 29 June 2006 (UTC)

== Citation needed? ==

I see that the sentence 
:''[[American National Standards Institute|ANSI]]/[[International Organization for Standardization|ISO]] [[SQL]] and [[Charity programming language|Charity]] are examples of languages that are not Turing complete yet often called programming languages.''
has been tagged "citation needed". What exactly needs citing here? That the languages in question are not Turing complete? That the languages are called programming languages? --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 16:10, 29 June 2006 (UTC)

::Both.  For Charity, I suppose a cite to the appropriate paper would suffice.  For SQL, I'm not sure, but I guess we could let that go.  [[User:Ideogram|Ideogram]] 16:29, 29 June 2006 (UTC)

:::Ok, I've added a ref for Charity (including relevant quotes). I'll leave references for SQL to someone else. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 16:58, 29 June 2006 (UTC)

::::Thank you Allan.  [[User:Ideogram|Ideogram]] 17:06, 29 June 2006 (UTC)

I think some versions of SQL are Turing complete, and some aren't. [http://www.w3.org/2001/tag/doc/leastPower-2006-01-23.html][http://lists.w3.org/Archives/Public/www-tag/2005Dec/0103.html] I'm not quite sure how reliable that source is, but it is from the World Wide Web Consortium. [[User:Armedblowfish|Armedblowfish]] ([[User_talk:Armedblowfish|talk]]|[[Special:Emailuser/Armedblowfish|mail]]|[[Special:Contributions/Armedblowfish|contribs]]) 19:32, 29 June 2006 (UTC)

: That's why the text reads as it does now.  It used to contain some meandering circumlocutions about "unless vendor-specific extensions make it Turing-complete".  The version of SQL we are referring to is, quite precisely, ANSI/ISO SQL (either SQL-92 or SQL:2003), and it is so named in the article. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 19:36, 29 June 2006 (UTC)

== Thanks ==

Thank you all for adding citations.  [[User:Ideogram|Ideogram]] 12:09, 30 June 2006 (UTC)

== Purpose section ==

The following sentence is one of the reasons quoted why different programming languages are suited to different tasks:

:Programs may need to extract the right amount of performance on platforms ranging from tiny microcontrollers to supercomputers.

This seems to me to be an oversimplification of what should be said here, which is that programs "must find a balance between performance, compactness and ease of writing" on such differing platforms.  If performance were the only issue, everything would be written in assembly language.  I propose that something more like the text I put in quotes there be used to replace "may need to extract [...] performance" in the sentence I quoted.  I'm not happy with "ease of writing" though... there must be a better way of expressing that that doesn't sound so clumsy.  Anyone? [[User:JulesH|JulesH]] 13:36, 3 July 2006 (UTC)

==What makes a language general-purpose?==

The article currently reads:
:All Turing complete languages can implement the same algorithms. These are often called general purpose programming languages. 
I don't think this is correct. "General-purpose" refers to languages which cover a broad range of applications, and are not, um, special-purpose.  So, for example, [[Snobol]] or [[awk]], though they are Turing-complete, are special-purpose in the sense that they were designed for, and mostly used for, string manipulation.  [[PHP]] is special-purpose in that it was designed for, and mostly used for, building dynamic Web pages. [[SQL]] is special-purpose not because it is not Turing-complete, but because it is designed for the manipulation of database relations. Of course all these languages (except SQL) can be used for general-purpose programming (and are by their devotees).  Sometimes languages break out of their special-purpose niche, the most spectacular example probably being [[Simula 67]], which was originally designed for simulation, and became the first object-oriented language. --[[User:Macrakis|Macrakis]] 14:09, 3 July 2006 (UTC)
:I think what is meant by general purpose is that it can be used for any task. Turring complete languages can. Non Turring complete can't. [[User:Jaxad0127|Jaxad0127]] 18:11, 3 July 2006 (UTC)
::Even that isn't necessarily true though: if your purpose requires you to interface with something else (other software or a piece of hardware) and your language doesn't implement an interface that will let you do that, you're stuck even if it is Turing complete.  General purpose languages, to be truly general purpose, must be able to form arbitrary interfaces with both the hardware and other software on the system.  Turing completeness says nothing about that, only what results you can calculate. [[User:JulesH|JulesH]] 19:52, 5 July 2006 (UTC)

:::Again, personal opinions are not a basis for deciding Wikipedia content.  Citations are.  --[[User:Ideogram|Ideogram]] 19:54, 5 July 2006 (UTC)

::::Well, exactly, to support a somewhat idiosyncratic use of "general-purpose" should be attributed to a source.  But in general use, the term has as much to do with available interfaces and libraries as it does with Turing ''per se''.  An embedded language that had a "loop" and a "tape", but no facilities for interacting with an OS, a screen, a keyboard, etc (e.g. it was fine as a controller with just one serial I/O interface) isn't "general purpose" under normal usage. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 01:04, 6 July 2006 (UTC)

Uh, I'd be careful with any claim of "all" in this context.  The following paragraph is pure opinion on my part (so it doesn't go in the article), but I'll add it to the talk page anyway.  :)  The difference between a general-purpose language and a [[domain specific programming language]] (it's opposite) isn't (in general) computational ability, but feature set.  All modern GP languages are Turing-complete; if for no other reason than TC-ness is easy to accomplish.  Some DSLs are; others are not; the DSLs which aren't are generally descriptive languages as opposed to imperative ones (and thus lack looping constructs and such); there are some descriptive DSLs which are Turing-complete by accident only.  

Some DSLs are intentionally not TC (See [[principle of least power]]), under the (questionable) assumption that being computationally weaker makes them amenable to static analysis, and thus more secure.

Getting back to the article:  I'm tempted to omit a definition of Turing-completeness; or if we provide one, we should steal it from [[Turing complete]] or some other source on computational complexity.  

--[[User:EngineerScotty|EngineerScotty]] 20:04, 5 July 2006 (UTC)

== Good Article ==

Congratulations, everyone.  Good work!  --[[User:Ideogram|Ideogram]] 19:54, 8 July 2006 (UTC)

== Not-quite-PLs ==

There have been a number of changes today from the fairly longstanding description of "sometimes called (but not usually) PLs".  The old version was:

:''Other [[computer languages]], such as [[HTML]], are sometimes informally referred to as programming languages.''

Frankly, I don't think any of the new versions (including mine) are better than the older ones.  But as minimum, this point, while important to mention passingly, becomes distinctly belabored if more than 20 words (''maybe'' 25 at the outside) are spent on it.  Most of the revisions (other than mine) wer 50+ words, giving very [[WP:NPOV#Undue weight|undue weight]] to the minor point. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 20:51, 9 July 2006 (UTC)

:I don't think this is a minor point at all. I think it should be discussed later in the article, but it's a point of significant contention in the community that deserves expounding upon because of how it deals with the subtleties of defining programming languages. I wouldn't try to downplay this. [[User:Deco|Deco]] 20:53, 9 July 2006 (UTC)

::Can you present a source—other than popular, non-programming business-speak—that describes a non-computational language as a programming language? I have never seen one. If there is a citable source here, we could work from what this source claims. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 20:55, 9 July 2006 (UTC)

''Please, please,'' '''please''' let us avoid long and irrelevant digresssions on this point.  It is just plain '''ugly''' to spend 60 badly-written words on a point that is only just barely merits mentioning in 20 words.  As a minimal (and probably unnnecessary) expansion of the nice concise prior form, I tried:

:''Non-computational languages, such as [[markup language]]s like [[HTML]] or [[formal grammar]]s like [[Backus–Naur form|BNF]], are usually not considered programming languages. A continuity with declarative computational languages blurs the distinction.''

I actually think there is mild benefit in using BNF as a second example, since it's not "markup", but still something other than computational (and we discuss it briefly later in the article anyway).  That's 28 words, which is slightly more than I'd like (I'd be happy w/o the second sentence), but at least it's not 60 words like Derek farn's last edit (and the words are spelled right). <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 01:27, 10 July 2006 (UTC)

:I agree that it is ugly in its current position, but I still think the best way to deal with it is to briefly mention that there are borderline cases and then give more detailed explanation later in the article, after more important things have been discussed. It won't be ugly in the middle of a detailed discussion of definitional issues, which are quite relevant to the topic but not exactly introductory. [[User:Deco|Deco]] 01:40, 10 July 2006 (UTC)

::Possibly it would be better somewhere else, i.e. later in a separate section.  But so far we haven't actually seen any evidence that ''anyone'' of relevant expertise has ''ever'' used the term "programming language" to describe markup like HTML.  On the other hand, the listed citations in the "Definitions" section list some good sources that explicitly exclude it (not necessarily naming HTML, but indicating "computational").  I am skeptical that the usage has ever been anything other than a misunderstanding by poorly informed business press (or even worse informed head hunters... aagghh!). <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 01:54, 10 July 2006 (UTC)

::Moreover, there are already perfectly good articles at the end of the links to [[markup language]], [[HTML]], [[BNF]], etc.  We need not repeat everything where a simple mention and link more than suffices. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 01:56, 10 July 2006 (UTC)

:I like the language you propose above, Lulu.  It's quick and to the point.  One source of confusion is sometimes the communities surrounding dynamic languages like [[Lisp]] (in all its forms), who tend to blur the distinction between code and data.  (In homoiconic languages with an eval capability; there is often little ''to'' distinguish code and data, after all).  Obviously many forms of "data" can be considered instructions for some sort of machine; one could argue that a .jpeg file is a highly domain-specific programming language, containing instructions to a graphics engine on how to render an image.  Of course, such arguments aren't illuminating, and I'd like to stay away from such (I bring it up just to show where such lines of thinking can lead).  --[[User:EngineerScotty|EngineerScotty]] 03:58, 10 July 2006 (UTC)

Should we mention that derivatives of markup languages (like [[DHTML]] for HTML and [[Extensible Stylesheet Language|XSL]] for XML) can be computational and therefor programmable? [[User:Jaxad0127|Jaxad0127]] 05:57, 10 July 2006 (UTC)

*WRT LotLE's objection that calling HTML a programming language is an ill-informed mistake, shouldn't we describe, rather than prescribe, usage?  If so, shouldn't reasonably-common mistakes and inexact usages be noted, together with an explanation that the usage is informal?  As a non-technical example, [[Frivolous lawsuit]] has a precise and a colloquial meaning.  Both are noted. [[User:Robert A West|Robert A.West]] ([[User talk:Robert A West|Talk]]) 06:04, 10 July 2006 (UTC)

::I think it was Allan McInnes who noted earlier in this same discussion that we should ''note'', but not ''promote'', a misusage.  

::It's sort of like the way that all "non-prescriptive" dictionaries are, of course, actually prescriptive.  It's not that any usage is completely equivalent, just that we don't decide usage from first principles.  More concretely, the usage that "matters" is that of relevant experts (in this case, people who write books on programming, etc); but if enough ill-informed HR departments list HTML as a PL, that misuse can be briefly mentioned ''as a common mistake'' (which is what we do). Your change looks fine to me, it saves a couple words, which is good. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 13:59, 10 July 2006 (UTC)

**I rephrased slightly, and I hope accurately.  Feel free to revert me if you think I am wrong.  [[User:Robert A West|Robert A.West]] ([[User talk:Robert A West|Talk]]) 06:13, 10 July 2006 (UTC)

== JTAG Interface ==

How the ARM processor can be interfaced with JTAG?
Anybody having sufficient information, kindly let me know.
--[[User:Satyabratasahoo|Satyabratasahoo]] 11:46, 10 July 2006 (UTC)satyabratasahoo
* We've no idea here; this is a Wikipedia talk page for the article on [[Programming Language]]s.  I recommend contacting your processor vendor (Intel or whoever), they should have the information you seek.  --[[User:EngineerScotty|EngineerScotty]] 17:10, 10 July 2006 (UTC)

== Recent intent/purpose edits ==

I'm having difficulty understanding what [http://en.wikipedia.org/w/index.php?title=Programming_language&diff=65035832&oldid=65022694 this edit] is trying to say.  Apparently this is talking about how the application domain of a programming language determins its features and characteristics, with a lot of examples.  I think that:

*The subject is worth discussing, but better addressed in the "Purpose" section.
*We need more discussion of principles and less of a "laundry list" of examples.  For example, discuss common application domains (database access, education, hardware control) first, and under each domain list one or two example languages.  --[[User:Ideogram|Ideogram]] 16:39, 21 July 2006 (UTC)

:It was hard to make sense of those edits.  Or the one about bits within bytes changing meaning by the same user.  The language was poorly written, which added to the confusion.  But even imagining rephrasing, it looks sort of like a "brain dump" of tangentially related thoughts—not ''entirely'' off-topic, but not obviously on-topic either.

:I'd suggest that if there is some point that is being sincerely proposed, we need to see it here on this talk page first, and figure out how best to include the concepts through dicussion. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 16:54, 21 July 2006 (UTC)

== Removed incorrect weak-typing example ==

In [http://en.wikipedia.org/w/index.php?title=Programming_language&diff=73952354&oldid=73154197 this edit], I removed the following text:

:The expression <tt>"123" + 45</tt> is legal in Javascript; and produces the result <tt>168</tt>; in evaluating the expression, a Javascript engine will note that the string "123" is convertable to a number, implicitly perform the conversion, and then add 123 and 45 to produce the final sum.  However, note that the expression <tt>"123" + "45"</tt> is <tt>"12345"</tt> (and neither <tt>168</tt> nor <tt>"168"</tt>); the <tt>+</tt> operator when applied to strings in Javascript performs string concatenation.

That's not true.  Demonstration: type javascript:void(alert("123"+45)) into your browser's address bar.  You'll see a dialog box with the text "12345" instead of the text "168".  If someone has an example that works, please put one in!

-- [[User:Phyzome|Phyzome]] is [[User talk:Phyzome|Tim McCormack]] 14:39, 5 September 2006 (UTC)

:What about just changing it to Perl:

 $ perl -e 'print "123" + 45'
 168

:Of course, it's really the operator that chooses the conversion:

 perl -e 'print "123" . 45'
 12345
 $ perl -e 'print "123" + "45"'
 168

:<font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 15:25, 5 September 2006 (UTC)

:: I think this and the original example are mixing operator overloading (+ for add versus + for concatenate) -- and that has nothing to do with weak/strong typing.  [[User:Quota|quota]] 16:53, 5 September 2006 (UTC)

:Looks good to me. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 16:22, 5 September 2006 (UTC)

:: No, this has nothing to do with operators (except conversion 'operators').  Let's try and find an example -- preferably not in any 'real' language unless it has a standard which we can reference -- which captures the concept being talked about here.  [[User:Quota|quota]] 16:53, 5 September 2006 (UTC)

:::Weak typing is not a well-defined term. However, what people generally seem to mean when they say "weak typing" is the kind of operator overloading with implicit type conversions that LotLE's Perl example demonstrates. See [[Weak typing]] and [[Type system#Strong and weak typing]] for more. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 18:20, 5 September 2006 (UTC)

::I disagree -- it's a conversion effect, not an operation effect (unless you consider assignment and conversions to be operators, which many languages do not).  For example, if one writes 'x=1.3' the meaning of that is very much dependent on the types of the left and right hand sides of the assignment.  In a strongly typed language both sides will have a (strongly) defined type (in C and C99, for example, the right hand side is a binary floating-point value, unfortunately).  In a weakly typed language, one (or both) sides will be more forgiving.   This has nothing to do with operations such as '+' .. which is why I am just saying we need a better example.  [[User:Quota|quota]] 18:29, 5 September 2006 (UTC)

:::And yet the [[Type system#Strong and weak typing]] section that I pointed to before uses basically the same example as a demonstration of weak typing. That usage seems to be a common one. Are you arguing for the more formal definition of weak-typing (i.e. a typed language that permits forbidden errors to exist in programs that pass the type-checker), used for example [http://lucacardelli.name/Papers/TypeSystems.pdf here]? 
:::: Not that far, necessarily, but I think a clearer example would be one where the variables can have multiple types (like many BASIC-like languages) .. rather than the variables having a fixed type (which there may be say or unsafe conversions to on assignment/copy) [[User:Quota|quota]]
:::Also, I'm a little confused as to why you're pointing to C as a "strongly typed" language. It's pretty widely considered weakly typed. Are you perhaps referring to [[static typing]] rather than strong typing? --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 18:58, 5 September 2006 (UTC)
:::: Sorry, I was a bit unclear -- I didn't meant to imply that the language was strongly types, just that aspect of it.  (Although I would describe C as unsafely-typed rather than weak-typed.  All variables have a unique type (though of course can be compromised by unions, etc.).  [[User:Quota|quota]] 16:01, 6 September 2006 (UTC)

== Version 0.5 ==

I've passed the article for inclusion into [[WP:0.5]], but to the folks who see this page: can we get those darned {{tl|fact}}s fixed soon? [[User:Titoxd|Tito]][[Wikipedia:Esperanza|<span style="color:#008000;">xd</span>]]<sup>([[User talk:Titoxd|?!?]])</sup> 17:00, 11 September 2006 (UTC)

== Contradiction ==

C++ is more strongly typed than C, and yet the article implies that C++ is less strongly typed than C, particularly in the last sentence of that section. For example:
:<code>char* buffer = malloc(64);</code>
will compile in C, but not in C++.  C++ requires a cast from <code>void*</code> to <code>char*</code>.  In comparison to C, C++ is rather strict about typecasting and mixing between types.
:<code>char* buffer = (char*)malloc(64);</code>
compiles in both languages.  [[Allegro library|Allegro]] won't compile using g++ out of the box for this reason.  The article is borked.--[[User:DavidHOzAu|DavidH]][[User talk:DavidHOzAu|Oz]][[Special:Contributions/User:DavidHOzAu|Au]] 09:01, 27 September 2006 (UTC)

: I don't see the contradiction you mention in the article. How is it implied that C++ is less strongly typed than C? The final paragraph of that section reads
::''Strong'' and ''static'' are generally considered orthogonal concepts, but usage in the literature differs.  Some use the term ''strongly typed'' to mean ''strongly, statically typed'', or, even more confusingly, to mean simply ''statically typed''.  Thus [[C programming language|C]] has been called both strongly typed and weakly, statically typed.
: C can only be called strongly typed if strongly typed and statically typed are used as synonyms. And then C++ has also to be called strongly typed. &mdash;&nbsp;[[User:Tobias Bergemann|Tobias Bergemann]] 11:10, 27 September 2006 (UTC)

:I concur with Tobias here. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 17:13, 27 September 2006 (UTC)

::I also agree. I've already removed the contradiction tag from that section. [[User:Jaxad0127|Jaxad0127]] 18:58, 27 September 2006 (UTC)

== Syntax example flub or simplification? ==

Under '''Elements''' subheading '''Syntax''' a lispy example is given:
 symbol  ::= ['A'-'Z''a'-'z'].*

The descriptive text following is
: a ''symbol'' is a letter followed by zero or more of any characters '''(excluding whitespace)'''

I don't know of any RE syntax where a period pattern excludes whitespace.  Is this an oversight?  Or maybe follows a language specification-specific regular expression convention?  — [[user:EncMstr|EncMstr]] 21:25, 5 October 2006 (UTC)

== Fourth generation languages ==
I like the merge of the 'generational' view into History, except where is the reference to the [[Fourth-generation programming language|4GL]]. Some of these started in the 1960s, made a big splash, and are still in use. Now, along that line, [[End-user computing|programming by users]] has very much been a part of the History which ties in both with the [[Fourth-generation programming language|4GL]] and the [[Fifth-generation programming language|5GL]]. Though, with both [[ICAD]] and AutoCAD, we've seen end-users tackling their problems with Lisp. Ought not there be some reference to the [[Fourth-generation programming language|4GL]] motivation and phenomenon? [[User:JMSwtlk|jmswtlk]] 14:43, 14 November 2006 (UTC)

:Oops. Sorry, somehow forgot that in the merge. Please jump on in and add something relevant on 4GLs to the history section, if you have some time. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 05:49, 15 November 2006 (UTC)

===Heuristics or not===
At the risk of getting my head cut off, I need to ask a question about why we cannot have heuristics (motivations for programming languages are many, including problem solving, ...) mentioned on this page. Perhaps, it ought not be in first paragraph according one school of thought. But, there are others that might see the need: Turing himself looked into the matter ([http://www.alanturing.net/turing_archive/pages/Reference%20Articles/what_is_AI/What%20is%20AI03.html]); also, consider [[Interactive computation]].  
:Programming languages are used to facilitate communication about the task of organizing and manipulating information, to express [[algorithm]]s precisely, or to search for, and hopefully find, [[Heuristic %28computer science%29|heuristic]] solutions. Some authors restrict the term "programming language" to those languages that can express ''all'' possible algorithms;<ref>In mathematical terms, this means the programming language is [[Turing-complete]] {{cite book | last=MacLennan | first=Bruce J. | title=Principles of Programming Languages | page=1 | publisher=Oxford University Press | year=1987 | id={{ISBN|0-19-511306-3}} }}</ref> sometimes the term "[[computer language]]" is used for more limited artificial languages.
It has been my experience that the 'heuristic' space is much larger than its 'algorithmic' counterpart (though, they are both very large). Perhaps, that is why I lean toward the [[Quasi-empiricism in mathematics|quasi-empirical]] view.[[User:JMSwtlk|jmswtlk]] 15:06, 16 November 2006 (UTC)

:It just looks very out of place in trying to give a basic definition of PL.  It might well be a topic that can be addressed neutrally lower in the article, but it's not the ''definition'' of a PL that it can be used in certain ways, or for certain purposes.  Likewise, PLs are often used to express mathematical calculations, or often used to organize data records, but neither fact is the core meaning. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 15:27, 16 November 2006 (UTC)

"organizing and manipulating information" covers just about everything that might be said in a programming language.  I would rather have a tighter definition but realise it might be very hard to come up with one.  When you say ''heuristics'' do you mean human generates one or machine generated ones?  Either way they are a special case.  [[User:Derek farn|Derek farn]] 23:35, 16 November 2006 (UTC)

:It may be that a broad enough definition of algorithm would subsume heuristics (one could easily flip this view, though). Too, a programming language (as you suggested) could very well be used by the computer to drive itself and other computers (in this sense, the language would allow the human to enter into and influence the state of affairs). [[User:JMSwtlk|jmswtlk]] 02:35, 17 November 2006 (UTC)

::What about the [[frame language]]s such as [[KL-ONE]]. They can express heuristics. --[[User:Ancheta Wis|Ancheta Wis]] 03:24, 17 November 2006 (UTC)
:::Ah, yes, but that would be a [[Fifth-generation programming language|5GL]]. The [[KL-ONE]] page is fairly sketchy (hopefully, not for long). [[User:JMSwtlk|jmswtlk]] 21:01, 17 November 2006 (UTC)

== [[Wikipedia:Articles for deletion/Aurora (programming language)]] ==

It would be helpful to have more users participating in this discussion. [[User:Dpbsmith|Dpbsmith]] [[User_talk:dpbsmith|(talk)]] 03:26, 17 December 2006 (UTC)


== Redirected ==


I was redirected here from [[Programming Methodology]], but I think a redirection to [[Methodology (software engineering)]] would be more appropriate. 
--[[User:Logomachist|Logomachist]] 00:45, 5 January 2007 (UTC)


== Removed paragraph ==

I've removed this paragraph, as it seems to based on a confusion of ideas:

:A programming language can be classified by its position in the [[Chomsky hierarchy]]. For example, the [[Thue programming language]] can recognize or define Type-0 languages in the Chomsky hierarchy. Most programming languages are Type-2 languages and obey [[context-free grammar]]s.<ref>{{cite book|author = [[Michael Sipser]] | year = 1997 | title = Introduction to the Theory of Computation | publisher = PWS Publishing | id = {{ISBN|0-534-94728-X}}}} Section 2.2: Pushdown Automata, pp.101&ndash;114.</ref>

Specifically, it confuses the position of a ''language'' in the hierarchy with the class of languages it can recognize or define. Any Turing-complete language, by definition, can "recognize or define Type-0 languages in the Chomsky hierarchy", but most such languages are in fact Type 2. Contrariwise, the usual regular expression syntaxes are also Type 2, but can only recognize Type 3 languages. Anyway, I've never seen programming languages being classified this way. [[User:Ben Standeven|Ben Standeven]] 05:51, 17 April 2007 (UTC)

== Market Share ==

I'm trying to get some grasp on market share for the different programming languages.  I assumed it C, C++, and Java were the top 3, followed by C sharp, and then something that's less C based.  Here was the best source I could find, it's tracking book sales:

http://radar.oreilly.com/archives/2006/08/programming_language_trends_1.html
[[User:Mathiastck|Mathiastck]] 02:09, 14 June 2007 (UTC)

:One measure of market share is number of job applications that specify the language.  See 3/4 down the page of http://www.computerweekly.com/Articles/2006/08/01/217247/skills-on-the-rise-as-market-shifts.htm .  Computer Weekly have been doing this sort of thing for over 15 years.  Perhaps somebody should get permission to use their data in a language popularity article. [[User:Derek farn|Derek farn]] 09:34, 14 June 2007 (UTC)

:  This seems to indicate apache software greatly outnumber microsoft software on servers though.

http://news.netcraft.com/archives/web_server_survey.html

and IBM outnumbers in revenue on machines

http://news.zdnet.com/2100-9584_22-6108453.html

and these seems to indicate that HP ships the most servers:

http://h71028.www7.hp.com/ERC/cache/107846-0-0-0-121.html?ERL=true

[[User:Mathiastck|Mathiastck]] 02:15, 14 June 2007 (UTC)

:Market share is going to depend to a large extent on what market you are interested in. For example, in the embedded space C is extremely dominant, C++ sees some use, and most everything else is a minority language. In contrast, web applications are highly unlikely to use C or C++. I would be very surprised if you could find statistics that cover "all" markets for software. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 06:08, 14 June 2007 (UTC)

== Artificial language ==

Hi, I'm a little uncomfortable with the opening line describing a programming language as an ''artificial'' language. I appreciate what is meant here but in philosophy of language ''natural'' means general purpose rather than pertaining to nature. All language, surely, is natural - or if not, all equally artificial. I'm not sure what would be the best suitable replacement, ''constructed'' or ''contrived'' perhaps? Any ideas anyone? --[[User:Kylemew|Kylemew]] 23:29, 31 July 2007 (UTC)

:In linguistics a [[natural language]] is the term used to describe human spoken/written/signed languages by humans for general purpose communication.  In theory people could use programming languages for this purpose, but it would not be an efficient method of communication.  While the term artificial language has its disadvantages it does get the sense across to readers.  We could probably come up with some more long winded set of terms that are technically more correct, but it would probably loss the unversed reader.  Of course all languages are also constructed and contrived (ok, perhaps by a large group of people over a long time).  [[User:Derek farn|Derek farn]] 00:35, 1 August 2007 (UTC)

::There exists a wikilink to [[artificial language]] which perfectly well explains why that term is ''precisely'' the meaning we intend to convey.  [[Natural language]] does not mean either "general purpose" nor "pertaining to nature" in either philosophy of language or in linguistics. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 01:42, 1 August 2007 (UTC)

== That first paragraph ... ==

... is still not quite right.  Structure and meaning of what?  Program?  Process?  [[User:Quota|quota]] 10:44, 19 October 2007 (UTC)

== Lacks sections on popularity & productivity of modern languages ==

I would like to know what languages are most dominant and what people have to say about why the spread is the way it is.  What do people think about including a section about popularity, and also one about productivity?  Assembly is clearly an inferior language for all but the lowest level of work these days; C is often criticized; functional languages are gaining popularity.  But the article does not mention these important aspects of programming languages.  I think recent trends should be included--this article feels datad otherwise. -[[User:Reddaly|Reddaly]] 01:40, 20 October 2007 (UTC)
:Without real metrics these would just be topics of opinion.  Each individual language article has details on intended use.  I don't think opinions on productivity and popularity belong here.  It's more appropriate on another wiki like [http://docforge.com/wiki/Main_Page DocForge].  --[[User:Matt Schwartz|Matt Schwartz]] ([[User talk:Matt Schwartz|talk]]) 20:03, 14 December 2007 (UTC)

:I concur with Matt. Wikipedia is not the place to carry out language wars or push opinions. Furthermore, the answer to ''"what languages are most dominant"'' depends heavily on the market segment you are looking at: C maybe "often criticized", but it remains (in my opinion and experience) by far the most dominant language for embedded systems; on the other hand, C is (again, in my opinion and experience) rarely if ever used for web application development. As for "productivity", numbers -- rather than anecdotes and opinion -- on that are pretty hard to come by. Possibly because programmer productivity within a single language itself varies by a factor of (IIRC) around 20 or so. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 00:40, 23 December 2007 (UTC)

== Practice Section Dated and Incomplete ==

"A language's designers and users must construct a number of artifacts that govern and enable the practice of programming. The most important of these artifacts are the language specification and implementation."  That is a generalization and nowadays a misleading representation of how programming languages are invented in practice.  Ruby still lacks a thorough specification and has become a very popular language.  Paul Graham's [http://www.paulgraham.com/arcll1.html thoughts]: "In 1985, a programming language was just a spec. Now, thanks to Perl, it means not just (and maybe not even) a spec, but also a good free implementation, huge libraries, and constant updates." -[[User:Reddaly|Reddaly]] 01:42, 20 October 2007 (UTC)

== Expand on distinction between artificial and formal languages ==

Peter Linz, in "An Introduction to Formal Languages and Automata" page 2, implies that programming languages are formal languages. He says, "A formal language is an abstraction of the general characteristics of programming languages." However, [http://en.wikipedia.org/w/index.php?title=Programming_language&diff=167967774&oldid=167927426 Derek farn] says that many programming languages are not formal languages. Therefore, programming languages are artificial languages. This seems reasonable; however, I feel the distinction should be expanded upon in the article. The article [[Artificial language]] expands to [[Constructed language]] and [[Manually Coded Language]], neither of which describes programming languages. [[User:Timhowardriley|Timhowardriley]] 23:50, 2 November 2007 (UTC)

:Inserting completely meaningless {fact} tags on undisputed (undisputABLE, just about) statements is a gross violation of [[WP:POINT]], and comes close to vandalism.  <sarcasm>Along a similar vandalistic line, you might as well insert a {fact} tag on each and every uncited sentence... or clause, or word, for that matter.</sarcasm>.  Don't do this nonsense!

:If you think you have an actual point about formal/artificial, make the case on this talk page, and reach consensus before changing it.  It's a weak point, since almost certainly incorrect: many PL's are NOT formal languages (some are, yes).  But at least ''discuss'' rather than vandalize. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 00:48, 3 November 2007 (UTC)

:Actually, I wouldn't mind a sentence on the distinction between formal and artificial.  No more than a sentence, and most certainly not in the lead.  But I have no objection of adding that slightly later. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 00:50, 3 November 2007 (UTC)

:: I politely, but emphatically, reject you accusation of vandalism. [[WP:POINT]] makes no mention of citations, neither does [[Wikipedia:Vandalism]]. Instead of vandalizing the article, my intention is to improve the article by enforcing one of Wikipedia's core content policies. [[WP:CITE]] says, "If a particular claim in an article lacks citation and is doubtful, consider placing {{Talkfact}} after the sentence or removing it. If you have time to try and find a reference, please do so ..." As you can tell, I did try to find a reference. I hope this discussion yields some improvement. If it doesn't, {{Talkfact}} can most definitely be restored. [[User:Timhowardriley|Timhowardriley]] 01:24, 3 November 2007 (UTC)

::I agree with [[User:Lulu of the Lotus-Eaters]] when he says "Inserting completely meaningless {fact} tags on undisputed (undisputABLE, just about) statements is a gross violation of [[WP:POINT]], and comes close to vandalism." [[User:Timhowardriley|Timhowardriley]] I have noticed that you have the  habit of using these tags when you disgree with wording that others are unwilling to change to meet your point of view. [[User:Derek farn|Derek farn]] 02:36, 3 November 2007 (UTC)

:::The issue now and previously never has been [[WP:NPOV]]; instead, the issue is and always has been [[Wikipedia:What is a good article?|"[The article] is factually accurate and verifiable."]] [[WP:CITE]] says, "If a particular claim in an article lacks citation and is doubtful, consider placing {{Talkfact}} after the sentence or removing it." I first considered it, but instead acted [[wp:bold|boldly]] with [http://en.wikipedia.org/w/index.php?title=Programming_language&diff=167927426&oldid=166721222 this edit]. Derek [http://en.wikipedia.org/w/index.php?title=Programming_language&diff=next&oldid=167927426 reverted] my edit with a claim that many programming languages are not formal languages. Whereas it seems reasonable within the context of [[Moore's Law]], it seems doubtful based upon [http://www.ucdavis.edu/search/directory_results.shtml?filter=linz,%20peter Dr. Linz's] unqualified implication that the set of programming languages is a subset of formal languages. By the way, Derek you have just added the NPOV accusation to the POINT and vandalism accusations because of my action to enforce [[Wikipedia:Verifiability|one of Wikipedia's core content policies.]] Unfounded personal attacks are an indication that you believe I should [[Wikipedia:Be_Afraid|be afraid]]. [[User:Timhowardriley|Timhowardriley]] 20:29, 3 November 2007 (UTC)

How about something like this?

:A '''programming language''' is a language which is designed to control the behavior of a machine, particularly a computer.  Some but not all such languages are [[formal language|formally defined]], while others are specified in a less precise fashion, such as a prose description or by observing the behavior of a particular implementation.  

No questionable links to [[artificial language]], and accurately reflects the current state of affairs, where most languages are "specified" in informal means, such as a standard document, a "reference manual", a reference implementation, etc.  (No arguments over how "formal" reference implementations are).  --[[User:EngineerScotty|EngineerScotty]] 03:44, 3 November 2007 (UTC)

:This proposed sentence is misleading, IMO.  The whole mention of "formal language" has far more to do with a syntax than it does with a semantics.  But the former isn't really that much of what is involved in ''specifying'' a language.  Enough extra words could eventually untangle what the sentence is trying to actually say, but they are unnecessary since what we already have is both concise and precise. "Artificial language" is quite helpful, since all readers have a prior familiarity with natural language (even if not with that term to name them): the contrast is illustrative immediately. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 07:51, 3 November 2007 (UTC)

=== Taking care on "formal" ===
[[Artificial language]] would be appropriate if of the thousands of languages out there, a commercially significant few of them are not [[formal language]]s. I'm qualifying few with "commercially significant" because laboratory experiments would need to mature before appearing in an encyclopedia. What are the programming languages that are not formal languages? What definition of formal language are you using? What characteristic do the non-formal languages have that exclude them from the set of formal languages? [[User:Timhowardriley|Timhowardriley]] 20:29, 3 November 2007 (UTC)

:I think, for example, Perl and C add up to "commercially significant.  As I'm trying to get you to see, it's not only syntax.  Of course almost every language has a BNF grammar, but almost all of them have formally un(der)specified behaviors as well.  Not that "commercially significant PLs" is the topic of the article, in any case.  Other than maybe Ada and Haskell, almost no PLs are actually "formal languages" (though most are kinda-sorta close). <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 22:02, 3 November 2007 (UTC)

::Of course Perl and C are commercially significant. I'm a little shocked that they don't fit your definition of formal language. Could you expand on formally under-specified behaviors? Why is having BNF grammar not a sufficient criterion for inclusion in the formal language category? If you can build a grammar for a programming language, and if every formal language has a grammar, then why is a programming language not a formal language? The purpose of my using the term "commercially significant" simply was to exclude laboratory experiments. I originally thought these non-formal-language programming languages were going to be languages that had a natural language parser so advanced that they didn't need a BNF grammar. I had no idea that you were excluding common programming languages from the formal language category. Why is Ada a formal language but C not? Finally, I think "it's not the syntax; it's the formally under-specified behaviors" should be explained in the article. [[User:Timhowardriley|Timhowardriley]] 22:35, 4 November 2007 (UTC)

:::How lucky for you that everything you are asking about is ''already'' in the article, and has been for a long time.  Did you ''read'' the article?!

:::The section 'specification'', for example, mentions that: ''While syntax is commonly specified using a formal grammar, semantic definitions may be written in natural language (e.g., the C language), or a formal semantics (e.g., the Standard ML [17]and Scheme[18] specifications).''  Some other material in that section is quite germane also.

:::There is a fairly nice example of a syntactic but un(der)specified program for C in the article also: ''The following C language fragment is syntactically correct, but performs an operation that is not semantically defined (because p is a null pointer, the operations p->real and p->im have no meaning)''

:::I think the real problem here is that editors get stuck on a pet notion, and want to rewrite a very carefully negotiated lead to (mis)emphasize it.  These same editors don't bother reading the body of the article to find out that the very issues are already well addressed there. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 23:09, 4 November 2007 (UTC)

:::Yikes! I just noticed the structure of Timhowardriley's argument above.  Boiled down: "PLs have grammars; FLs have grammars; therefore, PLs are FLs".  The formal name for this basic error of logic is [[Fallacy of the undistributed middle]].  My students would get slapped down hard for such an obvious mistake. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 23:18, 4 November 2007 (UTC)

::::I'm not reading the article as an editor; I'm reading it as a Wikipedia reader. Moreover, I'm reading it as a non-expert reader, expecting the article to re-enforce the introductory exposure to programming languages I received in school, then add something new. If you believe that Wikipedia articles should be [[Wikipedia:The perfect article|clearly expressed for both experts and non-experts in appropriate detail]], then you should reconsider the article's overall structure. Regarding my "[[Fallacy of the undistributed middle]]", I wasn't making a statement like you reworded my quote to be; instead, I was asking a question. And your harsh ("slapped down") and demeaning ("obvious mistake") response to my question says something about your needing [[tact]], towards both Wikipedia talk participants and your students. An appropriate answer to my question would have been something like, "Programing languages that support pointers are not formal languages because they can lead to runtime errors of null pointers." [[User:Timhowardriley|Timhowardriley]] 17:05, 5 November 2007 (UTC)

:::::I apologize for getting too snarky.  I was very annoyed at your initial [[WP:POINT]] violation in using a gratuitous {fact} tag as if it was relevant to a wording dispute.  I've seen that abuse of process far too many times to maintain much sympathy with it.  However, I cannot see why one passing factual clarification about the distinction between artificial and formal means we should reorganize the whole article.  It seems like a complete non-sequitor to me. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 20:47, 5 November 2007 (UTC)

::::A quick question for Lulu:  In my understanding, the reason that C is not a "formal language" is simply because it's semantics are defined by a prose document--specifically, an [[ISO]] standard.  While standards documents are generally written to be as unambiguous as possible, they still are [[natural language]]s and therefore informal.  The fact that certain programs are syntactically valid but semantically undefined shouldn't, AFAIK, enter into the equation.  Are you suggesting that formal languages cannot contain [[undefined]] behavior?  --[[User:EngineerScotty|EngineerScotty]] 17:16, 5 November 2007 (UTC)

:::::No, not exactly because of the prose documentation of semantics.  The more important issue is the ''undefined behaviors'' that most PLs have.  With undefined syntactic-valid constructs, a language does not always have "processable formulas".  Even if we narrow the sense to syntax alone, many PLs lack a precise syntax definition... except in the roundabout sense that "Perl is the language recognized by the current Perl runtime" (similarly for, e.g. Python, Ruby, etc. which have multiple implementations that differ at their margins).

:::::I really don't get why there is an objection to "artificial language", which means exactly and only what is being said in the lead... and the desire to substitute a term which is "mostly similar" that can only be shoehorned in with lots of caveats and exceptions. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 20:47, 5 November 2007 (UTC)

::::::Strictly speaking, a programming language having a grammar ''is'' a "formal language" in the technical sense: it has a set of symbols, and a set of formation rules (see [http://mathworld.wolfram.com/FormalLanguage.html here] or Wikipedia's own [[Formal language]] article). The technical definition of "formal language" says nothing about semantics, but only about syntax. However, in my opinion, calling a PL a "formal language" within the lead is misleading in the extreme, since the technical meaning of "formal language" is something which most readers will not understand. Furthermore, as LotLE rightly points out, there exist popular PLs which have a syntax that is implementation-defined, thereby rely on implicit formation rules expressed using the imprecisely-defined semantics of the implementation language, and are thus arguably not technically "formal". My preference is to stick with "artificial language" in the lead, since it says what needs to be said in a succinct and accessible manner. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 01:05, 23 December 2007 (UTC)

=== Abstraction ===
Allow me to bring the discussion back to my initial objection. (1) Dr. Linz published the following nutshell, "A formal language is an abstraction of the general characteristics of programming languages." This nutshell is obviously carefully worded to account for nuances. However, it <em>seems</em> to basically say that programming languages inherent the properties of formal languages.

:You are right, Linz chooses words carefully.  Likewise, we might notice that "Stick figures on signs are  an ''abstraction'' of the ''general characteristics'' of the humans represented."  The walking figures at cross-lights show a simplified form of bipedal walking; the standing ones on restrooms show a simplified form of gender differences; etc.  It is just as obviously wrong to conclude that "humans ''are'' stick figures" by identical reasoning. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 03:50, 6 November 2007 (UTC)

Therefore, if you understand the properties of formal languages, then you also understand the properties of programming languages.

:No more so than with stick figures! You can understand the properties of stick figures, and fail to understand many properties of humans.  You indeed can get the bipedal form; the general plan of two arms and two legs; the fact our heads are above our feet; where our major joints are; etc.  But there is still a ''whole lot'' left out by the abstraction.

(2) The wikilink to [[Artificial language]] does not address the nuances that seem to prevent the inheritance of all of the properties of formal languages to programming languages. Nor does the artificial language article address the nuances that seem to occur in programming languages that are absent from formal languages. More specifically, the artificial language article covers [[Constructed language]] — a language devised by an individual or group, instead of having evolved naturally — and [[Manually Coded Language]] — sign language. This nuance discrepancy prevented me from reading any further in the article, even though I am a highly-familiar, non-expert, adult-student of programming languages. I recommend that if the vast majority of properties of formal languages are also the properties of programming languages, then the article should start with formal languages and then branch off. Alternatively, the artificial language article should specifically address the balance of the missing characteristics. Dr. Mertz, please comment on my objections and consider them in any future edits of the article. [[User:Timhowardriley|Timhowardriley]] 22:58, 5 November 2007 (UTC)

:I agree that the article on "artificial language" could be expanded.  But the most important point, the contrast with "natural language" has always been clearly indicated. I also agree, of course, that "formal languages" are a very useful abstraction of PLs and other mathematical systems and reasoning.  But this article isn't that one, this one us about PLs, y'know the real existing ones... not only about a useful abstraction about them. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 03:50, 6 November 2007 (UTC)
{{talkarchive}}

== Programming language lists ==

{{Programming language lists}}
I've created {{tl|Programming language lists}} (seen at right) to collect the 4 lists that were all linked from each other. Please watchlist. Thanks. -- [[User:Quiddity|Quiddity]] ([[User talk:Quiddity|talk]]) 18:57, 14 June 2008 (UTC)

== Maybe A-class? ==
After changing a few formulations in the beginning, I came to realize I like this article very much. It is well done and properly layouted. Maybe this article should be considered for A-class after some reviews? ''<span style="color: #800000; background-color: #FFFFA0; padding: 1px 2px 3px 2px">Said: [[User:Rursus|<span style="color: blue">Rursus</span>]] [[User talk:Rursus|<span style="color: #800000">☻</span>]]</span>'' 12:20, 23 June 2008 (UTC)

:The A-class designation is decided by each involved WikiProject separately and requires at least two reviewers.  Some WikiProjects, such as WikiProject Computer science, are too small to support this kind of review process and so do not use the A-class designation.  I do not know if the Computing WikiProject uses the A-class designation.  --[[User:Slashem|slashem]] ([[User talk:Slashem|talk]]) 19:54, 22 July 2008 (UTC)

== Natural language comparison addition ==

This new text has been added repeatedly by an editor:

''While natural languages usually can be used as [[spoken language]], programming languages are meant to write carefully crafted programs that are feed to the machine for execution.''

To my mind, I cannot see anything useful that is added by this sentence, and several factual inaccuracies in the sentence as written.
# The use of [[natural language]]s as spoken languages is built into their definition, and a wikilink suffices.
# Programs written in PLs may or may not be:
## Carefully crafted
## Fed to machine for execution

Both things about programs are nice to do, but neither is part of the definition. Sloppy programs are still programs, and programs might only be read by humans, never executed.  The existing discussion seems to cover this matter more accurately already. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 22:39, 30 July 2008 (UTC)
:[[User talk:Lulu of the Lotus-Eaters]], I agree with your analysis. [[User:Derek farn|Derek farn]] ([[User talk:Derek farn|talk]]) 01:01, 31 July 2008 (UTC)
::I don't, that's why included the deleted text. I feel that there's a point not addressed in the article in it's current form.
::The article doesn't convey the idea of how PLs are used, what activity must someone perform to express a given meaning in language to "give instructions to the machine". Someone could get the idea that PLs are like [[Latin]], i.e. they're contrived and difficult but ultimately you can control a computer by giving it spoken orders, one by one.
:: Unfortunately this is exactly how is portrayed in popular culture. People could watch the [[I, Robot (film)|I, robot]] movie and come here to learn how to program a robot, and would leave exactly with the idea that you simply speak to the robot in a special way to tell it what it has to do. Go and read the article, there's nothing that would clear up such misconception. 
::You can disagree with the wording I used to express that idea, but I really feel that this point must be addressed, and we should agree on a way to include it. Thinking of it, a section describing the activity of [[computer programming]] (for which there's not even a link) would suffice. [[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 06:29, 31 July 2008 (UTC)
::Also, I've found that this sentence form the [[Computer program]] article contradict this view of programs as a mean to communicate algorithms between humans:
:::"a computer program does nothing unless its instructions are executed by a central processor."
::This should be clarified so that the two articles agree in what a program is meant to do.[[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 06:37, 31 July 2008 (UTC)

:::What is it that you perceive as not being covered, Diego Moya, by the first sentence of the article: "''A programming language is an artificial language that can be used to control the behavior of a machine, particularly a computer.''"
:::: What I perceive as not being addresed is certainly not covered by the first sentence, because what is not being covered is HOW "a programming language can be used to control the behavior of a machine", i.e. "what is programming". If you think that this article denies the idea that you can control a robot by speaking aloud in a programming language, you won't have a problem in telling me exactly what is the sentence or paragraph that contradicts it? Or explaining why computer programming is not mentioned even once. [[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 17:26, 31 July 2008 (UTC)
:::While movies are, no doubt, inaccurate in portraying programming, the meaning of a PL is not restricted to a particular difficulty or a particular syntax.  A variety of PLs have been proposed as being "close to natural language", and we may (or may not) see ones that are closer in the future. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 15:52, 31 July 2008 (UTC)
:::: Should I take it to mean that you *endorse* that computers can be programmed by speaking to them, and that usage is to be considered a PL? Because that's not at all supported by their definition in the article. Unfortunately it's also not denied, and I think that it should be (with all the pertinent qualifiers, of course).
:::: Certainly there have been attempts to produce PLs close to natural language (why aren't these attempts covered in the history section?, if think that's a big hole), but experts mostly agree that all of them fell sort (that's even in the article!): PLs and natural languages are in irreconcilable different categories. Evolution of PLs has only succeeded in adding abstraction handling, not "naturality", which would allow to "be ambiguous and make small errors, and still expect their intent to be understood". It might not be that in the future but at the point that you have something usable by a human that feels natural, it will no longer similar to a PL in the terms described in the article (semantics + syntax + type system + standard libraries). 
:::: So the article correctly describes the scope of what a PL is but it still doesn't show how a human use those elements to control the machine. We're putting the cart before the horse: it tells us about about what programming could be in the distant future, but it doesn't explain what programming is now. [[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 17:26, 31 July 2008 (UTC)

:::::I wouldn't mind an addition to the history section that mentioned the recurring goal of making PLs more like NLs.  Cited and neutral and all that, but I wouldn't mind citing someone who said that those attempts were generally unsuccessful.  However, to be slightly pedantic, you ''can'' program a computer by speaking even today.  There ''is'', after all, such a thing as voice recognition software, and some disabled programmers for example, have no other way of writing programs.  So it really just boils down to ''what'' you have to say to the computer to program it.  

:::::Indeed such speaking is not nearly as quick or effortless as in popular fiction, but there is no obvious dividing line between what you can do now and what some people hope will be possible in "future programming languages" in which "Computer: Go check my email for messages from John Smith, and for each message archive it if it is about last weeks meeting" would be a fine instruction.  In fact, that slightly structured command is not all that far from what some high-level libraries already do. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 22:01, 1 August 2008 (UTC)

===Definition of the topic in lead===
I've added a new section with a brief summary of the [[Computer programming]] article, and a accompanying new sentence to the lead. IMO this addresses the shortcoming that I explained above, and explains several used terms that were unexplained in the article.[[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 09:19, 1 August 2008 (UTC)

I find this addition to the lead to be confusing and unnecessary:

:"''[[Computer programming|Programming]] refers to the activity by which the language is used to detail the desired behavior in the form of a [[computer program|program]].''

It is strange to be reading an article on PL, suddenly to jump into a description of "computer programming" instead.  Obviously, there is a relation between the two topics, but we should keep this article on its own topic, not try to "transcluded" a different one. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 12:39, 1 August 2008 (UTC)
:I don't understand why you find it strange, given that "programming" contains half of the meaning of the topic at hand (and half of the name!), "language" being the other half. This second meaning is the primary (only?) focus of the article, while the first is mainly ignored. 
:I accept that maybe my additions, which were mainly definitions of the concept of programming, could not be the best way to portray the relation between "programming" and "programming language". 
:How would you explain this relation here?, because without that explanation, there's no context of how PLs are used. How would you approach the introduction of the terms "programming", "program", "programmer" and "software", which are used in the article without explaining their relation to the subject?  Please be constructive. It's difficult to evolve the article to cover a missing concept when every edit in this direction keeps deleted.[[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 14:02, 1 August 2008 (UTC)
:[[Derek farn]]: my addition was not a mere cutting and pasting of another article. It describes half the definition of this topic, which was undefined before.[[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 14:03, 1 August 2008 (UTC)

::I cannot see any real need to discuss or define "computer programming" as an activity in this article. There is already another article about that. 
::I think you commented somewhere, Diego Moya, that you wanted the "practical side" of this topic covered; to my mind, this is not a topic ''with'' a practical side in that sense.  PLs are an abstract creature, and the article should address the topic.  Perhaps the "See also" section would be appropriate to include a link to "computer programming".
:::I don't feel that this would suffice. If both you and Derek keep deleting all reference to way PLs are used without addressing my concerns, I will add a POV tag (weird for a technical subject, isn't it?), since your position is a particular POV and mine is not being covered: definitely should be a link to [[computer programming]], because now there isn't a way to get there from here; and PLs are created for a practical purpose (creating programs), which is not addressed in the Purpose section (only a vague "provide instructions to a computer" is used each time, never explaining how it's done).

::By analogy, the article on [[partial derivative]] is about the abstract mathematical creature and does not digress into discussion of the various and myriad uses the mathematical technique has in engineering, etc.
::: I would agree if this was an article about the [[Theory of programming languages]], which is a topic on its own. Until the two topics get separate pages, this article must be about the general topic of programming languages, not only the theoretical side. AFAIK partial derivatives were created as a mathematical tool; programming languages were created as an engineering tool, so I don't think that your analogy applies here. AND the general topic under which derivatives fall, which is [[Differential_calculus]] and is accessible from partial derivative, *does* cover its practical usage and significance.
::It appears that Derek.Farn at least, who has been a long-time and high-quality editor of this article, shares a similar opinion.  I'd like to hear from him (or other editors) at more length on this talk page, but I concur that the material that has been added is somewhat poorly written and does not flow well in this article. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 17:20, 1 August 2008 (UTC)
:::Yes, I would also like to hear his reasons. I've asked for your opinion on how my concerns could be expressed. If you don't mind maybe we could [[Wikipedia:Third_opinion|ask for a third opinion]]?  [[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 18:46, 1 August 2008 (UTC)
:::As I said earlier I agree with [[User talk:Lulu of the Lotus-Eaters]]'s analysis.  He is doing a sterling job trying to explain why your ([[User:Diego Moya|Diego]]) edits decrease the quality of the article.  [[User:Derek farn|Derek farn]] ([[User talk:Derek farn|talk]]) 20:34, 1 August 2008 (UTC)
::::Even if that were true, that explanations don't cover why you're deleting my edits instead of rewording them to your liking without destroying the ideas in them. Until now the only reason expressed to remove those ideas is a matter of opinion, in that this article shouldn't cover practicalities of usage, for which I strongly disagree. [[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 21:43, 1 August 2008 (UTC)
Since the only remaining opposition in linking to  (not elaborating about) [[Computer programming]] seem based on bad wording, I've been keeping trying with different wordings to see if someone is of your liking, or if you will mind to rewrite it. Is there a consensus that edits should be added to the article only after achieving consensus at the talk page? If not, I can't see why you're reverting every single addition I made to the page instead of just fixing the expressions you don't like in them. [[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 20:54, 1 August 2008 (UTC)

:As I have said, in my opinion, the correct weight for the association of PL with Computer programming is as a "See Also" link, which you have added.  It's not mostly about the specific wording, I just don't see the concept as sufficiently important to ''this'' article to be in the lead (conceivably a brief mention lower in the body though). <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 21:53, 1 August 2008 (UTC)
:: So your position could be summarized saying that programming is a tangential topic in programming languages, because PLs don't have a practical side? Forgive me, but that's extremely POV and doesn't do justice to what should be an introduction to PLs for a general audience from different angles. 
:: As I stated before, IMO a theoretical approach would be appropiate for the separate [[Theory of programming languages]] article but not for a general coverage that should work as a [[Template_talk:Introductory_article|trampoline article]]. The current focus of the article fails to [[Wikipedia:Guide_to_writing_better_articles#Provide_context_for_the_reader|Provide context for the reader]] (it should "state facts which may be obvious to you, but are not necessarily obvious to the reader", such that programming languages are about programming). 
::And your involvement in keeping the status quo based just in that opinion of yours is not helping to reach consensus about my concerns. I don't want to cite here all relevant Wikipedia policies that would support my posture about generalizing the current focus of the article, just notice that your opinion about what this article should be is IMO not what is expected for the entry point about this general subject.
::Just a final words to say that the article DOES work now in some way as a general introduction, it's just that it fails to cover some important points in that respect. I don't understand your negative to include those particular additions on the basis of your opinion of what the article scope should be. ([[User talk:Diego Moya|talk]]) 08:37, 2 August 2008 (UTC)

:::You have misunderstood the term [[WP:POV]], which is something slightly different in an editing context than in general usage; I'd recommend reading that guideline.  The current state of this discussion is that two long-term editors on this article do not believe the addition you propose improves the article, while you believe it does. Perhaps rather than restate my opinion (which I think I stated pretty clearly) you could seek involvement of other editors who might be persuaded to the relevance of your addition and/or try to explain in terms someone else finds convincing why you feel the side topic is relevant.  I just don't see it in what you've mentioned on this talk page, nor generally in terms of the article topic. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 18:28, 2 August 2008 (UTC)

I agree with [[User:Derek farn|Derek farn]] and [[User:Lulu of the Lotus-Eaters|LotLE]] that it's preferable to avoid getting into tangential definitions, particularly within the lead. As it stands, both the ''Definition'' and ''Purpose'' sections specifically mention the use of programming languages to write programs, and links to relevant articles that naturally consider the act of creating those programs. It would perhaps be helpful to link to the [[Programmer]] article within the ''Purpose'' section, since the word is used several times in a way that seems to assume its meaning is known to the reader. Similarly, there's perhaps scope for rewording a sentence somewhere in the ''Purpose'' section to make a link to [[computer programming]] (rather than a definition) fit within the flow of the text.--[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 00:30, 3 August 2008 (UTC)

=== Programs and machines ===

Speaking of tangents, I'm going to go off on one here, and suggest that we consider revising the first sentence slightly to read:
:''A '''programming language''' is an [[artificial language]] that can be used to write [[computer program|programs]] which control the behavior of a machine, particularly a [[computer]].''
My proposed addition is intended to clarify the fact that PLs aren't used to directly control machines, but rather to create (intangible) artifacts that control machines. Opinions? 
--[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 00:30, 3 August 2008 (UTC)

:I can see some merit in your revision, Allan McInnes, but it seems to miss the case of interactive shells.  One often uses constructs from programming languages such as Python, Bash, Lisp, Forth, etc. to perform machine actions, without ever saving a "stored program".  If you count Bash (as you should), I think I personally might write more code this way than in "programs".  Much of the time, the interactive actions are glorified calculator stuff, but I've also e.g. use interactive wrappers to peek and poke into machine registers and the like (i.e. low-level, "close to metal"). <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 01:14, 3 August 2008 (UTC)

::Yes, I gave the notion of interactive shells some thought as I put together my proposal. I don't see that they are excluded by the use of "program", only of "stored program" (which is a term that you've introduced). To take your bash example, the bash ''language'' doesn't "control the behavior of a machine", ''programs'' written in the bash language (be they a one-line imperative command, a dataflow pipeline of several commands, or a stored script) are the things that induce specific machine behaviors.
::That said, I'm not overly concerned if the lead stays the way it is (arguably, "programming languages can be used to control a machine" in the same way that "the English language can be used to communicate an idea"). I just thought I'd throw the proposal out there to see what the reaction was.
::--[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 03:20, 3 August 2008 (UTC)

:::I'm happy to agree that a one-line bash command is a "program" (since it is), but I wonder if you'd be trading one clarification for another confusion.  That is, I think many readers will assume "stored program" from "program", even though that's not really necessary to the meaning. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 06:12, 3 August 2008 (UTC)
::::You may well be right about the potential for confusion. As I said, I'm content to leave the lead as is for now. I appreciate your feedback though. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 06:30, 3 August 2008 (UTC)
:Good point [[User:Allan McInnes|Allan McInnes]], it is programs that control machines, not programming languages.  The only unease I have about your proposed correction is the link to [[computer programs]] implies that these are the only kind of programs.  Programming languages exist for writing non-computer programs for entities that are not computers.  We need an article for programs that include non-computer programs. [[User:Derek farn|Derek farn]] ([[User talk:Derek farn|talk]]) 09:59, 3 August 2008 (UTC)

::I share your unease Derek, which is why the text reads "program" instead of "computer program". Unfortunately, the only relevant wikilink I'm aware of leads to [[computer program]]. It would be nice to have a more generic "program" article that covers programming things like (off the top of my head)  automated looms, player pianos, automated test equipment, FPGAs (VHDL or Verilog are arguably programming languages), etc. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 21:20, 3 August 2008 (UTC)
::This is the kind of concerns I feel are under-represented or missing at all. By the WP style guide, all the content in the lead should be expanded later in the article according to its prominence. But the very first phrase which talks about how PLs "can be used to control the behavior of a machine" is barely addressed in the body of the article, only mentioned in very general terms such as "to provide instructions to a computer", never explaining how this is actually done. Just for the record, I'll put here [http://en.wikipedia.org/w/index.php?title=Programming_language&diff=229231843&oldid=228900837] a link to the changes I did to put that assertion in context by creating a new Usage section. Derek and Lulu felt that its content was not relevant. I'll try to rewrite it in terms of the interactive shell/batch processing modes suggested by LotLE and the distinction between programming computers and other kinds of machines, also hinted in the lead but never further developed. Even if a whole article is created later on this topic, it should also be explained here. Anybody can think of a programming language that's used to control a machine that is not a computer? [[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 07:40, 4 August 2008 (UTC)

:::You ask ''"Anybody can think of a programming language that's used to control a machine that is not a computer?"''. Several examples come immediately to mind: the programming for [[Jacquard loom]]s, the programming rolls for [[player piano]]s, the languages for early [[programmable calculator]]s (before they achieved the capabilities of small computers), and languages for [[programmable logic controller]]s (again, the early ones that were used instead of more expensive computers). Granted, most everythng that gets programmed today contains a microcontroller or microprocessor, because they're so cheap and flexible. On the other hand, programming any kind of [[embedded system]] is arguably not programming a "computer", if that term refers to general purpose computers. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 22:24, 4 August 2008 (UTC)
::::The Jacquard loom is the example usually given and I have used it in [[Program_(machine)]].  I have just stuck my neck out and added an example of a programmable device that I don't think contains a program.  What about programmable washing machines?  The [[washing machine]] article is not sufficiently detailed for me to cite it.  [[User:Derek farn|Derek farn]] ([[User talk:Derek farn|talk]]) 00:09, 5 August 2008 (UTC)

:::::That makes me think of other "special purpose" PLs.  Not sure what Derek farn's washing machine does, but for example, my microwave has the capability to defrost by running at N% power for X minutes, followed by M% power for Y minutes, then wait Z minutes, etc.  If I was able to figure out that programming language, I could instruct the machine to do those tasks :-).  While the microwave almost certainly nowadays has a general purpose CPU inside it, the ''programming language'' I use to instruct it is another example of a non-Turing-complete language. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> (signature previously accidentally omitted).

::::::Yet another example of a non-Turing-complete language that I've just come across: the [[G-code]] used to program CNC milling machines. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 00:57, 15 August 2008 (UTC)

== New Usage section ==

Here's a proposal to split the Purpose section in two, one dealing with how PLs are used and the other more focused in actually addressing their purpose:
<blockquote>

'''Usage'''
<hr>

Programming languages differ from most other forms of human expression in that they require a greater degree of precision and completeness. When using a natural language to communicate with other people, human authors and speakers can be ambiguous and make small errors, and still expect their intent to be understood. However, figuratively speaking, computers "do exactly what they are told to do", and cannot "understand" what code the programmer intended to write. The combination of the language definition, a program, and the program's inputs must fully specify the external behavior that occurs when the program is executed, to the extent allowed by the expressiveness of the language.

Programs for a computer can be [[Execution (computing)|executed]] in a [[Batch processing|batch process]] without human interaction, or the [[programmer]] can use the programming language to write [[Command (computing)|commands]] in an [[Session_(computer_science)|interactive session]] of an [[Interpreter_(computing)|interpreter]]. When a language is used to give commands to a software application (such as a [[Shell (computing)|shell]]) it's called a [[scripting language]]. 


'''Purpose'''
<hr>

Besides the prominent purpose of programming languages to provide instructions to a computer, there have been attempts to design one "universal" computer language that serves all purposes, although all of them have failed to be accepted in this role.
...
</blockquote>

The rationale to split the old section it in two is that the bits about "a greater degree of precision and completeness" aren't really about the purpose of the language. I've added the explanation about interpreted vs batch-executed programs that you were talking about above.

I've qualified the "must fully specify the external behavior that occurs when the program is executed" phrase with "...to the extent allowed by the expresivity of the language", since the external behavior is not fully specified by the program (the platform on which it runs also defines much of the behavior, and there a lot of intangibles such as performance and usage of resources). I've also dropped the "many languages have been designed from scratch..." since I can't see how it relates to Purpose, or otherwise provide relevant information. Please comment what do you think or how would you handle adding this information. [[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 13:55, 4 August 2008 (UTC)

==Machine==
I have just noticed that the article on [[machine]] excludes computers (in the first paragraph no less).  Computers have the necessary attributes to be included within the set of entities covered by the subsequent listed properties of a '''machine'''.  I think it is the machine article that needs correction, not the programming language (or other computing related articles) that use the term ''machine''.  Help in arguing my case most welcome.   [[User:Derek farn|Derek farn]] ([[User talk:Derek farn|talk]]) 00:17, 5 August 2008 (UTC)

=="Measuring language usage": Clarification, please==

I'd like to see something more definitive on prevalence of various programming languages. The section "Measuring language usage" does say<blockquote>"It is difficult to determine which programming languages are most widely used, and what usage means varies by context"</blockquote>however, "difficult" is not the same as "impossible" or "meaningless". Can we either give ''some'' kind of estimates here, even if qualified, or explicitly state that the question is so "difficult" that it is in fact impossible or meaningless for our purposes. Thanks. -- [[Special:Contributions/201.17.36.246|201.17.36.246]] ([[User talk:201.17.36.246|talk]]) 17:01, 13 August 2008 (UTC)

:I would ''greatly'' prefer to avoid any estimates of the popularity/prevalence of particular languages.  This article should be about general concepts, specific languages are sort-of incidental to this.  It would be fine to put such estimates in, e.g. the article on [[Java (programming language)]] or [[Haskell (programming language)]], since popularity is an attribute of those languages themselves.  Such rankings are just "interesting trivia" from the perspective of this article, not encyclopedic content. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 17:22, 13 August 2008 (UTC)

:I would also like to see something more definitive.  As the person who wrote much of the material in that section I wish it were more definitive.  Suggestion for how to make it more definitive most welcome.  [[User talk:Lulu of the Lotus-Eaters]], language popularity is an issue that is frequently asked about and it is a general, non-trivial, concept.  The existing material discusses the various ways of measuring language popularity and includes references to real counts and highlights the fact that popularity measurement can be answered in various ways, all subject to measurement bias.   [[User:Derek farn|Derek farn]] ([[User talk:Derek farn|talk]]) 18:23, 13 August 2008 (UTC)

::''Why'' do you want it more "definitive"!? What benefit would it provide to ''this'' article if we added "According to a study by A.Jones, C++ is twice as popular as Perl"? That sort of false specificity just detracts from the flow of the article... and balance would require citation of the dozen other studies that show varying results (perhaps because of using varying methodologies, such as those discussed).
::That said, if we provided ''footnotes'' do a few of those studies, perhaps attached to our brief descriptions of the several methodologies, I think that would be fine.  We shouldn't clutter this article, but letting readers locate an external source that, e.g. counts ads for programmers, shouldn't hurt. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 18:28, 13 August 2008 (UTC)
:::How could you disagree with the desire to make the contents of an article more ''definitive''?  If there existed an agreed upon method of measuring language popularity along with data meeting appropriate statistical significance, then it would be our responsibility to say so.   [[User:Derek farn|Derek farn]] ([[User talk:Derek farn|talk]]) 19:33, 13 August 2008 (UTC)
::::Well, yeah.  And if the moon were made of green cheese, I suppose that would belong in the [[moon]] article.  I don't see your point... the most definitely ''is not'' any "agreed upon method of measuring language popularity", and introducing one particular study among dozens or hundreds adds '''false specificity''' as I have written. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 20:04, 13 August 2008 (UTC)

:::::[[User:Lulu of the Lotus-Eaters|LotLE]], would you have any objections to a ''separate'' article on this subject? (Assuming that it met Wikipedia policies for verifiability, etc etc.) -- [[Special:Contributions/201.17.36.246|201.17.36.246]] ([[User talk:201.17.36.246|talk]]) 16:27, 20 August 2008 (UTC)

(out) I think an article along the lines of [[Measuring programming language popularity]] could well be encyclopedic.  Obviously, it would need the right tone, neutral citations, and so on.  I can imagine a reasonable article that perhaps had sections for different general methodologies, some data from particular studies under each methodology, that sort of thing.  If you create such a thing, I would certainly not mind including a relevant link. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 17:42, 20 August 2008 (UTC)

:Yes, that's along the lines I was thinking. I'm personally not competent to create it. But I think that it could conceivably be interesting. -- [[Special:Contributions/201.17.36.246|201.17.36.246]] ([[User talk:201.17.36.246|talk]]) 21:08, 21 August 2008 (UTC)

::Of course you're competent to create it! A first version need not be perfect.  For a stub, you could more-or-less just copy the section in this article, and start working on fleshing it out over time. Hopefully other editors would add to it.  Don't be shy, give it a try. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 21:21, 21 August 2008 (UTC)

== concept of translation ==

I am a lay person who is trying to understand the nature of programming
languages.  analogy to natural languages in general, and human language
(something I think I understand), is the most crucial to my understanding.  A
computer is this mysterious box with magical properties, and since so many of
the concepts are abstract, analogy to well-understood human processes becomes
even more important for the lay person.  Recently I have discovered the concept
of a relatively simple set of instructions, that a machine responds to.  I'm
speaking, of course, of machine language.  This article is the perfect forum to
cement the concept that, just as a human being has a native language, a piece
of hardware (the ever-magical computer) also has a native language.  Mentioning
machine language in the first paragraph may seem to some like an unnecessary
detail, but to me, a lay person, it is almost *the* crucial detail that enables
to imagine the workings of a programming language.  I am planning to add a
reference to machine language in the first paragraph.  If someone sees fit to
remove it, I hope the removal will not be done wholesale, but with an eye
toward appreciating that the primary goal of the lay person, in reading the
first paragraph, is to form a complete, if only very general concept, of what a
programming language is.

One person recently commented that it isn't true that all programming languages
must first be translated into machine language, but the only circumstance I can
think of where this isn't true is when a program is already in a machine
language.  <small><span class="autosigned">—Preceding
[[Wikipedia:Signatures|unsigned]] comment added by
[[User:Pooryorick|Pooryorick]] ([[User talk:Pooryorick|talk]] •
[[Special:Contributions/Pooryorick|contribs]]) 18:24, 13 October 2008
(UTC)</span></small><!-- Template:Unsigned --> <!--Autosigned by SineBot-->

:[[Scripting language]] are not translated to machine code, many programs (in many different languages) are [[interpreted]] directly.  To the author of the first paragraph: a machine language (or [[assembly language]]) is just another language and I think you are getting confused between the concrete behavior of a computer and the more abstract nature of evaluating the behavior of  program written in some language.  [[User:Derek farn|Derek farn]] ([[User talk:Derek farn|talk]]) 19:05, 13 October 2008 (UTC)

::Moreover, many programs never get near a computer at all.  I might write a program on the whiteboard to communicate ideas to my colleagues.  That's a computer program even if no one ever compiles or interprets it to a specific machine.  Interesting question: has anyone ever written an explicit programming language (not just pseudo-code) that never had a compiler/interpreter actually developed to go with it? Even if we don't have an example, such would most certainly be possible conceptually. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 00:04, 14 October 2008 (UTC)
:::I believe that nobody has written a compiler/interpreter capable of handling the complete [[Pl/1]] language; they are all subsets.  I understand that the same claim could be made for [[C++]].  Probably not quiet the kind of answer you were after, but close(ish). [[User:Derek farn|Derek farn]] ([[User talk:Derek farn|talk]]) 00:33, 14 October 2008 (UTC)

:::One example of an unimplemented language is Landin's [[ISWIM]]. It's been quite influential, but has never itself been implemented. 
:::As a more general comment, I think the "machine language == native language" analogy is a bit misleading. Even native languages are acquired, rather than being built in. Furthermore, native languages and other acquired languages typically operate at the ''same'' level of abstraction, while the key difference between "machine language" and other programming languages that might get "translated" (elaborated is perhaps a better term) into machine language is that they operate at ''different'' levels of abstraction. If anything, "machine language" is more like the patterns of neuron firings that occur inside the brain, and over which native and acquired languages are overlayed. But I'm wary of that analogy too.  --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 02:06, 14 October 2008 (UTC)

Thank you for the thought-provoking responses.  Indeed, a scripting language
may not generate a single new machine instruction, but just triggers the
execution of preexisting machine instructions available in the interpreting
program.  As someone who wants to understand this field, I'm still struggling
with the first paragraph because I assumed that a computer language was the set
of instructions used to communicate with a piece of comptuer hardware.  It
turns out that a comptuer language may be a set of instructions to a piece of
computer hardware, or it may be a set of statements which can be translated
into a set of instructions to a piece of computer hardware, or it may be a set
of instructions to another program, called an interpreter.   The lay person
needs to know, right off the bat, that a computer language, might be one of
several things.  At the very least they need to know that a computer language
is not always understood directly by a piece of computer hardware.  I'll
probably ake a stab at this, but would appreciate any other attempts to make
the first paragraph a little more enlightening without going into too much
detail. [[User:Pooryorick|Pooryorick]] ([[User talk:Pooryorick|talk]]) 15:12, 15 October 2008 (UTC)
: I concur with that sentiment. IMHO this information should be located right before the second sentence ("Programming languages are defined by syntactic and semantic rules..."). How about a reference to the execution of the program? This concept is explained in the Usage section, but it should also be mentioned in the lead, like this:
<blockquote>A '''programming language''' is an [[artificial language]] that can be used to write [[program (machine)|programs]] which control the behavior of a machine, particularly a [[computer]], in a process called [[Execution_(computing)|executing]] the program.
</blockquote>
: This mention should be enough to convey the notion that programs follow some specific rules to control the machine; the following sentence then provides the detail that the execution is related to the properties that define the language (syntax and semantics). [[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 16:03, 15 October 2008 (UTC)

:Firstly the process of executing programs is a digression and something that is overly detailed to belong in introductory material.  The concept of program execution is covered in [[program (machine)]].  On a technical point, the term executing is not universal and the terms ''interpreting'' and ''run'' (to name two) are also used.  [[User:Derek farn|Derek farn]] ([[User talk:Derek farn|talk]]) 16:32, 15 October 2008 (UTC)
::Not sure if I'm following you. In which sense the term 'executing' is not 'universal'? And I can't agree that this concept is a digression: IMO, it is tied to the very core of programming languages - they are created for execution (if that were not the case, they'd be mere description languages, not programming ones). [[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 21:34, 15 October 2008 (UTC)
Continuing with these ideas, I just attempted another change, already reverted, but which I think has some merit.  The first paragraph mentions both "programming language" and "machine", implying an important and probably direct relationship.  I initially took this at face value, getting the wrong impression that programming languages are used to create instructions that a machine responds to.  The first sentence does not say that, and technically may not even imply it, but that's what I initially understood from it.  As has been shown in this discussion, the relationship between programs and computer behavior is not that tight.  First, a programming language might not even have an implementation, and second, some programs don't generate a single machine instruction.  In fact, some programs are written directly to control the behavior of other programs (a program written in Python controls the behavior of the program, "Python"), and only indirectly, control the behavior of the machine.  Currently the focus of the first paragraph is on "what", as in "what a computer language is", but a lay person often understands most qucikly what something is, but getting some glimpse of "how" it works.  The first paragraph does not currently convey what I, a newcomer to the subject, needed to know right off the bat to avoid misconceptions.  Responses much appreciated. [[User:Pooryorick|Pooryorick]] ([[User talk:Pooryorick|talk]]) 17:06, 15 October 2008 (UTC)

:I want this article (and all articles) to be formally and precisely correct.  An encyclopedia isn't a tutorial, but rather a reference work.  "How it works" is something better fitted to a tutorial.  In any case a "programming language" is a fairly abstract thing, and should be addressed at that level, but with wikilinks to appropriately more concrete topics that it touches on. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 17:21, 15 October 2008 (UTC)

::Is it formally correct to say that a program written in Perl controls the behavior of a machine when it really controls the behavior of the Perl interpreter?  Or is it formally correct to say that a program controls the behavior of a machine when an implementation of that language has never been written? [[User:Pooryorick|Pooryorick]] ([[User talk:Pooryorick|talk]]) 17:38, 15 October 2008 (UTC)
:::I see your point.  Likewise, a C program doesn't control the behavior or a machine, but rather the behavior of a C compiler (i.e. which bytes of machine code the compiler emits).  Do you have an edea for a different phrasing? Something more simple and direct, not a complex circumlocution. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 20:46, 15 October 2008 (UTC)
::::How about this?: '''The execution of a program produces effects corresponding to the meaning of its rules. Those effects can directly alter the state of the machine, or guide the sequence of instructions in another program.''' [[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 21:10, 15 October 2008 (UTC)

:::The answer to your question hinges on whether we consider "machine" to mean a piece of hardware, or to mean something a more abstract computational entity (like a [[Turing machine]]) of which the hardware is simply an implementation. If the latter, then it is indeed formally correct to say that a Perl program controls the behavior of a "machine", since the Perl interpreter may be considered a "machine". Such ideas become particularly relevant when you consider that the "machine language" of some processors is in fact a higher-level abstraction on top of an internal [[microcode]] program. That's kind of the point I was trying to make earlier when I mentioned that one of the key aspects of programming langauegs that differentiates them from natural languages is the layering of abstractions. The "target machine" for executing a particular program is an abstract computational model (a stack machine, a register machine, the Perl interpreter, the Java virtual machine, the Bash shell interpreter, the Matlab command environment, a database management system) that may be implemented in a number of different ways (as hardware - e.g. Java chips - as software that runs directly on hardware - the kind of programming you seem to have initially been thinking of - or as software that runs on top of other software). In the case of ISWIM, even though it was never implemented, the ''meaning'' of ISWIM programs was defined in terms of the way it controlled the (abstract, not-then-implemented) [[SECD machine]]. A programming language without semantics (i.e. without a definition of how its programs "control" some "machine") isn't a programming language, it's just a structured syntax. I'm struggling with figuring out how to get those ideas across in the lead in a way that the layman will understand... --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 23:05, 15 October 2008 (UTC)    

::To LoTLE: I agree that Wikipedia must not be a tutorial (i.e. a sequence of detailed instructions on how to a complete a task), but its explanation *does* need to be understandable by the [[layman]], as per the [[Wikipedia:Lead_section#Provide_an_accessible_overview|style guides]]. As Pooryorick pointed out, the current introduction doesn't accomplish that goal in it's current form. I'd rather go with the criteria of a novice rather than an expert about what constitutes "easy to understand" or "enough information to explain a concept" (or even "precisely correct!" ;-).
::And please allow me to disagree with you: "How it works" is '''exactly''' what should be in an encyclopedia; if you're going to say just "What it is", you'd better write a philosophy treatise. "How you'd do it" is what belongs in a tutorial, but explaining that programs are executed is not "unnecessary detail" nor "a step required to complete a task"; the execution process is essential to the concept of programming languages for automatic machines, and must be addressed in the lead. [[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 20:43, 15 October 2008 (UTC)

===The lead===
: After digesting the well-considered responses on this thread, it occurs to me that we might be having all this difficulty with the first sentence because, as LOTLE alluded, it needs less information, not more.  If a program doesn't necessarily have to be intended to control the behavior of a machine, but can just be used as a thought experiment, and some programming languages have never been implemented on anything other than a chalkboard, why not generalize the description to something easily understandable, and sufficient to describe all possible programming languages:
:*"A programming language is an [[artificial language]] which can be understood, either by a machine, usually a [[computer]], or by another [[program (machine)|program]]."
:This sentence contains a link to [[program (machine)]], which might be the ideal place to focus on just exactly what can be done with programs by machines, humans, or whoever, and this article can focus on explaining the defining characteristics of different categories of programming languages.  I also like this sentence because it uses the word "understand" which fits the idea of being a language better than "control", some programming languages being used for purposes of expression rather than control.
:This sentence also conveys the other key: a criteria for distinguishing a programming language from another kind of language:  It must, in theory, be understandable by a machine or, in a nice [[Godel_Escher_Bach|GEB]] play, by another program.  
:To Derek:  Might I suggest that it would be more appropriate to contribute productively to this discussion than to accuse me privately of vandalism?  <small><span class="autosigned">—Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[User:Pooryorick|Pooryorick]] ([[User talk:Pooryorick|talk]] • [[Special:Contributions/Pooryorick|contribs]]) 22:57, 15 October 2008 (UTC)</span></small><!-- Template:Unsigned --> <!--Autosigned by SineBot-->

::I would be fine with this minor change to the lead.  Not sure I'm convinced it is ''needed'', but I am at least convinced it is not objectionable.  However, I'd like to hear if some other experienced editors chime in (e.g. Allan McInnes or Derek farn). <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 05:21, 16 October 2008 (UTC)

:::I'm a bit iffy on the use of the word "understood": the whole point of a computer (or, in the abstract, of a model of computation) is that it ''doesn't'' "understand", it mechanically applies rules to transform symbols into other symbols. Programs are ''understood'' by people. They're ''executed'' (or evaluated, or run) by machines. I know that this is a somewhat pedantic point. I understand where [[User:Pooryorick|Pooryorick]] is coming from. I'm just concerned that in trying too hard to use the "language" analogy we'll end up misleading people. Granted, plenty of other lay explanations of programming languages seem to talk about computers "understanding" the language. Anthropomorphism is rife in computer science (I'm guilty of it myself on a regular basis). Which is why I'm "iffy", instead of flatly objecting. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 06:09, 16 October 2008 (UTC)

::::It goes the other way around, as well.  "Cybermorphism" is all the rage with some psychologists who draw on ideas emerging from computer science to advocate that humans are just glorified machines :) [[User:Pooryorick|Pooryorick]] ([[User talk:Pooryorick|talk]]) 10:10, 16 October 2008 (UTC)

By its very nature the introductory paragraph cannot be exact and will be open to several interpretations.  We could probably produce a very legalistic introduction that while being technically correct is completely incomprehensible.  The place to disambiguate possible interpretations of the introduction is in the body of the article.  The current introduction is straightforward and relatively easily grasped.  All of the proposals I have seen so far have introduced more problems than they have solved.  Let's leave the introduction alone and work on improving the body of the article.  [[User:Derek farn|Derek farn]] ([[User talk:Derek farn|talk]]) 11:13, 16 October 2008 (UTC)

:The problem is that the first sentence is demonstrably false in at least two cases (discussed above), and has potential to propogate misconceptions.  The following sentence avoids those two cases, conveys the essence of what a computer language is, and is more concise:

:*"A programming language is an [[artificial language]] which can be understood, either by a machine (usually a [[computer]]), or by another [[program (machine)|program]]."

:Allan expressed some unease about "understand".  The Wikipedia article, [[Understanding]] states that "somebody who reacts appropriately to X understands X", which fits perfectly with the way we are discussing using the term. The article does go on to say that this definition might be inadequate in light of the [[Chinese_room]] argument, but that argument is also highly controversial.  In light of that, does "understand" still sound iffy?  [[User:Pooryorick|Pooryorick]] ([[User talk:Pooryorick|talk]]) 15:54, 16 October 2008 (UTC)

::As I read the changed intro a few more times (with "understand" introduced), I like it less and less.  I said I was OK with it, but once it's there, I realize how bad it is to leave out any notion of computation (e.g. "instruct") from the lead sentence.  I'm putting back the version that's been here for a couple years or so (that resulted from a lot of negotiation and thought). <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 08:11, 17 October 2008 (UTC)

:::Trying again with:

<blockquote>A '''programming language''' is an [[artificial language]] that can be used to express [[Computation|computations]] which may be understood by a [[machine]] or a [[program (machine)|program]].</blockquote>

:::Is it any better? [[User:Pooryorick|Pooryorick]] ([[User talk:Pooryorick|talk]]) 13:44, 17 October 2008 (UTC)

::I like the inclusion of the word "computations" in Pooryorick's version of the lead here, but not the part including "understood" (the anthropomorphism thing).  I wouldn't mind just "''A '''programming language''' is an [[artificial language]] that can be used to express [[Computation|computations]].''"  Still, I'm really not sure why there is any need to change the lead sentence at all... it's starting to feel like looking for a change just for the sake of changing it.

Actually, this combining might be better:

<blockquote>A '''programming language''' is an [[artificial language]] that expresses [[Computation|computations]], and whose [[program]]s may be used to control the behavior of a [[machine]], particularly a [[computer]].</blockquote>

This has the computation part, which is precisely correct.  And it also mentions machines/computers.  However, the mention of programs (i.e. interpreters) being controlled is unneeded in the lead: an environment like Perl, JRE, a simulator, etc. ''is'' a machine (an abstract machine rather than a collection of silicon traces). <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 17:04, 17 October 2008 (UTC)

:::"Understand" may be too vague for comfort, but "control" is flat out wrong.  It's a subtle point, but language in general is not about control, and "programming language" specifically has broader use.  "Control" belongs in [[Program]], where it already is.  In fact, most of the first sentence (it's been reverted again) is already in [[program]], making it redundant (and unnecessary) here.   To be conceptually accurate:  "Express" (or "prescribe") is to "progamming language" as "control" is to "program (machine)".  "Control" really needs to go.  [[User:Pooryorick|Pooryorick]] ([[User talk:Pooryorick|talk]]) 19:03, 17 October 2008 (UTC)
::::But how do you manage the usage of programming languages in non-computing machines? I wouldn't say that a piano scroll "expresses" any meaning; the only thing it has in common with a computer language is that you can put it on a machine and it will follow a predefined sequence of operations. I don't see this basic idea clearly expressed in the article's introduction. Even if control is the nature of the program, it also affects the form and elements of the programming language - so it should be also mentioned in this article. Programs and their programming languages are both sides of the same coin. [[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 20:14, 17 October 2008 (UTC)


::::Perhaps "direct" instead of "control"? --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 04:49, 18 October 2008 (UTC)

== Missing the point? ==

''(Warning: car analogy below.)''

What would you think if an article about, say, [[engine|engines]] had a lead paragraph like this one?
<blockquote>
An engine is a [[mechanical device]] that can be used as a [[component]] when building a machine, particularly an [[automobile]]. Engines are built from [[statics|static]] parts and [[mobility|mobile]] parts, which hold their structure and provide their operational elements respectively. Many engines are [[mass production|mass produced]] (for example, [[General Motors]]); some are particularly built and tweaked for specific events (such as in [[Formula One]]).
</blockquote>

Old-time editors of that article would delete any attempt to add the concepts of 'energy' and 'fuel' to that explanation, on the basis that this is 'unnecessary', 'too much detail' or describing 'how it works'. The concept of 'movement' would be discarded because it is 'already covered in the linked articles' of "automobile" and "mobility".

Wouldn't you agree that [http://en.wikipedia.org/w/index.php?title=Programming_language&oldid=245658147 such introduction] could be somehow missing the whole point?
[[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 12:08, 16 October 2008 (UTC)


:Perhaps this will help. Here's a small selection of definitions from texts on programming languages:
:* Paraphrasing from Abelson & Sussman's [[Structure and Interpretation of Computer Programs]]: "''Programming languages'' (are a way of expressing programs that) prescribe the tasks we want our (computational) processes to perform. Computational processes are abstract beings that inhabit computers. As they evolve, processes manipulate other abstract things called data. The evolution of a process is directed by a pattern of rules called a program."
:* From Aaby's "Introduction to Programming Languages": "A programming language is a syntactic realization of one or more computational models."
:* From Moti Ben-Ari's "Understanding Programming Languages": "A program is a sequence of symbols that specifies a computation. A programming language is a set of rules that specify which sequences of symbols constitute a program, and what computation the program describes." or alternatively "A programming language is an abstraction mechanism. It enables a programmer to specify a computation abstractly, and to let a program (usually called an assembler, compiler or interpreter) implement the speciﬁcation in the detailed form needed for  execution on a computer."
:The common ideas seem (to me) to be:
:# PLs are a tool for specifying a computation (in a particular computational model)
:# PLs consist of rules that define how computations may be specified, and what computations can be specified 
:# PLs allow computations to be expressed in an abstract form
:Any thoughts? Other references? Alternative ideas? --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 21:14, 16 October 2008 (UTC)

::[[User:Allan McInnes|Allan McInnes]] some of your quotes material relate to programs rather than programming languages.  Programs are written in a programming language.  I don't understand the hangup on the first sentence.  It is a broad brush description of a programming language which subsequent material can flesh out. The bit about syntax/semantics was originally written by me and contained an analogy with human languages, the analogy part got edited out a few months ago in a discussion that seemed to want to throw away any connection with human analogies.  I could dig out the original words if people think it worthwhile.  [[User:Derek farn|Derek farn]] ([[User talk:Derek farn|talk]]) 22:36, 16 October 2008 (UTC)

:::Derek, I included the material about programs in the quotes I selected because the quoted definitions weren't given in isolation, but in the context of using PLs to write programs. I wanted to make sure that the context of the quote was understood. I'm not necessarily suggesting that any or all of these quotes is itself suitable for use in the lead. Rather, I'm simply trying to use the quotes to help identify what "the point" that [[User:Diego Moya|Diego]] thinks we're missing might actually be. 
:::Personally, I was reasonably happy with the lead we had before (which we've hashed over any number of times, and which I think does an ok job of covering ideas 1 and 2 above). But obviously some other editors are not happy with it, and I'd like to understand why they aren't happy so that we can either address their concerns or help them to understand why their concerns should not be addressed. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 22:46, 16 October 2008 (UTC)   

:::Allan, thanks for clarifying the point you wanted to make. [[User:Diego Moya|Diego]] has made some valid points and I would be interested to see some proposed wording from him.  My views on [[User:Pooryorick|Pooryorick]] are available on his talk page and I have stopped responding to this questions on this issue.  [[User:Derek farn|Derek farn]] ([[User talk:Derek farn|talk]]) 23:14, 16 October 2008 (UTC)

::Each of these definitions is more satisfying than what this article offers.  It's notable that they all avoid talking too much about computers. Thanks for putting these up.  They'll help shape the further evolution of the definition in this article.  [[User:Pooryorick|Pooryorick]] ([[User talk:Pooryorick|talk]]) 22:07, 16 October 2008 (UTC)

:The point I intended to make through my analogy is mainly that you can't talk about programming languages without talking about execution; this concept is essential to the purpose of PLs. Yes, you can use them to express algorithms precisely, but you could also use maths for that; what's unique to PLs is that they undergo an execution process, and that execution is what "controls a machine". This is what lead me to include some weeks ago some references to "programs" and the distinction between natural speak vs batch processes: human languages are intended for [[communication]] (having a sender, receiver and medium) while programming languages are intended for [[computation]] (having instructions and a processing unit). In that sense, the quotations by [[User:Allan McInnes|Allan McInnes]] are a step in a good direction.

:As I see it, this article suffers from a tension between two goals. On the one hand, [[User:Lulu of the Lotus-Eaters|LoTLE]] and [[User:Derek farn|Derek farn]] defend a vision of the article describing PLs as a general abstract concept applicable either to computers or  player pianos. On the other hand some of us have a sense that PLs developed mainly in relation to computers, and that the programs that can be written and their execution process are essential to understand the nature of the language. 

:We can speak about "programming languages" in general and "programming languages in computing". The contents in this article are primarily about the later; I don't feel that the sentence "some are defined by a specification document, while others have a dominant implementation" is valid if we are also speaking of a 19th century programmable machine. 

:The abstract meaning of PLs explains what Perl and the [[Jacquard_loom]] have in common. But I don't believe there is much to say about that pure concept, so I think the introduction should make explicit the distinction between PLs in the abstract and PL's evolution as applied to computing, and explain the computational/executable nature of the later (vs the communicational nature of natural languages). [[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 12:00, 17 October 2008 (UTC)

So, how about this wording? This defers the technical details about syntax and semantics to the second paragraph. The new sentences cover the ideas I've explained above. Feel free to reword it as you wish:
<blockquote>
A '''programming language''' is an [[artificial language]] that can be used to write [[program (machine)|programs]] which control the behavior of a machine, particularly a [[computer]].<ref>[http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=33636 ISO 5127]—Information and documentation—Vocabulary, clause 01.05.10, defines a programming language as: an artificial language for expressing programs</ref>. The purpose of programming languages is the description and automatic execution of [[computation]]s, as opposed to [[natural language]]s which serve as a communication vehicle between humans. Modern programming languages have evolved from the mechanisms that early automatic machines used to alter their working patterns. Their programs specified the particular sequence of actions that the machine must perform. This property is kept in programming languages, which allow for (flexible, <s>general, complex)</s> ways to describe processes.
</blockquote>

:I think the distinction made between programming and human languages is a false one.  Information is manipulated and instructions given in both languages.  At a stretch it could be claimed that comments were the computing form of human chit chat (ie, social conversation), ok a big stretch.  The evolution discussion is a side track and I don't think it is correct, software engineers are famous for reinventing wheels and being driven by immediate needs.  I like the second paragraph of the current article a lot, perhaps it should be moved to after the second sentence of the first paragraph (with the subsequent wording forming a new paragraph)? [[User:Derek farn|Derek farn]] ([[User talk:Derek farn|talk]]) 13:08, 17 October 2008 (UTC)
<blockquote>
The study of programming languages has been tied to the history of computers. Programming languages are defined by [[syntax|syntactic]] and [[semantic]] rules which describe their structure and meaning respectively. Many programming languages have some form of written specification of their syntax and semantics; some are defined by a specification [[document]] (for example, an [[ISO]] Standard), while others have a dominant [[implementation]] (such as [[Perl]]).
</blockquote>
[[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 12:21, 17 October 2008 (UTC)

=== References ===
<references />

== About "out of place and inaccurate"... ==
If we're aiming to include only the relevant and accurate content in the lead paragraph, I'd say that the "Some authors restrict the term..." and "Thousand of languages..." paragraphs have to go. Per [[Wikipedia:Lead#Relative_emphasis]], they should be in the introduction only if they were significant to the topic and extensively covered in the body, something which they're not. Turing-completeness is in no way a main subject in this article, only hinted at; and the creation of new languages is not mentioned again, not even once. [[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 21:33, 17 October 2008 (UTC)

== Lead section proxy ==

There have been several interesting suggestions in the previous discussions that could lead to a precise and broad cover of the subject in the introduction. But it's impossible for those ideas to take form in a well redacted, coherent text under the current policies that protect the article's contents in its current form by reverting any significant contribution. While that protection has merit in that it saves a version that has endured a lot of thought, it's also impeding any further evolution. New ideas have to be put in a draft form, mixed and relentlessly edited until something good emerges. And that's simply not going to happen in the real article under these conditions.

To overcome that problem, I'm making here a copy of the lead section and intend to use it as a proxy to the real one, a place where to develop our half-baked, badly redacted attempts to include those desired concepts.

To all the interested in finding a better, more accurate and wider introduction to the article: here I'm asking you to follow the opposite approach, and be purposely inclusive. You can reword and reorder ideas as you wish, but try not to remove any of them. We'll see what emerges from this exercise and whether something can be made of the proposals listed above. Will have time to select the best picks if there's something usable for the article. [[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 02:39, 18 October 2008 (UTC)

:Good idea Diego. I've modified the proxy lead slightly to better reflect the actual structure pf the article (which seems reasonable, since the lead should in some ways summarize the article). I'd like to see the syntax/semantics paragraph expanded slightly to clarify exactly what's meant by "structure" and "meaning", but don't have time to wordsmith it right now.  --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 05:21, 18 October 2008 (UTC)

:It is a good idea.  I want to point out that the vast majority of this article is about the kinds of abstractions found in programming languages.  The abstractions are what is of interest in a programming language, and why, even though programming languages can trace their roots to low-level efforts to control machines directly, The fact that programs can influence programs, rather than just physical machines, opens up new universes of possibilty.  People who want to know the nuts and bolts of the relationship between program and execution can go to [[Program]], but here we want to explore what abstractions can be employed to better communicate with machines.  Consider that programming languages evolve considerably more rapidly than the instruction sets they ultimately employ.  language (abstraction) has a life of its own which transcends its various uses.

<blockquote>
"By relieving the brain of all unnecesary work, a good notation sets it free to concentrate on more advanced problems, and in effect increases the mental power of the race." -- A. N. Whitehead (http://sol.cs.trinity.edu/About/The_Courses/cs301/camn/)
</blockquote>

=== Programming language ===
A '''programming language''' is an [[artificial language]] that can be used to construct [[program (machine)|programs]] which direct the behavior of a machine, particularly a [[computer]].<ref>[http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=33636 ISO 5127]—Information and documentation—Vocabulary, clause 01.05.10, defines a programming language as: an artificial language for expressing programs</ref> Programming languages are also used to facilitate communication about the task of organizing and manipulating information, and to express [[algorithm]]s precisely. 

A programming language provides a structured mechanism for defining pieces of data, and the procedures or operations that may be carried out automatically on that data. Higher-level languages allow a programmer to combine several simple operations on a piece of data into a single more complex operation, which makes that task of creating complex programs easier.

Programming languages are defined by [[syntax|syntactic]] and [[semantic]] rules which describe their structure and meaning respectively. Many programming languages have some form of written specification of their syntax and semantics; some are defined by a specification [[document]] (for example, an [[ISO]] Standard), while others have a dominant [[implementation]] (such as [[Perl]]).   

The earliest programming languages predate the invention of the computer, and were used to direct the behavior of machines such as automated looms and player pianos. In the wake of the invention of the modern digital computer thousands of different programming languages have been created,<ref>[[2006|As of May 2006]] [http://hopl.murdoch.edu.au/ The Encyclopedia of Computer Languages] by [[Murdoch University]], Australia lists 8512 computer languages.</ref> with more being created every year.

=== End of the Lead section proxy ===

=== References ===
<references />

== Programming Language ==

I took that "created by people" part directly from the first sentence of artificial language :)  Anyway, how do you justify transcluding the definition of [[program (machine)]] from the first sentence of that article without transcluding the definition of artificial language?  Seems rather arbitrary to me.  [[User:Pooryorick|Pooryorick]] ([[User talk:Pooryorick|talk]]) 17:52, 18 October 2008 (UTC)

:As you've stated and shown in this discussion, you are new to this topic while a number of existing editors (including me) are very familiar with it.  Trying to edit based mostly on what you personally are ignorant of isn't really a good plan.
:The "artificial language" part is important inasmuch as it contrasts with [[natural language]], but is not of sufficient centrality to elaborate in the first sentence.  In any case, an artificial language need not be created by people; that addition is just plain factually false.  In particular, it is well possible (and even happens) to construct a PL programmatically rather than by hand (by people).  Maybe I'll go try to fix [[artificial language]], but that's a different topic.
:The relation to [[program]] however is much more central.  A PL in which no programs are written is theoretically possible.  I could perfectly well write down an arbitrary BNF grammar without ever writing anything that conforms with it.  But more sensibly, the whole purpose of a PL is to let us ''write programs in the language''.  For that, a brief explanation of what a program is is needed in the first sentence (or at least first paragraph, depending on exact sentence structure).  There is no "transclusion" here, FWIW; I haven't read "program" for a while so don't know if it uses the same clause, but the point isn't to use or not use the exact same words but to explain what we need to for ''this'' article. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 18:01, 18 October 2008 (UTC)

::(Switching to third person to solicit participation) My guess is that [[User:Lulu of the Lotus-Eaters|LotLE]] is a computer scientist, and that's why he sees [[Program (machine)]] as being more central to the definition than [[artificial language]].  A [[Linguist]] (or [[Gerald_Sussman|Gerald Sussman]]) might see [[Artificial Language]] as more central.  Programming languages are interesting ''as languages'', regardless of who or what is capable of reacting to them.  As computer languages incorporate more abstractions, they become more interesting in their own right.  There are in existence today computer languages which could (and probably should) replace traditional mathematical notation.  If they were adopted for that purpose, it would become obvious, even to those trained only in computer science, that the transcluded definition of [[Program (machine)]] in the first sentence of this article makes the definition of programming language overly specific.  [[User:Pooryorick|Pooryorick]] ([[User talk:Pooryorick|talk]]) 19:30, 18 October 2008 (UTC)

:::FWIW, my doctorate is in [[Philosophy]], neither [[Computer Science]] nor [[Linguistics]].  But in a general way, I've studied more linguistics than CS.  It's hardly about my background though, but about presenting the important lead sentence about the topic (which has, after all, emerged over a lot of discussion over multiple years by many experts).  Note: I still don't understand why Pooryorick keeps claiming the clause about "programs" is transcluded when it ''does not'' seem to occur in the [[program]] article at all. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 22:21, 18 October 2008 (UTC)

::::The transclusion is from [[Program (machine)]], not [[Program]].  One of the links above was wrong (I've changed it).  Language is about expression, and mentioning control in the first sentence is misleading.  There's no reason other than an arbitrary POV to deem "program" more central to the topic than "language".  "Language", after all, is the noun, and program is merely the modifier.  Many experts over multiple years may, nonetheless, have not gotten it quite right, especially where any committees were involved.  Does anyone have any idea what [[User_talk:Derek_farn|Derek_farn]] means about having already discussed "computation" being undesirable in the first sentence?  [[User:Pooryorick|Pooryorick]] ([[User talk:Pooryorick|talk]]) 03:43, 19 October 2008 (UTC)
:::::I'm fine with the latest change.  Computation seems better to me than "control" (and it's the change I proposed above, or something close).  I think Derek farn might object because player pianos and looms (arguably) do not perform computations.  However, I think those are peripheral enough to be mentioned only in the history/background... and I think there is a reasonable sense in which you can argue that even those ''are'' computations of a special (non-Turing) sort. <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 04:01, 19 October 2008 (UTC)

:::::And neither do SQL statements express computation.  We have been here before, it is the [[declarative programming]] style that is being ignored here.  If you want to discuss edge cases, what about the set of instructions used to program a microwave or washing machine, are they programming languages?  [[User:Derek farn|Derek farn]] ([[User talk:Derek farn|talk]]) 08:13, 19 October 2008 (UTC)

::::::I am also fine with going back to the version that had been stable for a year or more.  I really don't see the necessity of change that a new editor who lacks a detailed knowledge of the topic seems to feel.  On the other hand, declarative programming indeed also expresses computation; [[Prolog]] is Turing-complete even, for example.  And the lambda calculus was invented specifically as an alternate approach to expressing computation from von Neumann machines (while being computationally equivalent).  I'd say even the pure relational calculus is also just as computational as anything else that isn't Turing-complete (i.e. SQL, albeit there are slight "impurities" in the SQL standard, but it doesn't affect this point). <font color="darkgreen">[[User:Lulu of the Lotus-Eaters|LotLE]]</font>×<font color="darkred" size="-2">[[User talk:Lulu of the Lotus-Eaters|talk]]</font> 08:24, 19 October 2008 (UTC)

:::::::Maybe there should be another article dedicated to computer programming languages.  It may seem reasonable to have this article be primarily about computer programming language, because without computers we wouldn't probably wouldn't be discussing programming languages at all.  By the same token, though, one would think that the [[Language]] article would be primarily about human language, but it isn't.  It turns out that [[Philosophy|philosophers]] and [[Linguistics|linguists]] want to study the phenomenon of language in a broader context, so you have to go to [[Human_language]], and even then you have to go further, to [[Natural_language]], if you want to read about the most common use of language.  There is a lot to discuss, philosophically, about programming languages which isn't necessarily of immediate interest to the typical programmer or even computer programming language designer.  The key element which distinguishes programming language from other forms of language is the consistency constraint.  Declarative vs, imperative, turing-complete vs. not turing complete, computational vs non-computational, etc., are all debatable dimensions, but the requirement of consistency is not.  If [[Computer_programming_language]] had its own article, this article could focus on the development and implications of a previously unknown language constraint.  <small><span class="autosigned">—Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[User:Pooryorick|Pooryorick]] ([[User talk:Pooryorick|talk]] • [[Special:Contributions/Pooryorick|contribs]]) 14:35, 19 October 2008 (UTC)</span></small><!-- Template:Unsigned --> <!--Autosigned by SineBot-->

==Abstractions==
To [[User_talk:Derek_farn|Derek_farn]]: How does the sentence "The [[Abstraction (computer science)|abstraction]]s present in the language allow a programmer to represent the concepts involved in a computation as a collection of the simple elements available (called [[language primitive|primitives]])" apply only to some languages? Can you provide an example of a language without abstraction and without primitives to express computations? [[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 11:55, 21 October 2008 (UTC)

:[[Assembly language]] springs to mind and [[declarative language]]s express the 'what' rather than the 'how'.  [[User:Derek farn|Derek farn]] ([[User talk:Derek farn|talk]]) 12:09, 21 October 2008 (UTC)
::Assembly language is an abstraction (in your linked article: "a symbolic representation of the numeric machine codes") over the microcode and physical wires & transistors contained in the CPU, and declarative languages also express computations (the "what" and "how" distinction is an explanation used in teaching, not a precise scientific definition). To edit the lead paragraph you should think about the core principles that underlie the languages design, not just the common programming practices and folklore. Your response doesn't justify deleting my general assertion about abstraction in PLs, I'm adding the paragraph back. [[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 13:09, 21 October 2008 (UTC)

:The definition of an assembly language very rarely includes a specification of how it must be implemented, ie microcode is irrelevant.  The "what" and "how" distinction is used in teaching because it reflects what happens in real world programming.  The "abstraction" paragraph reflects a very narrow view of what constitutes a programming language. [[User:Derek farn|Derek farn]] ([[User talk:Derek farn|talk]]) 01:44, 24 October 2008 (UTC)
::In what sense is it "narrow"? You should explain exactly what terms in the deleted sentence were narrow and which ones were invented, otherwise it's a weak excuse. You have an exasperating habit to delete content written by other people and justify it with overly personal opinions. Wikipedia policy is that to [[WP:PRESERVE|preserve information]]: to be a good editor you should strive to ''correct'' information you don't agree with, instead of destroying it. Please read and understand that linked policy before doing your next revert, in special the "attempt to correct the misinformation or discuss the problems first before deletion" bit.
::You say "some languages may not contain expressions", just right after agreeing that they "express algorithms  precisely". How exactly do they express without expressions? And on assembly, you're requiring it to have a specification of the microcode for it to contain abstractions???  Obviously it doesn't depend on the implementations details, that's the reason a primitive is an abstraction: it captures what every possible implementation of a specific "information processing" would have in common. Maybe you're the one with a very narrow view of what constitutes an "expression" or an "abstraction". Feel free to discuss the ideas contained in that paragraph, but please don't remove it unless you have a better reason that "I don't think it looks good" - elaborate your complaints in as much detail as needed to reach consensus. [[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 07:31, 24 October 2008 (UTC)
::And just for the record: the "task of organizing and manipulating information" is called a [[computation]], according to its definition in Wikipedia. [[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 07:46, 24 October 2008 (UTC)

:::You are making a joke surely? [[expression (programming)]] means something very different than what is implied by the word "expression".  The article [[computation]] does not contain the words you claim it does (and neither does the wiki dictionary).  As for the [[microcode]] discussion, there is no requirement that any assembly language be implemented in microcode. [[User:Derek farn|Derek farn]] ([[User talk:Derek farn|talk]]) 12:18, 24 October 2008 (UTC)
::::Surely [[expression]] is not the same as [[expression (programming)]], but an introduction to a general article doesn't use words at its most technical meaning, as their audience is the general population. Any synonym would convey the same information, as long as the idea is conveyed that languages have compositions of simple elements. (And still, I can't think of any programming language that doesn't have [[expression (programming)]]s, as even visual languages do have them. Can you name one that doesn't? Anyway that's not relevant to my argument).
::::I don't know why you think that describing any language as having abstraction is narrow, and my problem is that you deleted the paragraph without explaining it properly (you still haven't: microcode is just *one* possible way to implement assembly, there are others, and the assembly operators are abstractions of all them).  The  "task of organizing and manipulating information"  is not in the [[computation]] article, those are your words for [[programming language]]; computation says "any type of information processing", and that subsumes your definition. [[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 14:38, 24 October 2008 (UTC)

== Important ideas in the lead paragraph ==
I've recovered [http://en.wikipedia.org/w/index.php?title=Programming_language&diff=246713303&oldid=246713095 the previous existing lead paragraph]. It's a good idea trying to simplify that complex wording, but the definition "expressing computations" shouldn't be lost as it's better than the very imprecise and meaningless "communication, with a machine". 

The ideas that a simplifying rewrite should retain, as per current consensus between the contributors above, are:
* Programming languages are artificial languages,
* which are created with the explicit purpose to express computations (which are abstract information processes),
* in the form of programs
* which are executed automatically in a machine.
* They can also be used to communicate between humans, because they are the most precise form to express algorithms.
* Every programming language has primitive constructs that, combined, describe data and data transformations (operations). (Note: declarative languages are not exceptions to this rule, their transformations describe what combinations and filtering of old data need to be used to create new data. Think of "computation" - which is 100% applicable to them).
* This combination of simple primitives to express new meaning is an abstraction process. The primitives are abstractions over the details of the machine.
* The existing primitives and their properties, their meaning, and the allowed ways to combine them are precisely specified through the syntax and semantics of the language. 
* This specification may be through a document, or as a working environment (an implementation).
* Non-computer machines used primitive abstractions over physical mechanisms. Modern languages generalize the possibilities by using more powerful abstractions.
* There are thousands of programming languages.
Can you provide a simplified rewrite using all these ideas? That would be great. We can discuss the relative merits and importance of each single idea, but all them are covered in the previous discussions and have more or less been agreed upon. [[User:Diego Moya|Diego]] ([[User talk:Diego Moya|talk]]) 13:22, 21 October 2008 (UTC)

: Programming languages consist of a set of rules which govern the composition of instruction sequences ("[[computer_program|programs]]") which can then be executed by computers, robots or other automata. As such, they form an intermediate stage between the abstract formulation of a computing task (devised by humans), and the actual operation of the machine. To accomodate for the varied nature of possible tasks and the different hardware employed, literally thousands of different programming languages have been developed.

: All programming languages have in common primitive building blocks for the description of data and the processes applied to them (like the addition of two numbers). These primitives can be combined to implement [[algorithm|algorithms]] to solve more complex tasks, like calculating a trajectory. Since even the primitives are more "powerful" than the machine instructions of the CPU itself, a programming language allows a more abstract and simplified formulation of any computable problem than pure machine code.

: Since computers require precisely defined instructions, programming language specifications must be very strict and rigid. In cases where procedures must be communicated in such a manner, programming languages may also be employed from human to human.

Just a shot. --[[User:Syzygy|Syzygy]] ([[User talk:Syzygy|talk]]) 14:41, 22 October 2008 (UTC)
