{{User:MiszaBot/config
| algo                = old(180d)
| archive             = Talk:Software engineering/Archive %(counter)d
| counter             = 6
| maxarchivesize      = 150K
| archiveheader       = {{Automatic archive navigator}}
| minthreadstoarchive = 1
| minthreadsleft      = 8
}}

{{Vital article|level=4|topic=Technology|class=C}}
{{WikiProjectBannerShell|1=
{{WikiProject Computing|class=c|importance=high}}
{{WikiProject Computer science|class=c|importance=top}}
{{WikiProject Electrical engineering|class=c|importance=mid}}
{{WikiProject Engineering|importance=top|class=c}}
{{WikiProject Technology|class=c}}
{{WikiProject Software|class=c|importance=top|computing-importance=high}}
{{WikiProject Systems|class=c |importance=top |field=Software engineering }}
}}
{{Archives}}
{{Outline of knowledge coverage|software engineering}}
{{dashboard.wikiedu.org assignment | course = Wikipedia:Wiki_Ed/Rowan_College_at_Burlington_County/Society,_Ethics,_and_Technology_(Fall_2018) | reviewers = [[User:Leptitcharmeur94|Leptitcharmeur94]] }}


== Earlier Reference to term Software Engineering ==

An earlier reference to the term Software Engineering was recently inserted into the article.  This would be quite some news.  The initial link seems very complete and is a message from Bertrand Meyer himself on the usenet group comp.software-engineering in 1992.  In Bertrand's post, he references a "Letter to the ACM Membership" by Anthony Oettinger published in Vol.9, Issue #8 in Aug. of 1966.  Having access to the ACM archives, I searched for this letter extensively.  I could not find it.  I also searched the Internet, but could not find it.  Something of this importance needs a more formidable reference than a post in a usenet group archive.  If the "Letter" is produced, I am ready to include it in the article. [[User:Lwoodyiii|Lwoodyiii]] ([[User talk:Lwoodyiii|talk]]) 16:28, 14 April 2013 (UTC)

The book "Science of Computing: Shaping a Discipline" gives that citation by Oettinger in 1966; it's Communications of the ACM, 9(8), p.546 but those pages are missing from the digital library.  However I was able to find it also in CACM 10(10) page 605.  That's 1967 and by Oettinger again.  So the term was definitely introduced by Oettinger before the 1968 conference, and it was done in the flagship publication of the ACM.  I made a screen shot for you http://i.imgur.com/ZJy15Ij.png see the bottom part [[Special:Contributions/91.159.183.138|91.159.183.138]] ([[User talk:91.159.183.138|talk]]) 10:43, 29 August 2015 (UTC)

== Coined software Engineering ==

There is someone who coined the word software, as someone coined the world electricity. But no one has the right to claim a new term only with an Engineer after it. The word creation, development, making, designing are sometimes synonymous with the word Engineering. --[[Special:Contributions/108.162.136.215|108.162.136.215]] ([[User talk:108.162.136.215|talk]]) 08:28, 20 May 2015 (UTC)
:"Software engineers" are programmers. It's as simple as that. I know because I am one. We have to have this article because the term is in wide use, but to describe programmers as engineers is akin to describing a hairdresser as a keratin engineer. [[Special:Contributions/31.52.163.167|31.52.163.167]] ([[User talk:31.52.163.167|talk]]) 23:23, 23 February 2016 (UTC)

== Proposed merge with [[In-house software]] ==
{{Discussion top|Closed as '''no consensus to merge'''. Discussion begun 6 months ago, petered out with no consensus after 3 months. [[User:TJRC|TJRC]] ([[User talk:TJRC|talk]]) 23:06, 16 December 2015 (UTC)}}
Too minor for own article. Entirely lacks sources. Easily incorporated into target article. Another similar page, [[In-House Design]], redirects to [[software engineering]] as well. [[User:EvergreenFir|'''<span style="color:#8b00ff;">Eve</span><span style="color:#6528c2;">rgr</span><span style="color:#3f5184;">een</span><span style="color:#197947;">Fir</span>''']] [[User talk:EvergreenFir|(talk)]] <small>Please &#123;&#123;[[Template:re|re]]&#125;&#125;</small> 00:15, 3 June 2015 (UTC)
:{{reply to|EvergreenFir}}  '''Support''' In my opinion both [[In-House Design]] and [[In-house software]] are candidates for speedy deletion. They are both minor and easily incorporated to [[Software engineering]].[[User:Gpeja|Gpeja]] ([[User talk:Gpeja|talk]]) 23:38, 18 August 2015 (UTC)

:Would suggest merging into [[Software development]], which is broader and more appropriate. Since there is little to merge, it's probably more a matter of where to redirect both those articles. --[[User:Boson|Boson]] ([[User talk:Boson|talk]]) 11:13, 19 August 2015 (UTC)

* '''Oppose'''  [[In-house software]] is a small article, but it's a decent topic on the issues of build vs. buy vs. commission. [[User:Andy Dingley|Andy Dingley]] ([[User talk:Andy Dingley|talk]]) 11:53, 19 August 2015 (UTC)
::{{reply to|Andy Dingley}} In-house software is not a 'decent' topic if you mean by 'decent' requiring its own article. Topics such as [[Software#Types of software]] (including in-house, outsourced, off-the-shelf) or [[Software business]] or [[Software development]] or [[Software Engineering]] are convenient places for this small piece of information. If you are able to expand this topic and support it with [[Reliable sources]], it may become 'decent'. [[User:Gpeja|Gpeja]] ([[User talk:Gpeja|talk]]) 22:17, 21 August 2015 (UTC)
::: Thankyou for explaining the basics of Wikipedia to me. Are you equally experienced in the software industry? [[User:Andy Dingley|Andy Dingley]] ([[User talk:Andy Dingley|talk]]) 22:46, 21 August 2015 (UTC)
:::: Thankyou [[User:Andy Dingley|Andy Dingley]]. It seems I have a problem in attitude. What would be a constructive thing to do in this case? Please advise as an experienced Wikipedian. I've just joined this year and have no idea what is the proper etiquette in case of disagreements. [[User:Gpeja|Gpeja]] ([[User talk:Gpeja|talk]]) 19:13, 24 August 2015 (UTC)
::::: There is a big difference in WP between the qualities of an article and the qualities of a topic. If an article is poorly written, it's quite common for it to end up at AfD where the qualities of it ''as a topic'' are then judged. This generally gives the right result: WP thus focusses on notable topics, as intended. 
::::: One of the biggest questions in commercial software is the three-way decision between buying existing software, developing it in house, or having it developed externally. Million pound projects have to choose this on a regular basis, many do not choose wisely. It's a huge issue within IT management and within software engineering.  All three of these, and their overview, are excellent in-depth articles for WP that would be valuable articles to have afterwards. There is also a vast literature out there describing the trade-offs.  There's probably even an MBA course to be had out there, just on how to choose  (someone who was thought to reliably choose well would be a valuable consultant within the industry). 
::::: By all means, list these topics at AfD if you think they're not notable as topics and unworthy of effort to develop them as articles. But I think I know what the outcome would be. [[User:Andy Dingley|Andy Dingley]] ([[User talk:Andy Dingley|talk]]) 11:40, 29 August 2015 (UTC)
::::::Thanks for giving more explanation. This is part of my learning process as a new WP editor. It would be great help if you at least put a rough outline and your definition of in-house software. The first sentence now reads: "In-house software is a software that is produced by a corporate entity for '''purpose of using it within the organization'''. " This doesn't match what you described above. Your description is more about commercial software development process and its tradeoffs. As I see it, there is lots of commercial software out there that is combination of all of the above so there is no reason to describe in-house software by itself. It is more important to describe the decisions you mentioned as an important part of software development process. I am still curious and would like to understand your point of you and idea of this article. It would help me learn how to create a new articles and make sure they stay on WP. I know it is quite common for new articles to be deleted at first review. Is there an option to move this article in Draft of my (or the original author) space and work on it off line? [[User:Gpeja|Gpeja]] ([[User talk:Gpeja|talk]]) 00:56, 1 September 2015 (UTC)
::::::: "Commercial" software is misleading as a term, because software becomes commercial when it's either bought or sold. This could be an accountant buying software in, or it could be a software house developing it in-house and then selling it. As our distinction here is mostly whether to "develop in-house or buy the work of others", then commercialism isn't the crucial difference, means of creation is. Remember too that software can be sold as applications (things that are usable by users) or libraries (things that developers use to build further software on top of).  A software house might be writing an application for sale, thus needs to write it themselves so that they then own the rights to these sales (they're a developer, not a reseller). Yet they still have to choose whether to build the component libraries within it themselves, or buy them from others.   
::::::: There's also the question of whether [[open source software]] is "commercial" or not. For most practical purposes here it is, even if there's no bill to be paid for it. It has the same technical implications (to a consumer) as commercial software: it is produced by others, it is dependent on others, but it does not require an in-house development team.
::::::: "In-house software is software that is produced by a corporate entity" is correct, but it's not necessarily for use ''only'' within that organisation. It's produced to meet the software needs of the organisation (either to use themselves or to sell on), but it is not limited to ''only'' being used internally. The case of the software application developer building or buying in a database library etc. is a simple counter-example.  The distinction is about who ''builds'' it, not who ''uses'' it.
::::::: If you want a draft space to work in, I'd suggest just creating it under [[User:Gpeja/drafts/In-house software]] or similar. It's easy to move later, you can even do it yourself.  There's also the Draft: namespace, which is useful for very new editors who don't yet have the rights to create pages in most namespaces. [[User:Andy Dingley|Andy Dingley]] ([[User talk:Andy Dingley|talk]]) 09:09, 1 September 2015 (UTC)
::::::::[[User:Andy Dingley|Andy Dingley]] Could you please comment on the article [[Insourcing]]? It is a strange term I've never heard. There is a connection to what you described above but for the business in general not only software.[[User:Gpeja|Gpeja]] ([[User talk:Gpeja|talk]]) 00:49, 3 September 2015 (UTC)
::::::::: "Insourcing" and the variants "onshoring" and "backsourcing" are recent formations that are a reaction to the fashion (early 2000s) for offshoring and outsourcing, and the general failure of those approaches. Although they can be (but not necessarily) a form of in-house development, their key feature is that they're a ''movement away from'' some previous outsourcing effort. Insourcing usually means moving development in-house, onshoring to move it to a separate developer who is locally located in-country. None of these terms are clear or particularly trustworthy, because they're used by management without the technical nous to really understand the issue, or the precision in language to maintain the distinctions clearly.
::::::::: I've even heard the awful form "expatrisourcing" which meant convincing a UK development team to leave the country and relocate to Bulgaria, where they could do the same work and be paid less  (but would avoid the language issues of native Bulgarian developers). I still don't know if that was a serious management suggestion.
::::::::: In-house development is the process of development in-house. Doesn't matter whether it has always been done in-house, or if it is a recent change from development previously done externally. [[User:Andy Dingley|Andy Dingley]] ([[User talk:Andy Dingley|talk]]) 08:50, 3 September 2015 (UTC)
::::::::: Another aspect to "in house" development is the size of the house.  If a team within a large corporate builds some software within that team (usually by one person) rather than having it done for them by the corporate IT Services monolith, that too can be seen as "in house development", as opposed to having the official heavyweight process and team build it (I don't know of a specific term for this, but would be interested to hear one). There are lots of projects facing this as an issue too. Corporate IT departments are often regarded as slow-moving and inflexible, encouraging this lightweight in-team development. [[User:Andy Dingley|Andy Dingley]] ([[User talk:Andy Dingley|talk]]) 08:57, 3 September 2015 (UTC)
{{Discussion bottom}}

== Citations of [[Software Engineering Body of Knowledge]] ==

I updated [[Software_engineering#Subdisciplines]] section to follow SWEBOK more precisely. I think that unsourced statements poorly repeat what was said in 15 links of SWEBOKv3.

Please review unsourced statements and tidy citation syntax. [[User:Ushkin N|Ushkin N]] ([[User talk:Ushkin N|talk]]) 09:18, 24 May 2016 (UTC)

== Who coined the term? ==

According to ''Milestones in Computer Science and Information Technology'', entry on software engineering, Edwin Reilly cites historian Brian Randall as believing that the term came from Fredrich L. "Fritz" Bauer.  He says to see pp 1606-11 of ''Encyclopedia of Computer Science'' for additional reading, but my edition of that book is older and doesn't contain those pages.  [[User:Bubba73|Bubba73]] <sup>[[User talk:Bubba73|You talkin' to me?]]</sup> 00:07, 15 July 2016 (UTC)

:I've seen by RFC this come up under [[Margaret Hamilton]], as an article there was noted dubious in July 2016.  Here it appeared in [https://en.wikipedia.org/w/index.php?title=Software_engineering&oldid=639841486 Dec 2014] edit as "coined by" her, later shifted to "adopted the term" in [https://en.wikipedia.org/w/index.php?title=Software_engineering&oldid=678436342 August 2015].  Since 'used by her' is not notable to the topic, I have removed it from the article.    I think that the original mention of her as coining it was in error and this was simply a remnant of the error. [[User:Markbassett|Markbassett]] ([[User talk:Markbassett|talk]]) 14:53, 19 July 2016 (UTC)

:: p.s. I've also removed the photo of her that was put in on 14 Jan 2014 as the top photo with subtext of credited with inventing the term.  Again, legacy of an error propagated and later revised and ... just removing the mistake cleanly and completely. [[User:Markbassett|Markbassett]] ([[User talk:Markbassett|talk]]) 15:09, 19 July 2016 (UTC)

== Certification and Licensure ==
This article misses the fact that in the USA over 30 States recognize Licensed Software Engineers also know as Professional Engineers (PE).  The process started by finding a cadre of experienced engineers who were individually vetted by the Texas Board of Professional Engineers.  This group formed the majority of those who then went and helped NCEES create the PE Exam in 2013 <ref>https://engineers.texas.gov/software.html</ref> 

The path requires a minimum degree in Engineering (some states will allow ABIT <ref>http://www.abet.org/accreditation/</ref> accredited science such as Physics and Computer Science), five years of experience working under another PE, passing the Fundamentals of Engineering exam (thus allowing a person to say they are an Engineer In Training or EIT), a background check, five to nine references, and finally the Professional Software Engineering Exam. <ref> https://ncees.org/engineering/pe/software/ </ref>.  Keeping the license requires ongoing professional education.

This means that the individual is now legally and ethically obligated to follow and uphold the standards of a professional engineer in their actions and deliverables.  At least in Texas there are many PEs who have been stripped of their license and/or fined for breaking those rules.  This is a different level of professionalism than a certificate from IEEE or Microsoft. 
Don Gilman, PE, Texas and contributor to the national exam.
[[User:Uncleharpoon|Uncleharpoon]] ([[User talk:Uncleharpoon|talk]]) 19:38, 13 November 2017 (UTC)
{{reflist-talk}}
:{{u|Uncleharpoon}}, yes the article should mention licensing of professional engineers. There is an article on this, [[Software engineering professionalism]]. However licensing affects very few software engineers. The need for this licensure can be seen by looking at the number of people who take the exam. The NCEES offers the PE Software exam twice a year, in April and October. In April 2017 a total of 20 people took the exam.<ref>https://ncees.org/engineering/pe/pass-rates/</ref> In states that require it a PE is needed only for those offering themselves directly to the public in solo practice or a small partnership. If you work for a large employer you will be considered under the supervision of PEs at the company, and can call yourself whatever your company calls you.<ref>http://theinstitute.ieee.org/ieee-roundup/members/achievements/answers-to-faqs-about-software-licensing</ref>

:While the IEEE supports licensing, the ACM took a strong stand against it and withdrew from the committee, stating {{tq|"...the Council further concluded that the framework of a licensed professional engineer, originally developed for civil engineers, does not match the professional industrial practice of software engineering"}}.<ref>https://web.archive.org/web/20000815071205/http://www.acm.org:80/serving/se_policy/selep_main.html</ref> The Fundamentals of Engineering exam, usually taken by graduating students, covers material such as Properties of Electrical Materials, Engineering Sciences, Circuit Analysis (DC and AC Steady State), Electronics, Signal Processing, Power, Electromagnetics as well as material software engineers would be expected to study.<ref>https://ncees.org/wp-content/uploads/FE-Ele-CBT-specs.pdf</ref> No effort has been made to develop an FE exam appropriate for software development. Time that would need to be spent by students to learn the material to pass the current exam is much better spent on topics in software development. [[User:StarryGrandma|StarryGrandma]] ([[User talk:StarryGrandma|talk]]) 22:11, 14 November 2017 (UTC)
{{reflist-talk}}

== Dubious claim in history ==

I'm undoing a dubious claim in the history that [[Margaret Hamilton]] was the one who made up the term.  Frankly, there seems clear evidence in 1966 of the letter published by [[Anthony Oettinger]] leading to the 1968 NATO conference on the topic with it's report widely spread as the origin of the common usage, and also credit given to the extensive works of [[Barry Boehm]] for developing it but she does not seem to have any prominent published works on the topic during this period that would credit it's rise to her.   I see a  21st century claim by her, also conveyed via local paper and NASA 50th anniversary review of people, but not as a part of the publicizing work.  I think it possible the phrase occurred by others in the 1950s as a casual utterance but not part of the field development and perhaps she independently used it as well in the 1960s -- but that would be after Oettinger, and lacks the body of work that Boehm contributed so any mention would be after those two and with less coverage to reflect due prominence.  Jus put up some evidence prior to 1999 or please stop pushing the tale.  [[User:Markbassett|Markbassett]] ([[User talk:Markbassett|talk]]) 01:33, 1 December 2017 (UTC)

== Copyright problem removed ==

[[File:Copyright-problem.svg|32px]] Prior content in this article duplicated one or more previously published sources. The material was copied from: http://www.collegequest.com/how-to-become-a-software-engineer.aspx and https://www.worldscientific.com/doi/10.1142/S0218194099000358. Copied or closely paraphrased material has been rewritten or removed and must not be restored, ''unless'' it is duly released under a compatible license. (For more information, please see [[WP:COPYRIGHT#Using copyrighted work from others|"using copyrighted works from others"]] if you are not the copyright holder of this material, or [[WP:Donating copyrighted materials|"donating copyrighted materials"]] if you are.)

For [[WP:Copyrights|legal reasons]], we cannot accept [[WP:Copyrights|copyrighted]] text or images borrowed from other web sites or published material; such additions will be deleted. Contributors may use copyrighted publications as a source of ''information'', and, if allowed under [[fair use]], may copy sentences and phrases, provided they are included in quotation marks and [[WP:CS|referenced]] properly. The material may also be rewritten, providing it does not infringe on the copyright of the original ''or'' [[WP:Plagiarism|plagiarize]] from that source. Therefore, such paraphrased portions must provide their source. Please see our [[WP:NFC#Text|guideline on non-free text]] for how to properly implement limited quotations of copyrighted text. Wikipedia takes copyright violations '''very seriously''', and persistent violators '''will''' be [[WP:Blocking policy|blocked]] from editing. While we appreciate contributions, we must require all contributors to understand and comply with these policies. Thank you. <!-- Template:Cclean --> [[User:Justlettersandnumbers|Justlettersandnumbers]] ([[User talk:Justlettersandnumbers|talk]]) 12:22, 24 October 2018 (UTC)
{{talkarchive}}

The examples of alleged "stuffups" given here are only allegations - there is no evidence given, or links to anywhere we could find such evidence. I could just as easily claim that the Apollo space program was delayed for 3 decades due to continued software failures, or the Sydney Opera House had bad accoustics for the first 10 years of its life due to software failures... I remember a rumour about this one, but what's the point of sensational allegations without being able to verify it - that''s the way the tabloid media works, but not an encyclopedia. [[user:Graham Chapman|Graham Chapman]]

64.174.7.xxx

The bias is obvious!  The article assumes that software can be engineered and is written from the perspective of a software engineer wannabe.  There is some babble about complex project failures and the assumptions that the coining the phrase "software engineer" will save the day.

It is now 2002 and all the complex software failures cited from the 60s and 70s, have been superceded by much vaster fiascos.   Even accounting for the fact that most of the most complex projects are black programs operated by the U.S.G. and the failures which exist until some artist delivered a perceived solution to newly bald project managers desperately grasping at straws .... the commercial failures have been on a new modern scale as well.   See the Denver Airport fiasco and read the glowing articles about "software engineering" right up to admitting they were late and that it would not work well if at all ever.

Perhaps Salon.com carries some back issues?  I cannot believe that "Salon.com" citing this heavily non NPOV article which contains no sop to the future software artists and/or hackers who may encounter this article is viewed as a  good thing.   Does salon set the standard of expectation of  balanced treatment of <b>engineering</b> articles at this institution or does our own published NPOV?

Maybe we can wikify this article to some form of usefulness but the overall underlying bias makes me think it is more effective to refactor it a piece at a time, perhaps after some professional programmers show up to help out, assuming they choose to stick around after a link from [[software]] or [[software programming]] or [[software hacking]] or [[coding]] or [[hacking]] leads them to this policy non compliant dreck ..... worse!  Future programmers that I may be working with may read this useless shit and be impaired on my future projects!  This is disaster.   I go now to help correct or delete some of these existing links until we can perfect this trash. [[user:mirwin]]
----

Oh great, another kook to deal with.  The article you removed is pretty sloppy, but what you replaced it with was nothing but a personal screed that the whole field is nonsense.  Well it may well be, but it ''is'' a respected field of study that deserves to be covered in an encyclopedia along the lines of those who study it and write about it.  The fact that you are not alone in claiming that the field of study has been largely unsuccessful is something that ought to be covered, but that in no way invalidates the field of study itself, its definitions, its goals, or its methods.  It merely reflects that the field itself is still in its infancy.

There are ''lots'' of programmers here, as you might suspect with any net-based group.  I've been programming since 1979, and professionally since 1982, so I think over 20 years in the business qualifies me to say that your opinions here are not mainstream.  Software engineering methods outside of mere computer programming ''are'' discussed and used in every serious software enterprise, and are taken seriously by most. -- [[user:Lee Daniel Crocker|Lee Daniel Crocker]]
: So this might perhaps qualify you to come up with a list of these methods along with some explanations. The article as a whole needs more attention. --[[User:Hirzel|Hirzel]] 09:21 15 Jun 2003 (UTC)

----
Moved from discussion of the material and perspective of the presentation to personal attack in record time.  No offense mate, if you wrote the original dreck, anyone can have an off day.

Layman and practioners take many things seriously.  Do you personally know any "Software Engineer, PE"?  The term professional engineer in the U.S. refers to one licensed to certify that a engineering specification is adequate to protect the public safety and interest.

Perhaps we have a cultural deviation here, where do you reside and do you percieve the definition of "engineer" different there than from the U.S. 

I am familiar with the SEI.  They do a lot of good work but they are clearly advocates with a vested interest.  Certainly references to them belong in the material presented per NPOV from the view of a practitioner or fan of  "software engineering"  

In the U.S. we have "Sanitation Engineers" who are more highly paid than garbage collecters.  I am not aware of any states that license them as PEs yet but it may have happened  somewhere in our 50 different cultures. [[user:mirwin]]
------

"respected" by whom?

I used to believe in this field.  But note the incredible bias of its typical practitioners:  total failure "in no way invalidates the field of study itself, its definitions, its goals, or its methods.  It merely reflects that the field itself is still in its infancy."  This is like the dudes still looking for the particle in the accelerator that will a GUT suddenly appear.  

They never acknowledge the probability that their whole field is built on a set of wrong premises.  In this case, that "software engineering" is just "requirements engineering" with less accountability, more jargon, and absolute disconnection between the bodies of real people affected by actions of real users.  Thankfully, this point of view is in decline.  Most of us today would accept that a perfectly "engineered" video game showing how to turn ordinary household implements into weapons of mass destruction would be well within their paradigm, and the definitions, goals and methods that they use, but also would accept that it would be unlikely to be allowed to reach beyond such an "infancy" for various legitimate ethical and social reasons.

Any attempt to actually "engineer" software soon discovers that without the body references implied by the real fields of engineering (e.g. chemical, mechanical, electrical) there is no way to assess safety or closure problems.  Accordingly, the "field of study itself, its definitions, its goals, or its methods" is invalid ethically, invalid ontologically, and invalid bodily.

So, my position is that software engineering does not exist, cannot exist, is a marketing term for a marketing concept, and to those who believed in it, is a stupid attempt to impose simple models on complex processes.  It is just as absurd to talk about "requirements engineering" in any other field of design.  This entire characterization of the process of creating complex tools or instruments has been discredited thoroughly, along with the SEI CMM that helped spawn it.  There is no value whatsoever in the term or concept of "software engineering" excpet insofar as software is part of other, more operationally bound, forms of engineering.  One might as well call the field "persuading the paying client that certain of his requirements do not exist", i.e. marketing.

The reader is far far better off learning how to distinguish an [[ontological distinction]] from an [[operational distinction]] from an "ordinary" distinction, which will drastically aid their listening and understanding.  Also to have a general notion of [[risk]] and of [[philosophy of action]] so that they do not make the mistake of assuming that actions carry uniform risk to the user or their surroundings.  If we intend to introduce the rudiments of software design here, as we have started to do in [[object-oriented programming]], then we should employ those terms as much as we can, e.g. [[problem domain analysis]], [[legacy domain analysis]], [[solution domain analysis]].  We should certainly be sure to outline [[schema]] and [[ontology]] as applied to the process of laying out a software design itself.

But under no circumstances should we pretend that software "risk" or "benefit" can be assessed outside of a [[foundation ontology]] or [[political economy]].

The idea that software could be engineered to better and better meet user "requirements" until it became inseparable from their daily lives has been thoroughly discredited.  First by the sloughing-off by coders and users of all products of more disciplined processes, then by the failure of OOP to produce any "reusable components" outside the political standards process, then by the "dotcom boom" and the pending collapse of Microsoft once honest stock option accounting is in place.  

Personally, I think that the day that this Windows Religion collapses, to be replaced by many fragmented subsystems, and the day that the Web Religion collapses, it will be relatively clear that the so-called "engineering" was simply bending human belief systems to fit what the systems could do at the time.  That no "engineering" in the sense of taking state of the art science and turning it into practical or useful tools was occurring.  That the entire process is much more viral and organic and more like gardening.

And, likely, that the control subsystems and highly constrained simulations, e.g. of hardware that track its states in a device driver, will not be seen as any kind of "engineering", but rather, as Dykstra put it, "computer science" proper - creating mathematical models to closely model the real world.

It might also be seen, like economics, as a sub-branch of [[general systems theory]] or [[philosophy of action]].  But I wouldn't hold my breath.  More liely the terms "software engineering" and "requirements engineering" will die a well-deserved death together.

----

Here's the paragraph about the Australian failures.  Some of these might be good examples,
but they're certainly not as well known and central to the field as the ones mentioned,
and I don't know whether they led to advancements in the field or if they are good examples of failure of specific methodologies that would merit including them.  More info is needed about them; a merelist of screweps doesn't make a good article.  --LDC


Other big stuffups I know about, though they were from the 1980s and 1990s and they're all Australian:

* The automatic tollway in [[Melbourne]] was delayed a year due to engineering difficulties, but even with the delay the software wasn't ready and they couldn't charge tolls for the first three months of operation.
* The automatic ticketing system for [[Melbourne]]'s public transport was delayed for years because of software difficulties.  (It is still hated, but that has more to do with hardware and politics rather than strictly software).
* The combat system for Australia's [[Collins-class submarine|Collins-class]] submarines was so bad, it has had to be scrapped and replaced with an American system.
* The [[Jindalee Radar|Jindalee]] Over-The-Horizon [[radar]] project was delayed for years because [[Telstra]], who were contracted to do the programming work, couldn't get it right.  They were eventually sacked and [[Rockwell]] was given the contract.</i>
----
"In very recent developments (as of April 2002) apparently Texas is considering issuing the PE license for software engineers while California is considering outlawing the use of the term Software Engineer as a noun or field of employment."
*my money's on California - Texas wants this for military industrial complex reasons, as there has traditionally been little consumer or industrial software produced there that isn't ultimately destined for military use - the different character of the two regions' software industries might well be the cause for the difference.  Another view is that "Software engineer" is a military term, since only the military actually has a policy of uniform risk for all elements of a system, and can put a dollar price on a human users' life and admit it. 24
{{talkarchive}}

:''Software engineering is already as predicatable and reliable as many fields of engineering, such as space or biological engineering. Although large, reliable software systems can be and have been constructed, software projects that fail during construction or in service are still too common. However, large traditional engineering systems also fail, such as Three Mile Island, Chernobyl, Bhopal, Space Shuttles Challenger and Columbia, are also too common.''

There should be a reference/proof for the claim ''"Software engineering is already as predicatable and reliable as many fields of engineering".''  Without proof this sentence is a simple opinion and should be marked as such ("Some people claim..."). Also, it is debatable whether Chernobyl failed because of engineering problems.  In space engineering many problems (and at least one desaster) were caused by software defects. [[User:MH|MH]] 17:22, 17 Nov 2003 (UTC)

:Automobiles kill 40,000 people in the U.S. every single year. Automobiles and roads are engineered by automotive and civil engineers. Software has nothing that kills this many people. (There is a simple automotive fix to drastically cut the death rate: limit the top speed to 30 mph, which would be an easy engineering change. Compare this to GUIs being designed so that users cannot misuse them.)

:The space shuttle blew up because of bad O-rings, and bad foam insulation, which are engineered by mechanical and aerospace engineers. Software has nothing that is as bad. Okay, software blew up a few unmanned rockets, and sent a Russian landing capsule off course, but that is peanuts compared to the mechanical and aerospace problems. Mechanical and aerospace problems blew up many rockets and destroyed two manned space shuttles.

:If Chernobyl failed because of operator problems, then SEs can also argue that their software fails because of operator problems (users should just avoid the buggy parts and get training to know where the bugs are). Be fair in your comparisons.

:Software has many, many, many problems. But, at least SEs acknowledge our problems. All of the official reports about the space shuttle disasters point out that NASA engineers believe that they are perfect and have no problems to worry about, so they live in a state of denial. Traditional engineers have many, many, many problems, too.

:In some ways software engineers do things much better than traditional engineers. The rate that SEs create value by creating new features is tremendous. Compare the rate at which "safe" railroad couplings were added to the railway industry.

:I have often felt that aerospace engineers (most particularly) yell a lot about the failings of software, to turn attention away from their own failings. They use software as a scape goat. I know of only a few cases where software was implicated as the cause of a crash. Aerospace engineers caused all of the other crashes (exploding fuel tanks, worn out elevator screws, no stall prevention, and so on).

^ Why is that there? ^ - Please see [[Wikipedia:Talk page]] for guidance on the uses of talk pages. I can't see how the above is relevant to the development of this article. [[User:Angela|Angela]] 19:39, 20 Nov 2003 (UTC)

:The writer MH specifically mentions software causing problems for aerospace. Many of the authors prior to about Oct 2002 of this page emphasized the failings of software engineering, usually related to military or aerospace systems. The SEI is sponsored by the U.S. military and it created to CMM and CMMI as ways to "control" software development. There is clearly a long-term relationship between software and aerospace. But, you are correct.

:: The aerospace desaster I was refering to was the [[Ariane 5]] story.  But you are right that this discussion is probably not fruitful.  What I still think, however, is that the above claim "Software engineering already is..." is a broad , unspecific opinion which should be marked as such or be backed up by some (statistical, scientific) evidence.  On this talk page some people are discussing what software engineering actually is.  The claim above gives the impression that there is a consesus about that and that the process of building software is as well-understood as is building a bridge. [[User:MH|MH]] 08:46, 24 Nov 2003 (UTC)

----

I removed the following paragraph as the claims are unreferenced. Is there a source for this? As far as I was aware, such interests are increasing. Also, see [[Wikipedia:NPOV]] - you shouldn't really be claiming something is interesting to note as that's just your [[point of view]]. Others may think it completely boring to note. ;) [[User:Angela|Angela]] 19:39, 20 Nov 2003 (UTC)

''It is interesting to note that interest in quality is waning. The number of books and consultants talking about quality dropped by a factor of 3 from 1998 to 2003. Surveys have shown that quality is rarely the distinguishing factor in most markets. And certainly, quality cannot be considered independently of cost and value.''

:Noted.

----

I removed the following paragraph, because it has nothing to do with the '''practice''' of software engineering: it's just a list of kinds of software. [[User:Ed Poor|Ed Poor]]

:Software engineering applications include [[email]], [[embedded system|embedded software]], [[graphical user interface]]s, [[office applications suite|office suites]], [[operating system]]s, optimizing [[compiler]]s, [[relational database]]s, robotics controllers, [[video game]]s, and the [[world wide web]]. Other important applications include [[accounting]], [[airline]] reservations, [[avionics]], [[banking]], and [[telephony]]. These applications embody social and economic value, in that they make people more productive, improve their quality of life, and enable them to do things that would otherwise be impossible.

::I agree. [[List of software engineering topics]] is a better place for this. [[User:Angela|Angela]] 20:53, 20 Nov 2003 (UTC)

::I disagree. Many computer scientists (Dijkstra and Hamming come to mind) argued that software is not a tool for applications, but a tool for mathematics. Software engineers usually write particular kinds of applications, and I believe it is instructive to show the kinds of applications that software engineers do write. A counter example, is that "scientific simulations" are written by scientists: signal analysis from radio telescopes, simulations of heat transfer in the sun, and so on are NOT software engineering applications, they are scientific applications.

:::I still don't think it's necessary. It's just a list of software -we ''know'' they write software; you don't need to list every piece of software they might write. You might want to  [[Special:Userlogin|login]] by the way. [[User:Angela|Angela]] 01:14, 21 Nov 2003 (UTC)

::::You may know what kinds of software practitioners write. However the casual reader probably does not know. Is wikipedia a forum for experts to show what they know, or a forum for the non-experts to learn? BTW, consider myself a friend of hard-working SE practitioners and cute-and-fuzzy ones, so no login is needed.

::A previous commentator argued that there was no discussion of "humanity". This paragraph is the one place in the article where it is pointed out that software engineering is mostly applied on behalf of society.

----

Software engineering is all about productivity and quality. We could use monkeys to program machine code with toggles on the front panel of the computer, except that we want productivity and quality. That is what distinguishes software engineering from just a hobby.

^Again, this doesn't seem to be aimed at improving the article.

:The point is that there are many kinds of software. Software engineers emphasize some kinds, but not all kinds. Suggest that writing any kind of software makes one a software engineer demeans all software engineers. A feeble list of SE applications sheds a small amount of light on the subject.

:There are many skill levels of writing software. Hobbyists can write software using whatever approaches they want. But software engineering is a profession, where things like productivity and quality matter. In fact cost is one of the reason that software jobs are being exported to put SEs in the US out of work. Cost is a key component of both productivity and quality. Perhaps there should be a discussion of these issues.

:A second point is that while I believe that you know what software engineers do, I have been watching various newsgroup type exchanges (like at www.software-engineer.org) to see who wants to know about software engineers. Many of the questions are from high-school students, who are probably looking for something to tell a guidance councellor. I think that making the introduction to this article readable and understandable by a high-school student (who many not be aware of all the apps) is a good thing.

----

Ed Poor has made the following points: "I understand software engineering, as Bush might say: I /am/ one! ;-)" and "Moving an excellent list of "types of software" to talk for disposition) " and "(productivity and quality are not mentioned in the article, except in the first para, so I'm cuttin' 'em -- But people are important, so I'm a-puttin' 'em in.)"

Where as the phantom avenger of SE practitioners has argued issues such as "audience may not know what SE is", "productivity and quality are essence of SE", and "SE focusses on ... applications, is useful to non-experts"

This edit war has degenerated into stubbornness. Can there be any common ground?

:hey you stole my line! :-)

:But seriously, droids and perls, I'd L-O-V-E to find some common ground. C'mon, give us a hint... --[[User:Ed Poor|Uncle Ed]] 19:17, 5 Dec 2003 (UTC)

::I read your page, which I essentially agree with. I asked on village pump a few weeks ago about target audience for articles. They agreed that having an intro that "intellegent adults" could read was important. Alas, not much comment on how much readers should know about the subject

::I think the intro should be written for high-schoolers and the body for college students at the most. This does not mean being dumb. But rather to explain complex ideas so that many non-experts can understand them. The experts in SE will not read this page, because they know a lot more anyway.

----
Hum, this article is biaised, imho. For example, something like ''Few software engineers manage anyone, so they are not viewed as managers, except by themselves.'' in "management status" (SE vs Trad. E table) should be refactored a little bit... (Sorry, no time for now to read the entire talk page, so maybe someone else already said that, I'll come back later) [[User:Gbog|gbog]]

----
Note (for the record) my source for "only 28% succeed completely, 23% fail outright" the Standish Group, as cited by [[Robert X. Cringely]] in [http://www.pbs.org/cringely/pulpit/pulpit20031204.html this article]. I've seen broadly similar estimates from many sources. [[User:Dpbsmith|Dpbsmith]] 00:40, 23 Dec 2003 (UTC)

----
This article is an incredibly biased piece that presents itself more as the work of a frustrated student with an axe to grind against the industry and its professionals. There is little valid or useful information here and comparing "software engineering" to "computer science" is a bit off-point. They should be two seperate articles. I'm not about to jump into this snake-pit, but perhaps whoever does could start by looking through this Software Engineering document by the IEEE at [http://www.computer.org/tab/seprof/history.htm].

The first paragraph itself needs to be re-written. There is not enough fact and illustration and too much fluff and provocation and confusion. All that needs to be said as the introduction is something like ''"Software Engineering is, essentially, the application of an engineering discipline to the design, construction and maintanance of software"''.

''while emphasizing productivity and quality. In the year 2000, these technologies and practices encompass languages, databases, tools, platforms, libraries, standards, patterns, and processes.''

The above is superfluous. Software Engineering is precisely what I stated up above. While you would hope that software engineers emphasize productivity and quality, that isn't what software engineering ''is''. If it's necessary to include a list of ''elements of good work ethic'' like that, perhaps include it as a sub-section. Also, a bulletted list of related etchnologies and aspects should be listed rather than tossing them into the opening paragraph.

The history and prominent figures in software engineering should be expanded or a list of relevant links to them elsewhere on Wikipedia should be provided.

It would be wise to thoroughly study the Wikipedia article on [[Electrical Engineering]] for an example of how this entire article could be done better. Hopefully, by someone with non-biased knowledge of the field rather than a grumpy antagonist.

This article doesn't need to be an essay justifying or invalidating the field of software engineering. It just needs to be an article describing software engineering. This '''entire piece''' is ''Software engineering versus ...''.  What is the point of that? This whole thing reads like a first-year CS student's rant on Slashdot.

[[User:Cordell|Cordell]] 16:40, Dec 31, 2003 (UTC)
----

:Some key points in the article, that I have tried to keep are:
:*treat all SE practitioners with respect and dignity
:*explain basic SE concepts so high-school students might understand / choose this career
:*recognize that there are many points of view about SE

:Cordell is enthusiastic about the IEEE concept of software engineering, which is an important point of view. The "list of SE concepts" page has a number of links to IEEE documents. Certainly, the IEEE POV could be expanded.

:Unfortunately, Cordell argues that only the IEEE POV is correct. In the U.S., there are about 700,000 practitioners, of which about 25,000 belong to the IEEE/CS and another 25,000 belong to the ACM. This means that the IEEE represents only 3% of practitioners in the U.S. which is much too few to embody the only view. The ACM embodies another 3%, and has a right to advocate a different concept of SE. The rest are not accounted for. For Cordell to impose the IEEE POV on everyone else is arrogant. For example, I believe that SE is not a branch of traditional engineering, because there are so many differences between them.

:The first 4 paragraphs are "a bit of fluff" because they try to explain what SEs do in simple terms, without deciding whether SE is a branch of TE or not (i.e. without being pro or con the IEEE).
----

I don't mean to suggest that only the IEEE 'specification' is an appropriate one to depict a 'Software Engineer' with, but if you compare other entries for _fill_in_blank_ Engineer, they are more about what that profession entails rather than justifying its place in comparison to others. I may have read the existing Software Engineer article wrong, but it seems like 80% of it is comparing the field to other fields in such a way as to make it appear that software engineers are in need of a boost of self-esteem. Almost like a bowler trying to justify why his 'sport' is on par with basketball, boxing or track and field.

However, I find the "nyah nyah those aren't ''real'' engineers!" attitude insulting. Are you suggesting that only people who are directly applying mainstream science to a field are ''real'' engineers? So a civil engineer or transportation engineer is not a real engineer? Software engineering requires the implementation of mathematical and complex logical sciences.

The dictionary defines engineering as: ''the practical application of science to commerce or industry ''

How does software engineering not fit this? It ''is'' the practical application of science to commerce and/or industry. Or is the disagreement that ''well, most software engineers don't implement laws of physics, mix chemicals or build 3d representation of bridge struts with AutoCAD, so they're faux engineers''?

What else shall we label them, then? Software artists? Software technicians? Bit-flippers? Are you saying that it isn't appropriate to call someone an engineer simply because they didn't spend four years of their life in a university to get a fancy degree?

I'm just saying that this article has severe MPD. I'm not pushing the IEEE description of software engineering, but I'm a little put off at how most of the article as it currently exists is nothing more than a list of how software engineering isn't legitimate compared to, say, electrical engineering or raw computer science.

And yes, I know that I could rewrite it myself if I so desired, but I don't know that I could do a satisfactory job for the majority of readers, either. I'm merely trying to provide some reasonable criticism based on how the article came across to ''me''. This is certainly one of the more difficult articles to adequately form that I have seen on this site, so I do recognize the effort of previous editors/contributors on it.

Whether an individual wants to call it ''engineering'' or not, that's what most new-hire postings call them. It's what is used on resumes. It's what the industry seems to have settled upon. Thus, it seems reasonable to just accept it and move on with describing the career field rather than rambling on with its justifications.

And for the record, I *am* a software engineer myself. For a big unix OS developer. I personally don't care what you classify software engineers as or if they're 'inferior' to pure CS majors or other engineers. When it comes down to it, my software engineer's salary trumps that of any ''other'' engineers that I personally know. So I'm not going to get my undies in a twist over it. *grin*

[[User:Cordell|Cordell]] 22:34, Dec 31, 2003 (UTC)

----

Much of your criticism is based on the evolution of the page.
The original versions from before mid 2002, mostly
listed the failures and criticisms of software.
It treated SE as less than CS, CE, EE, and other fields.
Look at the first few comments on this page for examples
of concern about that emphasis.

This article has slowly evolved to be more of a compare
and contrast, between these fields, hopefully treating
SE on equal standing with these other fields.
I added much of that, and I agree that it reads
a little too defensively.
I agree that this article needs more evolution.

Yet, it should be noted that in late 2003 and early 2004,
SE is still defining itself. It is not clear whether SE is
a branch of traditional engineering or not. It is not clear
whether SE is a subfield of CS. Only a few years ago (1999),
SE was mostly thought of as a small branch of CS.

In the November 2003 ACM Software Engineering Notes, 2 letters
debated this point. Dr. William Griswold (UCSD) argued that
SE is a branch of CS and they must remain together for the
benefit of both. Dr. Peter Henderson (Butler U) argued that
SE must shun its failed CS legacy and become a part of
traditional engineering. Also the recent (Summer 2003)
CCSE curriculum proposal for undergrad SE programs contained
a long (in my opinion simplistic) compare and contrast with
traditional engineering.

For this article to clearly compare and contrast with other
professions makes this article very timely.

It should also be noted that 6 months ago (mid 2003), SE was
not listed on the main Wikipedia page, because some argued
that it was a fairly unimportant branch of CS (i.e. applied CS).
The discussion of these issues in this article was an important
part of getting SE its own entry on the Wikipidia home page.

A time will come, when (almost) everyone assumes that SE
stands on its own as a proud profession. But, such cultural
changes usually take many years. I suspect that the
current discussion will be timely for at least 5 more years.

As we learn to explain SE in its own terms, that explanation
should fill most of the article. I urge you to help expand the
discussion of what SE is, in its own terms, without referring
to CS or traditional engineering. The compare
and contrast with other fields will then become less important.

----

This article basically reads "rant, rant, rant, rant..." [[User:Fredrik|Fredrik]] 11:21, 18 Mar 2004 (UTC)

: What would you change to improve it?

::Rewrite it from scratch with a better structure, better focus and better wording. I can't say specifically how I'd change it before making a try, though, and I'm afraid that it probably won't happen. [[User:Fredrik|Fredrik]] 14:08, 2 Apr 2004 (UTC)

:::This illustrates one of the characteristics of Wikipedia&mdash;in my opinion, one of its ''strengths.''
:::Traditional encyclopedias tend to gloss over areas of controversy. A traditional encyclopedia would probably assign the article on software engineering to an author who had written a book or two in the field, and it would be written from a point of view that simply assumes the legitimacy and validity of the practice and proceeds to describe its history, schools of thought, etc. For example, the article in the current Encyclopedia Britannica is utterly uncritical. It simply states things like
::::"As a consequence, a new subdiscipline, software engineering, has arisen. The development of a large piece of software is perceived as an engineering task, to be approached with the same care as the construction of a skyscraper, for example, and with the same attention to cost, reliability, and maintainability of the final product. The software-engineering process is usually described as consisting of several phases, variously defined but in general consisting of: (1) identification and analysis of user requirements, (2) development of system specifications (both hardware and software),(3) software design (perhaps at several successively more detailed levels), (4) implementation (actual coding), (5) testing, and (6) maintenance."
:::The only hint of a critical point of view is the use of the word "perceive." But the Britannica does not address the question of whether the perception (as an engineering task) matches the reality; whether software construction is really analogous to skyscraper construction; and whether software construction as of 2004 is comparable in predictability, reliability, percentages of successes, and percentages of disasters to skyscraper construction as of, say, [[Empire State Building|1931]].

:::In other words, the traditional encyclopedia would discuss software engineering from the point of view of the software engineer (or teacher of software engineers).
:::In Wikipedia, it is difficult for an article on a controversial topic to reach a metastable state unless it makes it perfectly clear that the topic ''is'' controversial, indicating the nature of the controversy, and stating each major point of view in a way that is acceptable to those holding the point of view. This makes Wikipedia more intellectually honest than traditional encyclopedias. [[User:Dpbsmith|Dpbsmith]] 01:34, 22 Apr 2004 (UTC)

== what are you doing? ==
{{talkarchive}}

== Previous comments ==
*[[Talk:Software engineering/Archive 1]]
*[[Talk:Software engineering/Archive 2]]

== Profession? ==
Why is PROFESSION part of the definition ?
Ren Bach, Switzerland rrene@acm.org.

==Admiral Grace Hopper? Some justification, please==

I would like to see some explanation or evidence for the inclusion of Admiral [[Grace Hopper]] as a "pioneering software engineer." It's clear that there is at least some controversy over the term "software engineering," and naming her as a "pioneering software engineer" seems to me to be enlisting her on a particular side of that controversy. And I'm not at all sure she belongs there.

I'd like to see some quotation or published remark that shows that she used the term "software engineering" herself and showed an awareness of and alignment with the "software engineering" community and its concepts. 

The first Google hit on ''Grace Hopper'' is: [http://www.sdsc.edu/ScienceWomen/hopper.html Grace Hopper, Pioneering ''Computer Scientist'']; and the [http://www.cs.yale.edu/homes/tap/Files/hopper-wit.html Wit and Wisdom of Grace Hopper] page does not contain the word "engineering." [[User:Dpbsmith|Dpbsmith]] 20:55, 21 Apr 2004 (UTC) Neither does Wikipedia's article on [[Grace Hopper]]. [[User:Dpbsmith|Dpbsmith]] 16:58, 22 Apr 2004 (UTC)

Of course,  [http://www-groups.dcs.st-and.ac.uk/~history/Mathematicians/Hopper.html this biography] mentions that she was a "Research Fellow in Engineering Sciences," "Systems Engineer," "Lecturer at the Moore School of Electrical Engineering," "Fellow of the Institute of Electrical and Electronics Engineers," etc. so I can see how this discussion is likely to go... but of course, before "Computer Science" was invented in the late seventies... and much brouhaha there was about ''that,'' too... all computer stuff was considered to be a kind of electrical engineering. So she was an engineer... but was she a ''software'' engineer? [[User:Dpbsmith|Dpbsmith]] 21:06, 21 Apr 2004 (UTC)

I'm going to remove her name for now. Please put it back if you have a reasonable case for her inclusion. [[User:Dpbsmith|Dpbsmith]] 17:00, 22 Apr 2004 (UTC)

:How is it that you justify the other names in that list?   By what criteria does one determine who the pioneers are?  For example, what timeframes would be appropriate for the term "pioneer" to be associated with that list.  - [[User:Bevo|Bevo]] 18:42, 22 Apr 2004 (UTC)

::All I can say is that when I looked at the list of names, I thought "One of these names is not like the others, one of these names doesn't belong."

::The issue is not who's a pioneer. Admiral Hopper was IMHO certainly a computer pioneer. But I don't think she espoused the viewpoints usually associated with "software engineering." As for the other names on the list... I didn't really consider them. Since the article says that software engineering "emerged as a bona fide profession" starting in the mid-nineties, so I'd think anyone who was clearly identifiable as working in software engineering prior to the mid-nineties would count as a pioneer.

:Why did you leave the other mention of [[Grace Hopper]] in the article if you don't feel that she was a software engineer? - [[User:Bevo|Bevo]] 18:44, 22 Apr 2004 (UTC)

::Because I didn't notice it. Now you've called my attention to it, I see that the context seems to be merely the role of women in computing generally. It seems to me that the sentence says: Hopper and other women filled "programming" jobs during the "1940s, 1950s, and 1960s". It also, it seems to me, is saying that those decades were "the first several decades of software engineering."

::If ''all'' software writing done in the 1940s, 1950s, and 1960s was "software engineering," then certainly Hopper was a very notable software engineer. And indeed some parts of the article do seem to take the view that all software writing is software engineering. 

::However, I believe that the phrase "software engineering" these days usually carries some definite semantic baggage with it: it is a specific approach to the task of writing software. I think this is clear from other parts of the article. For example, one part of the article specifically classifies Edsger Dijkstra, Donald Knuth, and Alan Turing as ''not being software engineers.'' Hopper's most notable contribution might be the development of COBOL; Dijkstra's, the development of ALGOL. These are very parallel achievements and to me would suggest that they belong in the same category, as does Hopper's original background in mathematics.

::In other words, if "software engineer" is just a courtesy title for "good programmer," sure, she was a software engineer. But if "software engineer" means management techniques, adherence to well-specified methodologies, use of CASE tools, etc. then it's not so clear. [[User:Dpbsmith|Dpbsmith]] 19:29, 22 Apr 2004 (UTC)

:Perhaps [[Kent Beck]] should be removed from the list as well.  See especially SE pioneer [[David Parnas]] article http://www.xp2003.org/xp2002/talksinfo/parnas.pdf - [[User:Bevo|Bevo]] 02:42, 23 Apr 2004 (UTC)

Grace Hopper built the first compiler for the Mark 1, and compilers are probably the most important tools that SEs use. Also, she is famous for "it is easier to get forgiveness than permission" which is a very XP way of working. She did not set out to be a software engineer, but David Parnas probably did not set out to be a software engineer, either.

As for who should be on the list, that is an excellent question. The CS page debated a similar question for about 6 months last year. The criteria I used, was that I wanted 5 or 6 names from the [[list of software engineering topics]] pages that gave a sense of how big and broad the field is. Beck and Humphrey go together like yin and yang, showing opposite ways of doing process. Hopper was from the first generation, Beck is from "the most recent" generation. Once again, like yin and yang showing change over time. Boehm, Brooks, and Parnas are the heros from the first generation to meaningfully use the term software engineering. Yet, they are not the first generation to work on these issues, nor were they the last.

There are lots of ways to choose the top 5 or 6 names.

:It's not a question of "who's the top," it's a question of "what does software engineering mean?" And the more I look at this article, it seems to me that the article has a severe, severe problem. "Software engineering" is being used to mean at least two distinct things. 

* As an umbrella term, for anything having to do with the production of software
* As a specific term for a specific school of thought about the organization and procedures for developing software... a school that ''draws a distinction'' between engineering, science, art, and craft and distinctly ''advocates'' the use of an engineering model for producing software.  

:Now, the [[List of software engineering topics#Pioneers|Pioneers]] list from ''List of Software Engineering Topics'' obviously uses the "lumper" definition, as it includes [[Edsger Dijkstra]] and [[Donald Knuth]]... yet [[Software Engineering]] uses the "splitter" definition when it declares that Dijkstra and Knuth are ''not'' "software engineers," but "computer scientists." 

:Personally, when I look at the [[List of software engineering topics#Pioneers|Pioneers]] list, ''I'' certainly put Kent Beck, Grady Booch, Fred Brooks, Watts Humphrey, Winston Royce, Gerald Weinberg, Ed Yourdon in a different category from Backus, Dijkstra, and Knuth. And to me, Admiral Hopper belongs with the latter, not the former.

:The supposed definition that heads the article is no help. In fact it's a mess. It says "the profession concerned with creating and maintaining software applications by applying computer science." Now, the term "computer science" did not exist prior to, I dunno, the early seventies. It seems to me it's pretty hard to decide whether Backus or Hopper or the ALGOL folk can be properly described as "creating and maintaining software applications by applying computer science." It's even harder for me to figure out where, in "The Psychology of Computer Programming" (Weinberg), or "Handbook of Walkthroughs, Inspections, and Technical Reviews" (Weinberg) or "Extreme Program Explained" (Beck), you can point to an example of the "application of computer science." 

:Meanwhile, throwing in that term "profession" clouds the issue further. Someone who contributes to Linux without being paid for it is doing it for the love of it, and is therefore by definition an amateur. If software engineering is a profession, than most Linux contributors are not software engineers... at least not while contributing to Linux. That makes no sense to me.

:Anyway, I still think that if you write "Kent Beck, Barry Boehm, Fred Brooks, ___________, Watts Humphrey, David Parnas," that "Admiral Grace Hopper" is not an obvious fit.  

:Dpbsmith|Dpbsmith]] 23:18, 23 Apr 2004 (UTC)

::Do you consider the "Extreme Programming" methodology to be an engineering methodology? - [[User:Bevo|Bevo]] 01:04, 24 Apr 2004 (UTC)

:::An "engineering methodology?" What's that? My limited experience is that&mdash;outside of software&mdash;people who call themselves "engineers" don't talk about "methodologies." [[User:Dpbsmith|Dpbsmith]] 01:23, 24 Apr 2004 (UTC)

:::Indeed, I just checked:

:::* "aerospace engineering methodology" = 2 Google hits
:::* "chemical engineering methodology" = 28 Google hits
:::* "civil engineering methodology" = 7 Google hits
:::* "electrical engineering methodology" = 10 Google hits
:::* "mechanical engineering methodology" = 18 Google hits
:::* Your search - "Mining engineering methodology" - did not match any documents
:::* "software engineering methdology" = 5560 Google hits

:::I don't know exactly what that means, but it has to mean ''something.'' [[User:Dpbsmith|Dpbsmith]] 01:23, 24 Apr 2004 (UTC)

::::Read the article [[Methodology]].  Look at the use of the word in this [[Software engineering]] article.   Google for "engineering methodology" and I get 18,000 hits.  Google for the term "software engineering and methodology" and I get 19,300 hits. It's a well-established term. - [[User:Bevo|Bevo]] 01:36, 24 Apr 2004 (UTC)

::::I know what a "methodology" is. And I know what a "software engineering methodology" is. I am questioning the phrase "engineering methodology" because I don't believe that other branches of engineering indulge much in "methodologies."

:::::''All'' of the examples in the [[Methodology]] article refer to software engineering or project management, and if you changed the title to "Software Engineering Methodology," only two sentences would need rewriting.

:::::Change your Google search from ''"engineering methodology"'' to ''"engineering methodology" -software'' and the number of hits drops to 4560, most of which concern information systems or other computer-related topics. Change it to ''"engineering methodology" -software -information'' to exclude these and it drops to 1660. 

:::::''Software'' engineers talk a lot about "methodologies." Other engineers do not. [[User:Dpbsmith|Dpbsmith]] 20:06, 24 Apr 2004 (UTC)

::::::I suppose that indicates that "software engineering" is not a true engineering endeavor.  Perhaps you don't get to the maturity of legitimately using the label "engineering" until you only have one proven and universally practiced way to do something. - [[User:Bevo|Bevo]] 14:22, 25 Apr 2004 (UTC)

:::::::There are many ways to build bridges, many ways to build houses, many ways to build radios. Engineering has many, many methodologies, not just on. Perhaps engineers do not do engineering?

==Oh, that ''Conclusion''==

...that says how big, important, proud, etc. the software engineering profession is? Does it communicate any information at all? Or is it pure marketing?

I don't suppose it would be possible to quietly remove it or otherwise put it out of its misery? Reminds me of an old promotional film for Project Whirlwind which ends:

:We have told you the story of one problem recently solved on one digital computer. Multiply this by hundreds of problems being handled routinely by a hundred such computers and you have an idea of the current importance of the digital computer as a new tool to help scale some of the '''hitherto insurmountable peaks which span the domain of man's activities!'''

Cue music. [[User:Dpbsmith|Dpbsmith]] 16:25, 29 Apr 2004 (UTC)

: You make a good point. I looked around and found no other articles on Wikipedia that have conclusion sections. And this text is very (overly?) "apple pie".

: Here are 2 reasons to keep a conclusion like this one. First, the text before the conclusion is a major downer: all about the criticisms of SE. It would be nice for those who read the text from front to back to be left with a positive vibe about SE. People often remember what they read last. One alternative is to find some positive or neutral content to put at the end. Second, many technical articles (though not Wikipedia, yet) identify a few clear points for readers to remember, these key points are often restated in the conclusion. I wonder what handful of key points the other authors of theis article want readers to remember, and where should they be listed?

== Restructuring of page ==

I hope you agree with breaking up the software engineering article in several smaller articles (and moving lots of talk to the archived talk). I know, this was very rough cut, but I hope time will smooth it out again... :) --[[User:Denny|denny vrande&#269;i&#263;]] 21:59, Jun 27, 2004 (UTC)

: Thanks, it really needed it.

== Disagree with the latest precis at the top of the article. ==

The latest commenting-out of "poorly formed sentences" in favor of non-nuanced lists is a regression. Better to have the detail than the stereotypes in the current lists which make up the wikilinks. The current changes to the first paragraphs bowdlerize and trivialize it. The software tools which were previously mentioned aren't necessarily in the replacement lists. [[User:Ancheta Wis|Ancheta Wis]] 01:43, 22 Jul 2004 (UTC)

: I agree. A common mistake in hypertext documents is to assume that readers will click on all of the links and understand what all of the links mean. If that happened, readers would have to click on everything in Wikipedia to understand 1 page.

: I believe that each page should stand on its own, at least a little bit. A casual reader should find enough details on each page to understand something about the topic, without any additional clicks. And the text around each link should give the reader enough context so they can choose whether to click on a link or not. Note: This principle is the opposite of "information hiding" that is used to design software for computers.

: This means that the first paragraph or so of the SE article should list enough concrete applications that naive readers would understand (a little bit) what we mean by "application", and should list enough technologies and practices, that they would understand (a little bit) what we mean by "technology and practice".

:: Examples were removed under the guise of "peacock terms". But, there were no peacock terms in the text. Peacock terms are "an important..." "one of the most important..." "one of the best..." "the most influential..." "a significant..." and so on.

:: Another stated principle of Wikipedia is "Show; don't tell". Concrete examples are much more like "show; don't tell" than abstract generalizations. So, I have reinstated the examples.

:: The only real reason to remove examples I can think of, is because someone disagrees with whether the examples are valid. For example, some argue that embedded-software is engineered, but office suites are not because they have so many problems with crashing and security. But, that would be a debate over what software engineering is, rather than a debate over peacock terms.

:: I urge Kenny to explain his rationale for deleting the examples. Perhaps then we can find a way to change the intro to meet our common goals.

::: ''embody social and economic [[value]], by making people more productive, improving their quality of life, and enabling them to do things that would otherwise be impossible.'' ''help developers, by improving [[productivity]] and [[quality]].'' -- it is communist slogans, not definitions. Abstract. Senseless. Metaphoric. Emotions in form of words. Better to write something like this: Software is usefull. For exaple [[word processor]] is very usefull in text editing. For more examples see ... Software created by prgammers with software tools. Most common software tool is [[compiler]]. For more software tools see [[programming tool]]
::: Long enumerations is sentences used in [[Ericksonian hypnosis]] to misslead [[consciousness]].  Example: A, B, C, D and F and may be also G, H and J, if K and L will join too will do M, N and O for P, Q and R for S, T and W. 
::: Write "Examlpes:" before examples. Do not oveload with exaples, I think 1,2 3 is enogh. Write most common examples.
::: Thank you. [[User:Kenny sh|Kenny]] 14:32, 2004 Jul 28 (UTC)

:::: I can agree with you about separating out examples into a separate sentence using the prefix "Examples:". I did that.
:::: I do not yet agree that examples should only have 1,2, or 3 examples is enough. On the [[List of software engineering topics]] page, there are more than 100 applications and more than 200 technologies and practices. It may take a list of 6 or 8 examples to show diversity of applications / technologies and practices.
::::: A too lot of examples is not effective. Please read [[The Magical Number Seven, Plus or Minus Two]]. This number of words in sentence is ideal. [[List of software engineering topics]] is full comprehensive ordered list. [[User:Kenny sh|Kenny]] 09:54, 2004 Jul 29 (UTC)
:::::: Many, many clear and important sentences have more than 9 words. The point of writing is to communicate clearly. Please avoid using simplistic rules to justify bad writing.
:::: Let me assure you that I live in the U.S. and I oppose communism. I believe it is important to show SE in a good way, just like everyone else should want to show their favorite topic in a good way. That is common sense communication. The reason to say the technologies and practices are there for productivity and quality, is because it is true. If you do not care about productivity or quality, then you may be a programmer, but not a software engineer. The reason to say that applications improve people's lives, is because it is true. People enjoy playing video games, which would be impossible without software. People have lower cost telephone service (more value) because of software. The Agile Software Development publishes many papers and books about creating "social and economic value".
::::: Ok, yes, productivity, quality, entertaiment is important. Also there is a lot of other important topics, and not only SE improves quality. 
::::: Critic of "SE applications embody social and economic value by making people more productive"
:::::# this article about SE, not SW and SW applications.
:::::# [[Wikipedia:Avoid_peacock_terms]]
:::::# IMHO, I see nothing interesting, usefull, in this sentence. The sense of this sentence is same and "Pencil embody social and economic value by making people more productive". The only meaningful interpretation on this phrase I found is: "Software is usefull for people." 
:::::# After I've read this sentence, I have this questions:
::::::# What is "social and economic value"?
::::::# Making people more productive for ....?
::::::# Only SE applications are valuable?
::::::# How SE applications making people more productive?
::::::# SE applications make people only more productive?
::::::# SE applications make only people more productive?

:::: I agree that this page is about SE and not SW. To contrast, SE people write core applications, while business people write spreadsheet templates, lots of people write VB scripts, artists write animation scripts, and scientists write simulations. All of that is software. Trying to clarify this distinction is a good reason to show the diversity SE applications.

:::: Scientific applications are more about understanding nature than about making people productive. Software engineers write the compilers that make the scientists more productive. Animation scripts are more about making visuals to an artist. Software engineers write the animation engines that make the artists more productive. SE has a different emphasis than other professions that write software.

::::: Yes, this is right. [[User:Kenny sh|Kenny]] 15:46, 2004 Jul 29 (UTC)

:::: We agree on that.

:::: I believe that one important distinction, is that most SE software is purchased for one reason or another. (Note that the free software projects often recreate programs that have been sold for a long time.) Users buy the software because they want to use it for a reason. In office automation and robotics, it is to improve the productivity of workers. In the case of visual special-effects and video games, it is to have fun. These are examples of "social and economic value". Perhaps "value" needs to be explained better or use better examples.

:::: Also, I believe that the first 2 or 4 paragraphs should show what SE is and start to explain that it is not all software. These paragraphs cannot make an exact distinction, because that would take too many words. (That is what the whole article is for.) But these paragraphs should start to introduce some of the key distinctions.
::::: I'll be back in 3 days. [[Software engineering]] need nore rework. [[User:Kenny sh|Kenny]] 19:20, 2004 Jul 29 (UTC)

==Don't see the point of this section or sentence==
There is currently an entire section called '''Software engineer''' whose content is:

:A profession, which cares with creation of software with software engineering called software engineer, programmer or developer.

I tried to rewrite it, but I don't understand what it means or what the purpose of the section is supposed to be. Does it mean:

:A software engineer is a professional devoted to the creation of software via the application of software engineering principles. A software engineer may also be called a programmer or developer.

If not, what does it mean? Is it worth a whole section just to explain that a "software engineer" is someone who does "software engineering?" [[User:Dpbsmith|[[User:Dpbsmith|Dpbsmith]] [[User_talk:dpbsmith|(talk)]]]] 16:22, 30 Aug 2004 (UTC)


I think that your's is better but, as someone with a degree in "software engineering" I am a little disturbed by how much this article likens software engineers to programmers.  My [[California State Polytechnic University|University]] makes a clear distinction between a computer engineer (from the college of engineering), a computer scientist (from the college of science), and a computer information systems major (from the college of business).  True, in all 3 programs we learn to code, but the purpose of software engineering (a part of computer engineering) is to take a set process to the development and integration of software into a system.  Engineering is the application of science into the real world and can't be done properly if you understand only how code works and not why code works.  I'd like to see this article (and the world in general) come to some clearer definitions between programmers, application architects, and software engineers. [[User:Cavebear42|Cavebear42]] 23:36, 30 Aug 2004 (UTC)
:True that! DaBeast

==To make more international==

To make this more international, the issues such as economics and famous people needs to become more international (less biased to U.S.). To do this, we need data from Europe and Asia. So, what is the economic impact of SE in Europe and Asia? Who are the SE pioneers in Europe and Asia?

==Remove==

Removed the following sentence, because it directly contradicts itself.

:Without the engineering approach, the code can be difficult to maintain or debug, but an engineering approach does not guarantee quality code without bugs.

==Waterfall==

"The waterfall has been widely discredited in practice, though many people still seem to idealize it."

Where and how has "the waterfall been widely discredited?" 

I do ''not'' advocate it, but I want to see this sentence clarified and evidence cited.

If it means simply "The waterfall method is no longer in fashion" or "large developers like Microsoft do not use the waterfall method" then that is what should be said. 

If it means "The waterfall method has been shown to be inferior to other methodologies" then that is what should be said.

In both cases, evidence for the assertion should be cited.

: The Spiral model (and others) succeed because the Waterfall fails. I am not aware of a single large project that has ever been successfully driven by a requirements doc, except where that project had undergone many previous iterations. Even the US DOD agrees about this. The pragmatists in SE widely agree that the Waterfall is a catastrophe.

: However, good criticism is hard to say. Alas, the Waterfall is still very fashionable with many people (for example formal methods people, and some project management people) who use it justify their own point of view. For them, the Waterfall is far more superior and successful to the Spiral, Chaos, Scrum, or other models. Also, the Waterfall is very simple, and most SE textbooks begin by teaching the Waterfall because it is so simple.

: Please help find a better way to say this.

What really bothers me about software methodologies is my impression that they simply come in and out of fashion for no particular reason other than the personal influence and salesmanship of exponents. Each methodology is always accompanied by flat assertions that it has been proven in practice, but the "proofs" I've seen seen usually anecdotes ("case studies,") and are often accompanied by unrealistic requirements for success (must have everyone's buy-in, must have the backing of upper management, etc.) They are often discussed in a way that ''implies'' a background of data which is always assumed but never actually presented.... [[User:Dpbsmith|[[User:Dpbsmith|Dpbsmith]] [[User_talk:dpbsmith|(talk)]]]] 19:41, 6 Oct 2004 (UTC)

: Good point. This is one of the main criticisms of all methodologies. The page [[Methodology (software engineering)]] lists a couple more related criticisms.

: Methodologies was one of the main areas of software engineering over the last 20-30 years. Even today, there is a huge amount of time and energy devoted to methdologies(including RUP, Agile, CMM ...). I think this SE page should *briefly* discuss methodologies and point to the other page. But like I said, saying it well is hard. Do you have any thoughts on what it should say?

Why are we making judgements on how well a process works?  I think we should state what the waterfall method is, since it is so prevalent, and leave it at that.  Then when we discuss iterative methods or the spiral method, we can say that those methods attempt to build on the waterfall model by accounting for the element of risk.  Of course, each methodology will have something unique to itself, something in its design/philosophy that accounts for something the others don't.

== Remove ==

: This article attempts to be neutral on this issue, but errs on the side of being independent to clarify the differences between fields.

== Quotes ==

These 2 quotes are pretty cynical and down. In a similar vein, one could describe Winston Churchill as "a politician who lost a bunch of elections." Can we not find much better quotes about SE?

*I don't believe you can get much better than [[Edsger Dijkstra]] and [[Fred Brooks]], and I would be opposed to replacing these quotations with gee-whiz happy talk. [[User:Dpbsmith|[[User:Dpbsmith|Dpbsmith]] [[User_talk:dpbsmith|(talk)]]]] 17:34, 19 Nov 2004 (UTC)

** I think one can almost always do better than Dijkstra. The only person more cynical the Dijkstra is Neumann. Boehm and Parnas would both be much better (more true to SE) than Dijkstra.

***What the '''heck''' do you mean by "more true to SE?" I cannot imagine someone saying "let's remove the quotation from John A. Roebling and replace it with one from Othmar Ammann because Ammann is more true to civil engineering than Roebling." This whole article reads more like a marketing department's white paper than an encyclopedia article about a branch of engineering. [[User:Dpbsmith|[[User:Dpbsmith|Dpbsmith]] [[User_talk:dpbsmith|(talk)]]]] 20:36, 23 Nov 2004 (UTC)

****You have one point, but only one point. Dijkstra was reknowned for his goals to make SE more mathematical. He made many important contributions to SE. But, his biases show he is rather narrow-minded, perhaps fanatical. He also showed a lot of contempt for commerical software and practitioners.

****On the other hand, Parnas and Boehm have both worked in industry, and except for a few stray comments here and there, they both showed respect for commercial software and practioners. They also tolerated a much wider range of ideas of what good SE practice is.

****I believe that one cannot define SE without including practice, and in this respect Dijkstra is totally out of touch with reality.

== [[Kent Beck]] ==

Why isn't he a pioneer?  His promotion and popularization of the XP concepts seemed pretty radical and pioneering to me at the time.  And even where the whole XP method hasn't been adopted, a lot of its ideas have influenced the development process. -- [[User:Key45|Key45]] 23:10, 23 Nov 2004 (UTC)

*He is a pioneer ''of extreme programming,'' certainly, but he isn't a pioneer ''of software engineering.'' He is a notable and important ''recent contributor'' to the field of software engineering. A pioneer is "One who ventures into unknown or unclaimed territory to settle. 2. One who opens up new areas of thought, research, or development: a pioneer in aviation." Beck didn't "open up" the field of software engineering. That was done in the 1970s. In fact, [http://www.cs.colorado.edu/~kena/classes/5828/s99/comments/srinivasan/01-29-1999.html Robert L. Glass] defines the "pioneering era" as 1955-1965. "Structured Programming" emerged in the early 1970s. Naur et. al wrote "Software Engineering: Concepts and Techniques" in 1976. I don't know exactly when Beck was developing the "Extreme Programming" methodology, but it must have been in the 1990s, a couple of decades after the pioneers. [[User:Dpbsmith|[[User:Dpbsmith|Dpbsmith]] [[User_talk:dpbsmith|(talk)]]]] 01:30, 24 Nov 2004 (UTC)

** "Unclaimed territory, opens up new areas of thought...".  I'd say that describes Beck to a tee.  He greatly expanded the way people think about software engineering, even if he didn't invent it.   I don't think basing the distinction on date alone is correct.  Wouldn't you call [[Burt Rutan]] a pioneer in [[aerospace engineering]], even 40 years after the moon shot and 100 years after the [[Wright Brothers]]?  Also, didn't you argue for his inclusion earlier in this page (in the Grace Hopper section)?    -- [[User:Key45|Key45]] 17:17, 24 Nov 2004 (UTC)

*** Burt Rutan and Kent Beck are innovators or revolutionaries, not pioneers.  That does not diminish their contributions. [[User:Hu|Hu]] 17:42, 2004 Nov 24 (UTC)

*** It's all arguable, but I would have called [[Burt Rutan|Rutan]] a pioneer in the use of composite materials in aviation and a pioneer in the commercialization of spaceflight; I would have said [[Frank Whittle]] was a pioneer in jet propulsion, and that [[Charles A. Lindbergh|Lindbergh]] was a pioneer in transoceanic flight; but when I think of "pioneers '''of aviation'''" I think of [[Octave Chanute|Chanute]], [[Samuel Langley|Langley]], and the [[Wright brothers]]. [[User:Dpbsmith|[[User:Dpbsmith|Dpbsmith]] [[User_talk:dpbsmith|(talk)]]]] 18:10, 24 Nov 2004 (UTC) P. S. No, I never argued for Kent Beck's inclusion ''as a pioneer.'' I wasn't paying a lot of attention to aspect, really. IMHO Grace Hopper was a pioneer in '''computing,''' but does not '''belong to the field''' of software engineering. IMHO Kent Beck certainly '''belongs to the field''' of software engineering, but did not '''pioneer''' it. Your mileage may (and obviously does) vary. [[User:Dpbsmith|[[User:Dpbsmith|Dpbsmith]] [[User_talk:dpbsmith|(talk)]]]] 18:14, 24 Nov 2004 (UTC) P. P. S. And, yes, I see that the article on Lindbergh calls him an aviation pioneer. But the article on [[Burt Rutan]] does not...

****I would much rather put both Beck and Humphrey on the page as pioneers. They complement each other. But, Beck helps to show that the field is much more than what a bunch of researchers thought about 30 years ago. SE is a living, breathing field that still is evolving. -- The Phantom Avenger

==Meanings==

I've reinserted the following which I believe to be accurate:

:[[As of 2005]], in common parlance the term ''software engineering'' is used with at least three distinct meanings:
:* As the usual contemporary term for the broad range of activities that was formerly called [[programming]] or [[systems analysis]];
:* As the broad term for the technical analysis of all aspects of the ''practice,'' as opposed to the ''theory'' of computer programming;
:* As the term embodying the ''advocacy'' of a specific approach to computer programming, one that urges that it be treated as an [[engineer]]ing profession rather than an art or a craft, and advocates the codification of recommended practices in the form of ''[[Methodology (software engineering)|software engineering methodologies]].''

The term is really used in all these senses, even if some advocates would like it to be otherwise.  

Why was it removed? 

If, after introducing these terms, it is felt that the article should discuss only one of these meanings for software engineering, it should say so and then continue. Anything else muddies the water. [[User:Dpbsmith|Dpbsmith]] [[User_talk:dpbsmith|(talk)]] 21:22, 15 Feb 2005 (UTC)

==RUSSOFT==
What is RUSSOFT?  Do we have an external link to more information? [[User:RJFJR|RJFJR]] 21:08, Feb 20, 2005 (UTC)

* [http:\\www.russoft.org www.russoft.org] is an external link to RUSSOFT.  The other organizations listed in the article are wikilinked (such as [[IEEE]]).  I don't know how we want to handle this for consistancy (wikilinks only, this one as external, remove this, leave as is...).  I'm not even positive it is an organization in the same way IEEE and ACM are.

== Removed material ==

The intro section was very choppy (a lot of paragraphs each with a few sentences).  I consolidated them and removed the following material.  I felt the following material, while detailed and interesting, was not directly related to software engineering.  I have moved it here in case there is disagreement. [[User:RJFJR|RJFJR]] 19:32, Mar 12, 2005 (UTC)
*[[List of software engineering topics#Applications|SE applications]] are used in a wide range of activities, from [[industry]] to [[entertainment]]. Software applications improve user productivity and quality of life. [[Application software]] examples: [[office applications suite|office suites]], [[video games]], and the [[world wide web]]. [[System software]] examples: [[embedded system]]s and [[operating system]]s.
*Software engineering examples: [[database]]s, [[Programming language|languages]], [[Library (software)|libraries]], [[Design pattern (computer science)|patterns]], and [[Programming tool|tools]]. Computer science examples: [[algorithm]]s and [[data structure]]s. Project management examples: [[software development process|processes]].

:This edit opens up a long and divisive debate. There are many issues. 
** Concreteness: Many believe that examples make text much more concrete and comprehensible. Others want text to be high-level and abstract.
** Audience: A related question, is who should the pages be written for? Most writers are in college or past college. However, there is evidence that most readers are high-school students, or other people who are not familar with a topic. What is obvious and irrelevant to a CS student or grad, may be very unclear and important to a high-school student or someone who is thinking of returning to college. Of course, Wikipedia has yet to define its target audience very well. The lists make it accessable to a much broader audience.
** Definition: Saying that SE emphasize quality does not really say what is and is not SE. Some (especially in aerospace, SEI, etc.) have argued that SE is about life-and-death apps, and video games are not SE because a lower standard of quality applies. Yet, the U.S. census from 2000 made it clear that people who write normal, everday app view themselves as SE. Using the broader examples allows this larger community to be included, without pandering to the elitists.
** Style: Your main complaint is choppiness. The original version was sentence prose. One Wikipedian hated the prose list, but was willing to stop arguing after making it an example list. This was maybe 6-8 months ago.
** I will replace the examples in a couple days, unless someone finds a new way to think about all this. -- The Phantom Avenger for SE


Sorry, I didn't mean to cause a disturbance.  One of your points mentioned quality as it relates to software engineering,  this sounds like something that could be (and should be) expanded into a section.  Can we add a section for definitions under terminology and put some of the material you want to put back in there?  I'll have to look at this some more later. [[User:RJFJR|RJFJR]] 15:13, Mar 15, 2005 (UTC)

:Please do not apologize. You are correct that the sentences are choppy and need to be improved. And, they had sat there for many months, without change. While I have fought in these battles in the past, I do not mean to imply that you intended any harm.

:The big dilemma I see, is that most readers will not read past the intro. So, all relevant info for the main definition should be in the intro. Only alternative, historical, and other weaker info should be moved down into the definition section. Also, the intro from last week was not particularly long, in terms of word count. The trick is to make is tighter and smoother. Will think about this. -- The Phantom Avenger for SE

----

Removed the following text. This is a researcher fantasy. I suspect that every truly useful bit of research is very quickly adopted into practice. At least 1 practitioner believes that researchers are too often self-deluded and research gets ignored only when it is junk. Practitoners need every useful method and technique that they can find, regardless of when or where it comes from.

:In the last years [[software]] engineering made big steps from the research point of view. But the research output has been slowly introduced in the industry. So probably, nowadays is important to transfer the advanced research output into daily practice, instead of developing new methods and techniques.



I replaced the second paragraph which was

:Software applications improve user productivity and quality of life. Examples include [[embedded system]]s, [[office applications suite|office suites]], [[operating system]]s, [[video games]], and [[world wide web]]. Technologies and practices improve the [[productivity]] of developers and the [[quality]] of the applications they create. Examples include [[algorithm]]s, [[data structure]]s, [[database]]s, [[Programming language|languages]], [[Library (software)|libraries]], [[Design pattern (computer science)|patterns]], [[software development process|processes]], and [[Programming tool|tools]]. Processes encompass analysis, specification, design, development, and testing.


The paragraph I substituted tries to answer the question "what is software".  If someone chooses to replace it please consider putting my version here for possible discussion or borrowing from.  The version I inserted may need some work on the choice of wording (could be simplified some).  I need check if we have an article on measuring code in ''millions of lines of code''.  I apologize in advance if I've made the article worse rather than better.[[User:RJFJR|RJFJR]] 17:53, Mar 25, 2005 (UTC)

:I think your explanation of "why SE matters", mostly the reliable million line apps is important. However, there is a whole page [[computer software]] devoted to the question "what is software?", so I don't believe that that belongs here. Also, there are no concrete examples of what apps and technologies are. People in the field will have no problem, but people outside the field probably do not know.

::Apps are used in the devices listed.  I didn't want to bog people down with things like embedded system and real time programming (even though there some differences in how you do engineering for those conditions.)  I'm not sure how to descirbe SE techniques without being too technical.  The second paragraph as I wrote it is a tad long, may need pruning.  On the other hand probably need to add an example of the kind of app you have on a PC (to go with what are mainly embedded examples).  Any ideas for non-technical examples of SE techniques? [[User:RJFJR|RJFJR]] 20:00, Mar 25, 2005 (UTC)

:::After thinking about it for a couple days, I basically agree with your intro. Good job. -- The Phantom Avenger for SE

----

For Your Info: Yesterday (March 29, 2005) this page was in the top 10 on Google search for "software engineering". Until yesterday, this page bounced around between about place 11 and place 20. Pages Usually bounces around in a range of 5 or 8 positions. Since this page has been climbing, it should routinely be in the top 10, within a month.

This means that this page is useful enough for lot of people to appreciate it. I believe the reason for popularity is because this page has real content and real sentences, as opposed to boring lists like the "computer science" page. Also, it is neutral enough to not get hung up on traditional (out of date) points of view.

Anyways congratulations to all the authors of this page. -- The Phantom Avenger for SE

**High Five, everyone! [[User:RJFJR|RJFJR]] 02:20, Mar 31, 2005 (UTC)

== 'Room for improvement' has room for improvement ==

The section currently headed 'room for improvement' ironically has room for improvement.  It was a section on how software is often buggy and insecure but that improvements in software engineering procedures and technologies can improve this.  It's been tightened to the point where it is a little too tight.  Anyone have any material we can add to clarify this? [[User:RJFJR|RJFJR]] 02:35, Apr 7, 2005 (UTC)

==Excuse me?==

Extreme Programming is the best-known agile process. In Extreme Programming, the phases are mixed up. Advocates say this is much more effective. Testing is done first, to provide concrete goals for development. Coding comes next. Design and architecture emerge out of refactoring, and come after coding. Design is done by the same people who do the coding. (Only the last feature - blurring together design and code - is common to all the other agile processes.)

:How can testing "be done first?" If no coding has occurred yet, what is there to test? [[User:Dpbsmith|Dpbsmith]] [[User_talk:dpbsmith|(talk)]] 10:39, 7 Apr 2005 (UTC)

::You write the unit test as some sort of semi-formal specification to test the design contract of a future implementation. That way you can think of the interface of code, while doing something useful (coding) at the same time. Example: you want to write a certain collection class. First you write the unit test, in which you create an instance of the (not yet existing!) class in code. Then you do a few addition and removal operations, and write code to check the contents and size of the container. This test will of course not compile. So then you write an empty class that conforms to the newly-designed interface. You adapt some changes to the test if needed, and you compile. This time, the unit test will compile, and will fail immediately (otherwhise your test is bad). Now you continue implementing methods, during which you constantly test, expand and adapt the unit test. I hope this clears stuff up. [[User:Wlievens|Wouter Lievens]] 16:51, 7 Apr 2005 (UTC)

:::That's completely different. "Developing unit tests" is not "testing." Please clarify the paragraph language to explain that unit tests are developed before developing the code, which is perfectly sensible (and a common practice for decades), not that "testing is done first," which is absurd. Also, if the unit tests are actually implemented, then surely that counts as "coding," i.e. it is just saying that one part of the coding, the unit tests, is performed before other portions. Note that this is not that different from insisting that well-specified requirements be defined before coding begins; unit tests are simply ''very'' well-specified requirements. [[User:Dpbsmith|Dpbsmith]] [[User_talk:dpbsmith|(talk)]] 17:37, 7 Apr 2005 (UTC)

::::You're indeed correct. The paragraph (with which I had nothing to do :p) requires a rewrite. [[User:Wlievens|Wouter Lievens]] 19:12, 7 Apr 2005 (UTC)

== Formal methods: cleanup ==

I removed most of the contribution of  204.134.9.1 (April 5), as it fits more into a discussion of personal views (i.e. here) than it represents a neutral point of view.

The general problem is that formal methods can not be seriously discussed as a sub-chapter of a software engineering article. So we better keep here only a value-free short note that there is something like &#8220;formal methods&#8221; too. 

In particular the contribution is focused on writing and validating code. People apply formal methods for any kind of application. Creating conventional code (like C++ etc.)  using formal methods is just one &#8211; not very sophisticated &#8211; possibility to use their power. For instance, a state machine can be defined without writing one line of code. There are several methods to validate the state machine (infinite loops, dead locks, states which cannot be reached etc.). A designed state machine can be expressed as a set of boolean equations by an automatic process. This set can be then executed by an other automatic process (the rules of boolean algebra are well known). Doing so one creates a computer control application, but there is not one line of code behind it. This is the really interesting part of formal methods, the validation possibility is just an other aspect of it.

:This is a formal methods fantasy. I would like *anyone* to show me a 'state machine that can be expressed a set of boolean equations' that actually does something useful that is not written *some* form of programming language (whether graphical or textual). Even ML and OCAML are now universally recognized as programming languages. And, any form of validation that can be applied to boolean equations can also be applied to code. The above paragraph contains more wishful thinking than the original article contained opinion.

::[[User:Thowa|Thowa]] 10:42, 17 Apr 2005 (UTC): None of the formal methods can be shortly explained within a Wiki-discussion. But let's do a short example, a more interested reader might find as a useful starting point to understand how powerful formal methods in practise are.
::Let's create a finite state machine (FSM) having two states "Eat" and "Sleep". This FSM shall communicate with two external objects: a digital input (di) and a timer (ti). The digital input can generate two signals: &#8220;true&#8221; and &#8220;false&#8221;. The timer generates one signal &#8220;over&#8221;. The timer accepts also a command &#8220;start&#8221; (which does a reset and starts the timer). We create an input and output dictionary which can be used by the FSM:
::;Input dictionary: {di_true, di_false, ti_over}
::;Output dictionary: {ti_start}

::What does our example FSM do? It starts in state &#8220;Eat&#8221; and goes to state &#8220;Sleep&#8221; in case the di was set to &#8220;true&#8221;. Entering the state &#8220;Sleep&#8221; the FSM starts the timer. To go back to state &#8220;Eat&#8221; the timer must be &#8220;over&#8221; (ti_over) and the di must be changed to &#8220;false&#8221; (di_false). Please print the FSM transition diagram on a piece of paper to avoid any misunderstanding. To create the executable specification we need to create state transition tables for each state of our FSM:

{| border="1" cellpadding="5" cellspacing="0" align="center"
|-
! style="background:#efefef;" | State Name
! style="background:#efefef;" | Condition(s)
! style="background:#efefef;" | Actions(s)
|-
| valign="top" | Eat (current state) || Entry action || n/a
|-
| Sleep (next state) || di_true || n/a
|-
|}

::and

{| border="1" cellpadding="5" cellspacing="0" align="center"
|-
! style="background:#efefef;" | State Name
! style="background:#efefef;" | Condition(s)
! style="background:#efefef;" | Actions(s)
|-
| valign="top" | Sleep (current state) || Entry action || ti_start
|-
| Eat (next state) || di_false AND ti_over || n/a
|-
|}

::An automatic process can generate a set of equations which fully express the above specification. This set could look like this (note that this is already a kind of machine code, so it looks criptical, but I enter it here to show the &#8220;magic&#8221; behind the executable specification):

::S1      N2 V4
::S2 E1 N1 V3&2

::where S represents the current state, N the next state, E entry action and V condition (& means AND). For instance the first line means &#8220;in state 1 (Eat) go to state 2 (Sleep) if the boolean condition 4 (di_true) is true&#8221;.

::Some words about the used boolean algebra here. In the presented concept it is the positive logic algebra and not the boolean algebra (i.e. NOT is forbidden). The reason is simple: in the software world we have very seldom signals which can be negated. Lets take for instance a sensor which delivers temperature: temp_low, temp_good and temp_high. What would be NOT temp_high? So in the above concept we only look if a signal exists or not. Some signals cannot exists in parallel, e.g. We cannot have at the same time di_true and di_false.

::The above equation plus the description of the I/O dictionaries can be now read by a standard executor (which might be a part of the OS) and executed.

:::I like your example very much. I copied it to the [[formal methods]] page as the "example" section. Thank you.

::As you can see up to now, we did not write one line of code in any conventional programming language. Of course, this method can be applied &#8220;only&#8221; to design the control part of the application. All the peek/poke operations (translation of real signals to names accepted by the FSM and vis-a-versa) as well as pure mathematical calculations have still to be coded in the conventional way, but the improvement (reliability, maintenance and time-to-market) in software design is enormous.

:::I disagree with your premise. Yes, you did not write in a "conventional programming language" but you did write in a "programming langauge". If you claim to have an "excutable specification" then the specification must be written in a mechanically clear form. Also, I have no way to know whether your spec improves reliability or maintenance or time-to-market. Those claims are just hot air. Perhaps my guru friends would have written the same program in C++ much faster than you wrote your executable spec.

::::[[User:Thowa|Thowa]] 07:31, 26 Apr 2005 (UTC): I can agree with you that any kind of &#8222;mechanically clear form&#8220; can be called a programming language. But then I would say that this &#8222;FSM-language&#8220; is an enormous progress in development of programming languages compared with all we have else. The step forward is the syntax and methodology behind it. 

::::1. The syntax: instead of writing thousands of lines of cryptic text which can only be understood by certain gurus you plot pictures and fill out tables. The result of your work can be understood by your management, can be discussed with your customer and does not need any further design documentation as it cannot be better explained in words.

:::::I think we agree on what you say in these 2 paragraphs. When a mini-language is smaller and clearer, it is ofter better for everyone. -- PASE

::::2. Methodology: the difference in thinking is here critical. For instance in OOP you think in terms of objects. You try to express your problem (application) as a set of black boxes communicating with each other. In FSM you try to express your problem in a form of situations (states), which is a much more realistic approach. If you design a system of 10 FSM, each of them consisting of 10 states, you covered theoretically 10^10 possible situations your application can be in. Even if we know that there are several impossible combinations of FSM states, it is impressing to be able to see how many situations do we cover. In OOP it cannot be possible because we don't think situation oriented &#8211; you can count only your black-boxes. Besides this can you imagine how many lines of C++ code would be necessary to cover 10^10 cases? In practice all we can do in code is to design the sunny day scenario and cover the most obvious error cases. The rest is just &#8222;almost impossible&#8220;, &#8222;happens very seldom&#8220; or &#8222;can be accepted&#8220;. Therefore the most of the software is as it is (i.e. buggy). You will also make bugs in your FSM design of course, but those are on a much higher level of abstraction (something like if (a=b) instead of if (a==b) will never happen in your &#8222;code&#8220;) and the (automatic) validation methods are by far much more powerful than what you can do in code.

::::I think the above statements explain also a little bit what I meant by &#8222;improved reliability, maintenance and time-to-market&#8220;, but you can still think it is just &#8222;hot air&#8220;. Luckily there is some &#8222;hard ware&#8220; in place: Lucent published some years ago [http://www.lucent.com/minds/techjournal/pdf/winter_97/paper08.pdf "an article in Bell Labs Technical Journal"], where they explain how they introduced the [[Virtual finite state machine|VFSM]] (virtual FSM) technology in their labs and what were the results in terms of reliability, maintenance and time-to-market after several hundreds of projects done (see p. 15). Since then, there has been done a lot of improvement and the methods became much more powerful. Unfortunately my own experiences are not published yet, but I promise that this will happen soon... ;-) --[[User:Thowa|Thowa]] 07:31, 26 Apr 2005 (UTC)

:::::This is an interesting argument. My first response is that most code in most apps is not applicable to most formal methods. I work on a commerical app that plays a sound, whenever a file transfer completes (among other stuff). This code is about interfacing with the OS and saving and setting user preferences. No formal method will make that better.

:::::Another example is parser generators. They are very nice examples of formal methods, by expressing syntax simply and clearly. But, most programs do very little parsing, so parser generators do not help most programs. Of course PGs do help compilers and a few other programs.

:::::Every new formal method technique helps a little bit. I hope your VFSM gets used. But, very few formal methods have been widely used, unless they are put into compilers, like weakest preconditions, where they are used automatically and invisibly. -- The Phantom Avenger for SE

:::I have had a small amount of success on occasion writing a mini-language to do something, where the mini-language saved a lot of code. Usually the code was very redundant. Most recently, it was a list of macro calls that made the WindowProc message names clear, whenever there was a macro defined for the message. The mini-languages often looked like your table above. But, rather than arguing that they are "executable specifications", I have been arguing that they are "useful code." Maybe, one theorist's executable specification is a programmer's mini-language?

::The software engineering is a young science and there is still a lot to do, but there is already a lot in place and so there is already a lot to learn if you want to work as engineer and not as coder.

:::You are making assumptions here. 20 years ago, I worked on theorem proving, mostly with resolution-based provers in grad school. I originally believed in things like you say, but I changed my mind. Theory cannot handle the following questions. How do we know that you did not forget a case? What if the user wanted a completely different problem to be solved? How do we know that a hand translation from your diagram to code is correct? These are the hardest questions to answer, and no amount of theory will ever do so. -- The Phantom Avenger for SE

::[[User:Thowa|Thowa]] 10:42, 17 Apr 2005 (UTC)

Last but not least, I found there is an article about formal methods, so it's better to focus on the details there.

:I think we agree on this. -- The Phantom Avenger for SE

[[User:Thowa|Thowa]] 15:09, 10 Apr 2005 (UTC)

==POV section snipped==

I removed this:
:''Software engineering'' is the practice of creating [[computer software|software]], productively and with quality.

:Members of this profession are called software engineers, [[programmer]]s,  [[developer]]s, or practitioners.

:People who write code and do not follow the doctrines of software engineering are more accurately called programmers, developers, or software artists.

Every one of these sentences is unsupported and debatable opinion. Not one of them is backed by any reference to any source.

First, creating software "productively and with quality" is the '''goal''', not the '''definition''' of software engineering. It is a ''claim'' that is made by software engineering advocates. Our article on [[Engineering]] says "Engineering is the application of science to the needs of humanity. This is accomplished through knowledge, mathematics, and practical experience applied to the design of useful objects or processes." Nothing about productivity or quality there. Would we say that "athletics is the practice of winning games?" Would we say that an athlete is not an athlete when he or she loses?

::I agree with your arguments. But, from a historical POV, productivity and quality have been the main drivers of SE for the last 40 years. Fortran, Cobol, Java, code repositories, etc. have all been promoted to improve productivity, quality, or both. The famous "No Silver Bullet" paper was based on the argument that nothing would bring a 10-fold increase in producitivity with 10 years. The main thrust of the CMM is measuring and improving quality (and outsourcing jobs). The SEI in many documents specifically defines SE in terms of process.

::The problem is that we have been so busy bootstrapping the SE profession with tools and processes, that we still don't have a "lofty goal" definition of SE. And, I would not trust traditional engineers to write it for SE, or base it on their definition. SE is still figuring out its own reality.

Second, "the doctrines of software engineering" is a very poorly defined term. In fact, "doctrine" and "engineering" are almost antithetical. On page 7 of Sommerville's "Software Engineering", 6th edition, he says:

:Engineers make things work. They apply theories, methods and tools where these are appropriate but they use them selectively and always try to discover solutions to problems even when there are no applicable theories and methods to support them.

Are we to say that a software engineer is not being an engineer when he is trying "to discover solutions to problems even when there are no applicable theories of methods?" Or, in fact, is this the time when he is ''most truly'' an engineer?

::This has always been a point of contention. Is an SE what a typical SE does every day? Is an SE someone who works toward a particular end? With particular tools? etc.... The sentences you removed were written by different authors who insisted that the definition be kept in the article. I at one point moved them into the same section. This text should probably have been removed a long time ago.

Third: Who decides who gets called an "engineer?" On the one hand, very, very, very few people who write software hold a PE certificate. By that definition&mdash;the legal definition in many states&mdash;very, very few software developers are entitled to be called "engineers." On the other hand, "software engineer" is the job title at many companies for ''anyone'' who writes code. It is absurd to say that it is wrong to call someone by their job title. There is no doubt that software engineering ''advocates'' would like to define the term themselves, but that is ''their'' point of view. [[User:Dpbsmith|Dpbsmith]] [[User_talk:dpbsmith|(talk)]] 23:22, 21 Apr 2005 (UTC)

::Once again, an excellent point. Partly this is a debate between the elitists and the populists. Do you have a proposed answer? -- The Phantom Avenger for SE

:::My proposed answer is to snip the paragraph, since I don't think it says anything useful or important. I don't see any need for it to be there. It is up to those who think something of this sort needs to be there to articulate it in a neutral and non-promotional way.   [[User:Dpbsmith|Dpbsmith]] [[User_talk:dpbsmith|(talk)]] 16:21, 25 Apr 2005 (UTC)

== Careful about POV: "Profession" ==

I weasel-worded the statement that software engineering is "a profession." The definition of "profession" varies. Software engineering meets some definitions of profession but not others.

A good example is the existence of a code of ethics. Many, though not all definitions of "profession" say that a professional is bound by a code of ethics, which takes precedence over the professional's responsibility to his employer. It is very clear that medical doctors ''and their employers'' acknowledge that doctors are bound to a code of professional ethics. A doctor may be a hospital employee, but is a doctor first and a hospital employee second. The same is true of accountants.

It is far from clear that this is true of software engineers. [[User:Dpbsmith|Dpbsmith]] [[User_talk:dpbsmith|(talk)]] 16:17, 25 Apr 2005 (UTC)


==POV==

The attempt to remove POV by insisting that software engineering is not a profession and not a form of engineering is extremely POV.  If you want to add that most areas do not have legislation establishing a professional software engineer license then that certainly belongs.  But I feel no need to stay here and hear how software engineers are not professional, not ethical, not competent, not able, etc.  Not licensed maybe, anything else needs to be proved.[[User:RJFJR|RJFJR]] 16:33, Apr 25, 2005 (UTC)

:How do you read "regarded by some as a profession" to mean "insisting that it is not a profession?"

:If it is important to have the word "profession" in the lead paragraph than it has to be qualified somehow, because some people regard it as a profession, and some do not. It's a grey area. And it depends on how "profession" is defined and people do not agree on the definition. It is clear that software engineering is ''not'' a profession '''in the same way''' that medicine or accounting is. Does that mean the word profession should not be used? Not necessarily, but there needs to be some care about how it is phrased. 

:I'd be perfectly happy to leave the word profession out of the lead paragraph altogether. Do you have a wording that you would suggest? Here are some that occur to me: [[User:Dpbsmith|Dpbsmith]] [[User_talk:dpbsmith|(talk)]] 12:09, 26 Apr 2005 (UTC)

:#Software engineering (SE) is the discipline practiced by software engineers, concerned with creating and maintaining software by applying technologies and practices from computer science, project management, engineering and other fields. [substitute "discipline" for "profession"]
:#Software engineering (SE) is the practice of creating and maintaining software by the skillful and systematic application of computer science, project management, and engineering knowledge. [[User:Dpbsmith|Dpbsmith]] [[User_talk:dpbsmith|(talk)]] 12:09, 26 Apr 2005 (UTC)

::I agree that *not all* agree that SE is a profession. But, from the point of view of simplicity and clarity, saying that "SE is a profession" makes sense. Adding words like "discipline" just make it worse. Just what is a "discipline" or "practice"? Murky words make definitions worse. -- Phantom Avenger for SE

::Also, I believe that SE is a profession, just like medicine or accounting. What is the difference? That you need a license? Many people in medicine do not have licenses. Many people in accounting do not have licenses.

:::As noted above, both medical doctors and accountants subscribe to a formal code of ethics and consider themselves to have ''a responsibility to their profession'' and not merely to their employer. An accountant can say to an employer "I can't do that because it is not in accordance with generally accepted accounting principles." I don't think you can point to anything comparable for software engineering. If a doctor said to his or her employer, "I can't do that because it is not medically ethical," the response would probably be an argument for its being ethical. If a software engineer said to his or her employer "I can't do that because it violates the code of software ethics" the response would probably be hysterical laughter. This is a clear difference. 

::::Whoa! Where is it written that "profession" equals "ethics"? I just looked up the definition on dictionary.com [http://dictionary.reference.com/search?q=profession] and it does not mention ethics. And, "thief" is a very old profession, but where is the ethics in that?

:::::As I have said repeatedly, '''definitions of "profession" differ.''' That's what I mean by saying that "software engineering is a profession" embodies a point of view. 

:::::It turns out, by the way, that I'm quite right that some people, e.g. the ACM do think that a code of ethics is intrinsic to the idea of a "profession." But it turns out that '''I'm quite wrong''' in thinking that software engineering doesn't have one. Here's the [http://www.computer.org/tab/seprof/code.htm#Full IEEE/ACM software engineering code of ethics]. So now the question is: is it for real, i.e. is this code of ethics a real part of the day-to-day practice of software engineering? [[User:Dpbsmith|Dpbsmith]] [[User_talk:dpbsmith|(talk)]] 19:51, 26 Apr 2005 (UTC)

::::Also, the Wikipedia entry for [[profession]] hardly mentions ethics. Except that late in the intro, it points out that ethics is less important in the late 20th century.

:::Of course, if "professional" is taken to mean "someone who is paid" then there is no problem--except that it would imply that most work on open source projects is not software engineering.

:::None of this should be taken to suggest that software engineers, '''as a group,''' are not "ethical." Who can say whether the employees of Microsoft, '''as a group,''' are more or less ethical than, say, the employees of Arthur Andersen? I'm just saying that the professions of medicine and accounting ''formally'' have an ethical dimension that I don't think software engineering has. [[User:Dpbsmith|Dpbsmith]] [[User_talk:dpbsmith|(talk)]] 17:06, 26 Apr 2005 (UTC)

::::We know that Arthur Anderson employees engaged in unethical behavior, because AA was put out of business. We know that energy engineers at Enron engaged in unethical behavior, because Enron was put out of business. Their professions did not prevent them from behaving unethically.

::And, if we are going to pick nits, what "engineering knowledge" does SE use that is not already covered by CS, PM, or another field like medicine? Many people (like me) argue that SE is not a branch of engineering. For example, the TBP which is the engineering honor society in the U.S. over the last 2 years amended their constitution to ban CS people from joining. Most SE people have CS degrees. Clearly, many traditional engineers argue that SE is not part of engineering. -- Phantom Avenger for SE

==IEEE POV?==

Replacing the intro paragraph (which is specific) with one defined by the IEEE (which only represents about 5% of the SEs in the U.S. and maybe 1% or 2% of the SEs in the world) is a very political act. That definition certainly does not apply to me or my colleagues. -- The Phantom Avenger for SE

Besides, that definition does not mention ethics. :)

*OK, what's an organization you like, and how do they define it? My point is not to pick IEEE specifically, but I noticed that a number of other organizations seem to use that definition... and I was looking for an authoritative definition from an outside source that might be accepted as neutral. [[User:Dpbsmith|Dpbsmith]] [[User_talk:dpbsmith|(talk)]] 00:18, 27 Apr 2005 (UTC)

::Well I am in the ACM. But most software engineers are not in either organization. Wikipedia in general does not go around using "standard definitions." It tries to create even better definitions. -- PASE

== Proposal: Have a Software Development page ==

Currently, "Software Development" redirects to "Software Engineering". It seems pretty clear to me that not all software development can or should be considered to be software engineering. It might resolve a lot of the POV concerns (on all sides) to have a general Software Development (SD) page that can then direct people to various topics, including Software Engineering (SE), Software Craftsmanship, or whatever. A fair amount of the content should fit within the SD page, while the IEEE stuff can be at home at SE.

:Distinguishing between SD and SE might be good idea. Please proceed. Note that there is already a [[computer programming]] page.

:However, there are many other people who are software engineers who are not in the IEEE. In fact, almost all SE are not members of the IEEE. For example, the ACM has more members who qualify as software engineers than the IEEE does. And, both organizations together cover less than 10% of the software engineers in the U.S. and much less than that around the world. See the [[Software engineering demographics]] page for details.

:Note that the current page talks about all SEs, and avoids claiming that any one society has the best definition.

:If you want to start an "IEEE SE" page, then please start an "IEEE software engineering" page, which can state as much IEEE propoganda as it wants. But, to claim that the IEEE is the primary source of wisdom about SE would be conceited. The IEEE is an important source of info, but they sometimes promote their own agenda, rather than for the whole SE community. -- The Phantom Avenger for SE

::I am starting an [[IEEE software engineering]] page.

== Critical mass ==

I'm not an expert in software engineering, but I request article
[[critical mass (software)]] to be written, explaining use of term ''critical mass'' in software engineering. A sentence linking to it might look nice after
the sentence...

"Many software products contain millions of lines of code that are expected to perform properly in the face of changing conditions."

...in [[software engineering]] article. I just can't find the words to write
it my self. --[[User:80.221.54.251|80.221.54.251]] 19:36, 25 May 2005 (UTC)

whooooo
{{talkarchive}}
== Previous comments ==
*[[Talk:Software engineering/Archive 1]]
*[[Talk:Software engineering/Archive 2]]
*[[Talk:Software engineering/Archive 3]]
:To prepare the article improvement, I have moved the previous talk page to [[Talk:Software engineering/Archive 3|Archive 3]]. Nevertheless, the whole talk archive (1-3) should be reviewed along with the improvement. --[[User:Hans-AC|Hans-AC]] [[User talk:Hans-AC|<font size="+1">&#9993;</font>]] 15:32, 26 May 2005 (UTC)

&nbsp;

== Question: What is the main similarity between a Software Engineer and a Programmer? ==

Answer: Neither one graduated from an engineering school

== Purpose ==

Would the paragraph in the entry for "Software Engineering" with the header "Purpose" not be improved by the inclusion of a sentence that begins with "The purpose of software engineering is..."


== EN sofware engineer ==

Does anyone know what "EN" stand for? Thanks

== Collaboration of the week?? ==
On May 20, 2005, I proposed [[Software engineering]] for the [[Wikipedia:Collaboration of the week#Software engineering (May 27)|collaboration of the week]]. I was wrong doing so, because I did not obeye the rule, ''only nominate articles which don't currently exist or are stubs''. Sorry.

Nevertheless, [[Wikipedia:Collaboration of the week#Software engineering (May 27)|have a look]] at the comments by [[User:ZeWrestler|ZeWrestler]], [[User:Water Bottle|WB]], and [[User:Dpbsmith|Dpbsmith]]. --[[User:Hans-AC|Hans-AC]] [[User talk:Hans-AC|<font size="+1">&#9993;</font>]] 15:32, 26 May 2005 (UTC)

&nbsp;

== [[Wikipedia:Article improvement drive#Software engineering|Article improvement drive]] ==

; '''Reason''' : There is a long [[Talk:Software engineering|discussion]] on the article with a lot of topics not cleared up to now. In my opinion, the article is not state of the art. It could be structured better and some sections could be moved to articles of its own. It should be a '''start page''' for all articles concerning with tthe topic and an introductory article for the '''[[Wikipedia:WikiReader#Software Engineering|WikiReader Software Engineering]]'''. Simultaneously, I propose a German collaboration ([[:de:Wikipedia:Qualittsoffensive#Software Engineering|Qualittsoffensive]]).

=== First step: copy to a rework page ===
I have just copied [[Software engineering|the whole original article]] to '''[[Software engineering/Rework]]'''.

Please feel free 
#to do your proposed changes at first in the [[Software engineering/Rework|Rework]] instead of the original,
#to insert any '''inline comment''' and include those comments in /* */
::/* like this */ 

Please contribute to the next steps! --[[User:Hans-AC|Hans-AC]] [[User talk:Hans-AC|<font size="+1">&#9993;</font>]] 16:32, 26 May 2005 (UTC)

&nbsp;

:Don't you want to move all this stuff below to the [[Talk:Software engineering/Rework]] page? Or has the whole thing just fallen into disarray? [[User:Brent Gulanowski|Brent]] 01:47, 18 October 2005 (UTC)

=== Second step: some section-reordering in Rework ===

=== Third step: coordinate Rework with previous discussion topics ===
... in [[Talk:Software engineering/Archive 1|Archive 1]], [[Talk:Software engineering/Archive 2|Archive 2]], [[Talk:Software engineering/Archive 3|Archive 3]]

=== Fourth step: find sections that can be moved to articles of its own ===

=== Fifth step: improve contents ===
This page could definitely be improved in the front-matter right at the top.  Software Engineering, as opposed to the formal discipline of Computer Science, puts much more emphasis on the full-lifecycle of development and (potentially long-term) maintenance of a software product.  Whereas most Computer Science-trained folks (those with undergraduate degrees in CS) tend to focus on the programming task -- and Computer Science as a discipline focusses on all the theoretical underpinnings of that task such as algorithm development, language specification, compiler construction, etc.,-- the formal discipline of Software Engineering sees programming as only one aspect of the effective development of a software product.  SE looks at Requirements Engineering, Software Design (high-level and low-level), appropriate design notations, test planning, formal Software Validation and Verification, Test Planning, Test execution, and quite importantly, the (oftentimes much longer and for some pieces of software, more costly) Maintenance phase.

Software Engineering thinks about developing and shiping the product that will meet the customer needs, in the required timeframe, and within the specified budget.

The fact that 60% - %80 of software projects (citation:  the Chaos Study from the Standish Group) fail to meet one or more of these criteria points up the need for considerable growth and advancement in the discipline of SE.

Aside:  the figure of 50 programs granting undergrad degrees sounds way high to me.  In 1997 when I formally researched it, there were only four universities granting such degrees (one was Rochester Institute of Technology; I don't recall the others).  There are many more graduate programs, but I have no idea the number.

I am sorry I don't have time to edit the article page at present, but I'll try to get back to it in the next few months.  The above info is a very quick stab at some needed perspective.  --[[User:N2e|N2e]] 16:03, 10 April 2006 (UTC)

=== Before-last step: coordinate [[Software engineering/Rework|Rework]] with newer changes in [[Software engineering|Original]] ===

=== Last step: replace [[Software engineering|Original]] by [[Software engineering/Rework|Rework]] ===

== *whistles innocently* ==

[[Image:Software development process.jpg]]

[[User:Project2501a|Project2501a]] 20:36, 24 July 2005 (UTC)

* Cute.  This is funny, no doubt, but can someone please explain to me why we have this nonsense in an encyclopdia entry?  It is childish at worst and uninformative to the novice at best.  Perhaps there could be a section for criticism of the ''industry'' as it stands today containing a subsection for humor, but certainly not at the top of the page.  It is the first thing that catches the attention of the reader, who is then left wondering what this silly comic has to do with software development.  Nevermind that requirements gathering, billing, project scheduling (all of which the cartoon pokes fun at) and so forth are ''not'' software engineering ''per se'', but are separate practices altogether which support many types of engineering.  I apologize for my tone, but I think it is warranted.  This is unbecoming of Wikipedia.  --[[User:MichaelAhlers|MichaelAhlers]] 15:29, 8 August 2006 (UTC)



== Information Quality Management ==

[[User:Adrius42]] added the following sentence fragment at the end of the first paragraph: ''A part of an emerging discipline of [[Information Quality Management]].''  I removed it because it isn't a compelte sentence and the article it points to needs work.  Is this term sufficiently common that it should be inserted and if so then where does it go? [[User:RJFJR|RJFJR]] 19:30, August 2, 2005 (UTC)


What is the point of this? It seems to be just like spam.

==Source for economic impact paragraph?==
; Economic : In the U.S., software drove about 1/4 of all [[Economics|increase in GDP]] during the [[1990s]] (about $90 billion per year), and 1/6 of all productivity growth (efficiency within GDP) during the late 1990s (about $33 billion per year). Software engineering drove $1 trillion of economic and productivity growth over the last decade. 

How about a ''source'' for this? I thought this was an area of ''intense'' debate among economists. The decade mentioned--the 1990s--leads one to ask, in any case, how much was real economic growth and how much was just the Internet bubble. [[User:Dpbsmith|Dpbsmith]] [[User_talk:dpbsmith|(talk)]] 17:19, 5 August 2005 (UTC)

:There were articles a few years ago, in both IEEE Computer and ACM Software Engineering Notes, that explained the size of software engineering. Both stated that software engineering accounted for $200 billion to $250 billion in the U.S. of ecomomic activity each year. However it was the federal reserve which stated that "computing" accounted for 1/2 of all economic growth over the late 1990s. Software has 10 times as many people as computer hardware. Software now costs more than hardware. So assuming that software has 1/2 of the impact of computing should be conservative. Just do the math. -- The Phantom Avenger for SE

== Process and methodology ==

Why is it that we have a section called "Process and methodology" and an article called [[Software development process]]? Are we not refering to the same thing? --[[User:K.Nevelsteen|Kim Nevelsteen]] 20:41, 23 August 2005 (UTC)

:The much of the [[software development process]] article was originally a section of this (SE) article. It was moved when this SE article got way too long. Then the process and methodology section started growing and changing into what it is today. They cover similar material. I doubt that any effort has been made for them to relate to each other. -- Phantom Avenger for SE
I would propose that maybe a commom article with the exact software development/engineering procedure should be made and that both articles link to it.--[[User:K.Nevelsteen|Kim Nevelsteen]] 15:28, 24 August 2005 (UTC)

:Sounds good.

== What is a software engineer? ==

I have noticed that a lot of the other articles link to this one under the term a "software engineer". I can understand that software development is now sometimes called software engineering, but what is a software engineer exactly and what makes him different than a [[programmer]], [[software developer]]/analyst, [[Lead programmer]], [[systems architect]], [[project manager]]? I have personally met people in each of these positions, but I have not met a person that is a software engineer that can state what he does differently than any of the ones I have just stated. At my university there is not a degree for a software engineer, yes one for an industrial engineer and also one for a software developer/analyst, but not a software engineer. To my knowledge it seems to be a title created for those that just feel a little bit better than software developers. Can someone please clarify?--[[User:K.Nevelsteen|Kim Nevelsteen]] 15:40, 24 August 2005 (UTC)

:The last sentence in the intro section says, "There is extensive debate about what SE is, who qualifies as an SE, who sets the standards, etc." Nobody can give you the definitive answer today, though many people have strong opinions. This is a big problem for this page, because people who advocate one answer sometimes try to impose their favorite answer on this page. -- The Phantom Avenger for SE

::It's all quasi-political, quasi-religious. 

::Some of it is probably related to academic infighting. There were fights when people wanted to establish "computer science" departments at universities&mdash;traditionally the stuff had either fallen under "mathematics" or "electrical engineering." How could there be a "science" of computers when computers do not exist in the natural world? Once "computer science" was established, there was then the problem that computer scientists are more interested in studying finite automata or proving theorems about programs than in the nitty-gritty of making million-line payroll programs work, so "software engineering" needed to be invented.

::Some of it is an advocacy term. The implication is that there is a set of disciplines and "best practices" which, if followed, will allow armies of average programmers to crank out huge software products that are reliable and can be delivered on-schedule and under budget. 

::You will notice that the general "tone" of this article is quite different from that of other engineering articles. [[User:Dpbsmith|Dpbsmith]] [[User_talk:dpbsmith|(talk)]] 19:58, 24 August 2005 (UTC)

:A software engineer is anyone who says they are one, or alternately, that some authoritative body identifies as one. I don't want a definition of "software engineer" so much as I want a description of what a typical software engineer does. Words have definitions, true, but phrases that refer to some kind of activity (or role) resist abstract definitionjust describe the activity! That would provide some idea of what software engineering was. Moreover, one could then write down what a programmer does, and also what a software developer does, and compare them and see if anything comes of it (like, they're all the same, or that some go to more meetings, or something). There is definitely a lot of commonality in the effort of creating software, regardless the nomenclature, since a lot of software gets created, and mostly in similar ways. [[User:Brent Gulanowski|Brent]] 02:06, 18 October 2005 (UTC)

::Although I happen agree that "a lot of software gets created, and mostly in similar ways," I believe those who use "software engineering" as an advocacy term would strongly disagree. They would assert (incorrectly) that there is a difference in kind between the sort of creative art/craft small-team-of-bright-individual programming that produced e.g. the original Mac OS and what SEI CMM 5 organizations do. [[User:Dpbsmith|Dpbsmith]] [[User_talk:dpbsmith|(talk)]] 09:36, 18 October 2005 (UTC)

:::In which case, documenting the controversy about software engineering is more important to the Wikipedia than trying to resolve it. But I challenge any software engineer to deny that you'd have engineered software without programmers writing code and compilers compiling it. I personally don't think that software engineering is different in kind, only in degree, but maybe even that's moot.

:::So, how about an article with this gist: "Software engineers make software. What makes them different from other people who make software is subject to vociferous debate. Some people think software engineering is a loaded term. Some think it is an oxy-moron (or just nonsense). Others (X number of self-described software engineers amongst them) think it's an important and valid distinction. Many have said that software errors are bad, and that something needs to be done to avoid them. It seems to be taken for granted that making software gets harder the more complex it is (exponentially so?), so highly managed techniques are an attractive way to attempt to control the complexity. Pro-software engineering camps favour systematic approaches in line with other engineering disciplines, as well as similar accreditation and the like. See other articles for different opinions about how to increase software quality/reliability." [[User:216.234.42.2|216.234.42.2]] 20:41, 18 October 2005 (UTC)

::::Well, '''I''' like it. I trust you can dig up [[Wikipedia:Cite your sources|source citations]] to show that there are camps holding each of those opinions... I just noticed that SEI now disowns the entire CMM model and has a New Improved model. I'll bet the organizations that spent good money getting to CMM Level 5 are really pleased to know that their certifications are garbage and it's time to hire a consulting to help them qualify for CMMI certification... :-)   [[User:Dpbsmith|Dpbsmith]] [[User_talk:dpbsmith|(talk)]] 22:31, 18 October 2005 (UTC)

For Wikipedia internal consistency, if this article is to remain entitled "Software Engineer" it could read like and perhaps even reference the Wikipedia "Engineer" article. The "Engineer" article currently states, "An engineer is... a person who uses scientific knowledge to solve practical problems using technology." If it is postulated here that "Software Engineer" is a specific example of the general category "Engineer" in the same manner that "Automotive Engineer" is a specific example of "Engineer" then the difference between "engineer" and "builder" becomes somewhat clearer. 

According to this definition, what distinguishes a "software engineer" from a "software developer" is the application of "scientific knowledge". Scientific knowledge is that type of knowledge that is measureable, repeatable, public (published), peer reviewed, and accepted as fact, or at least factually backed theory. I can personally build a car (or dune buggy, or at least a go-cart) by going into a scrapyard and sort of copying what I see. I can probably build it faster and cheaper than a regular car. Furthermore, there is certainly nothing wrong with building a go-cart for private use, and there should never be any legal restrictions on doing so. It may be a fine vehicle, even a thing of beauty - but it likely wouldn't be generally accepted as being "engineered" and legally roadworthy. In contrast, I could read a large body of knowledge on car design, and perhaps even get certified in that BOK, which may be time consuming and annoying and indicate some commitment to a long-term career in that field. I also then have to commit to following generally accepted scientific principles regarding effective automobile construction that meets specifications including socially accepted codes for safety, comfort, limits on permissable uses of toxic materials, acceptable stopping distances etc etc. Complete overkill for a go-cart. Not entirely necessary for the dune buggy that me and my buddies are going to run in off-road settings. Completely legitimate if human safety, large volume sales, and/or a business is at stake. 

The gist for me then is not whether there is a role called "software engineering" - but rather "is software engineering a common practice, or more of an exception"? I don't know the answer to this, but I know I want to fly in planes where the engine control software was "engineered". I want to do my banking with software that was "engineered". I don't care if thousands of people write tons of cool programs for tons of cool purposes and even distribute them for free. That's probably even a good thing. Especially if it's a cool game. But if that cool free game bungs up my home computer, then I'll be mad anyway, even if its free. 

I hope my little diatribe sheds some light on the above comments and implied questions as well, particularly the initial para by K. Nevelsteen.
[[User:ThreePD|ThreePD]]

Slightly related, I am curious to know which software engineering methods have been used with the Linux development model [section Software engineering today].  Traditional software engineering methods have emphasized the importance of specifications/requirements documents, but the Linux project has been able to deliver a solid piece of software without the use of these.  If the software engineering methods used by Linux is documented somewhere, it would be helpful for future projects, especially open source ones.

I am a software engineer, The difference is simple, i have a degree on my wall that says software engineer. Those who have an engineering degree are engineers. you can't be an engineer without an engineering degree from a university. let me give some examples. a construction worker is not a civil engineer. a construction worker with 10 years of experience may know more than a new grad civil engineer. but the construction worker is still NOT a civil engineer. if you have an engineering degree your an engineer, otherwise your are not. an electritian is not an electrical engineer. an electrician with experience can know more than an electrical engineer. but the electrician is NOT an electrical engineer. a factory supervisor can know more than an industrial engineer, but he is still NOT an industrial engineer. there are many more examples from every engineering discipline. and more. hope that helps. the difference in the job they do doesn't matter, anyone can do anyone's job with enough practice. if you see a Surgeon do an operation 50 times, you will be able to do it yourself. does that make you a doctor? clearly NOT you have to go through med school first.


Okay... and what about a Software Quality Engineer?? This new term that has come up in the IT industry -- is a Quality Engineer also a Software Engineer? --[[User:221.134.24.63|221.134.24.63]] 19:36, 21 May 2006 (UTC)

I'm one of those guys writing "Software Engineer" as profession. what's the difference? why do i use this term? It's quite similar to the difference between a construction worker and the architect. even with years of experience the first one will be able to build you a good wall, but letting him build a bridge will get him to his limits. missing knowledge about scientific methods like statics. and the architect will most probably not have the ability to build you a nice wall (even with years of experience), but with his science background he will be able to plan and (hopefully) also supervise the building of large constructions. he will even be able to tell you in advance if the construction will sustain heavy storms. because he knows the numbers. while the construction worker will tell you by experience for his wall if it is strong enough for certain strains. Additionaly the REAL BIG DIFFERENCE is: the architect (at least here in Switzerland) has by law to take responsibility for his construction!!! So for simple software the software engineer is often not evidently superior to a programmer, but when the problem gets larger (and we engineer defend our jobs with the story "most software grows with time and gets larger than ever expected") the programmer ends up with a limit of complexity he can manage. the engineer is prepared to see problems in algorithms sooner and should use more appropriate ones, while the programmer leak of knowledge leaves him clueless. so far in theory, but there is also experience and the difference in quality of studies. Saw already a certified informatic engineer going through the same studies like me and having a quite blurred knowledge about object-orientation and others with such degrees writing very bad code. in practice software engineer studies should give you a very precious scientific background to recognize problems earlier, simply because you know them! a construction builder will not see statics problems because he simply does not know them, but learns it in practice, step by step and most probably not reaching the amount of knowledge, the architect learned by studying statics models. This is simply a transfer of knowledge build up in decades or centuries from earlier constructors/architects. <br>
But still: Universities give you a distilled knowledge about the topic from experience of your predecessors, but those studies are only fruitful with practice! finally with practice/experience you can apply this knowledge. in software engineering i would say: yes, it is superior, but without practice it  stays theory and who wants a theoretician?<br>
So i use this term to distinct myself with one point: engineer means "responsible body", i am aware of and taking the responsibility for the task, not just "executing commands" and being one of the construction workers. why? because i can estimate the effort and problems by having the scientific knowledge AND experience. The university degree usually asserts the former, but only with addition of the latter you get what i respect as a real software engineer. Too bad often people use this phrase just because of their studies.<br>
So i disagree that by default a software engineer is better than a programmer, just agree that he has also the scientific knowledge, but only with experience he gets better and able to take the responsibility. <br>
So you could do a doctor's work after having seen the operation 50 times, but without the title you will not be able to take the responsiblity, because if somethings fails during the operation, you are mostly clueless, you can only reproduce the steps you saw. why he did it or what you have to do now because something failed? you don't know. by knowing how the human body works, you can estimate what merely went wrong, you are "prepared" for deviations from standard proceeding, you get in sich situations on your own and have to take decisions. got it? the construction worker could try to build it, but on problems beyond his scope he's clueless, like you as a doctor replacement. while the doctor and the architect know the models of human body resp. statics and can estimate what's going wrong, see first signs and take decisions to avoid those problems because they happen.<br>
same for the engineer, building a software he should see issues about security and performance, because of his scientific know-how. the programmer can build something that runs, but if without the know-how he will not even be able to see security or performance issues in his product, while an engineer (with experience) may see it at once and take decisions before the issues turn up in production... (User:anonymous, 15:00, 4 April 2007 (CET))
My opinion is that SE is not yet a mature discipline. There are still too many semantic gaps when moving from goals to business requirements to system requirements to etc. ... to code. What is msiing is the rigour of translating the conceptual design (and rigorously designing the conceptual design) eventually to code with minimal semantic loss. This implies that the design itself should be mostly semantically complete and specified in some standard 'engineering' languages (/models). I realise that much work still needs to be put into software generation, architecture designs, automating requirements engineering/tracking/validation, business process specification standards, etc. Not to mention bring all of these together so that software can be built (or generated) as designed. It is this rigorous design that I would consider as being Software Engineering. It all starts with requirements practices and 'engineering' the necessary metamodels and ontologies that will deliver the required knowledge bases and requirements models that will drive software design. [[User:MetaAnalyst|MetaAnalyst]] 09:02, 12 July 2007 (UTC)

:I added a <nowiki>{{seemain|</nowiki>[[Controversies over the term Engineer]]<nowiki>}}</nowiki>. I think it is relevent and can clear up a few <nowiki>{{fact}}</nowiki> tags in this article, I am just not positive I placed it in the correct location. <font style="background-color:#ddcef2;font-weight:bold;color:#000;">[[User:Exit2DOS2000|Exit2DOS2000]]</font><small><small><sup>[[User Talk:Exit2DOS2000|T]][[Special:Contributions/Exit2DOS2000|C]]</sup></small></small> 20:09, 28 September 2007 (UTC)

== Relationship to (Dependency On?) Definition of Computer Software ==

Hi. I'm a trifle concerned (and amazed) that so much energy is expended on arguments about "Software Engineer" when one of the operative terms[[Computer software|Software]]has an article on Wikipedia which is so wanting. It seems obviousif only to methat it's very difficult to define a term like "Software Engineer" without first getting an explicit consensus on the nature of software. I guess it's just too obvious to everyone else. Even if I'm off base, that page needs attention, and maybe it would be a good day off for some of the participants around here. And if the nature of software is so obvious, it's a shame that the page is so poor, since it would be a low-hanging fruit.

The weird irony is that instead of paying sufficient attention to a discussion of software, a lot of energy has seemed to go into creating a long list of kinds of software. Are software engineers feeling so slighted that they feel a desperate need to advertise? I've never found lists of examples of a type did much to explain the deeper nature of the type. And with something like software, where the end product is only the tip of a very large iceberg (hence the energy expenditure to understand and describe the act of its creation), the futility of such a list is even more pointed. A proper definition deserves better attention in the Wikipedia.

A while back I added a bunch of stuff to the [[Talk:Computer software]] page, hoping it would attract some more attention. I have ideas about what to do, but I'm new at this and can only drop in periodically, so I could use some help.[[User:Brent Gulanowski|Brent]] 01:11, 18 October 2005 (UTC)

: Please avoid the mistake of confusing a concept with the words and letters that describe the concept. For example "engineering" is not "enginee" + "ring" which might be the interpreted as "engines that make rings" or something else silly. There are not a lot of rings in most engineering. Likewise, "software engineering" is not "software" + "engineering". SE almost never uses differential equations, or phyics or chemistry. And SE is not just a fancy version of software. Software engineering is its own field, with its own history, ideals, tools, conventions, etc. That is why this article struggles so hard to define itself. -- Phantom Avenger for SE

::Computer hardware engineering doesn't necessarily make heavy use of differential equations, physics, or chemistry either (unless you're talking about low-level semiconductor device design). They're more likely to use boolean algebra and other discrete formalisms. By the same token, there are many aspects of signal processing (nominally an electrical engineering discipline) that make minimal use of differential equations or chemistry. Engineering is not defined by differential equations (even if many engineering math textbooks might lead you to believe otherwise), or continuous mathematics in general. Nor is it defined by a tie to physics or chemistry. Engineering is a pragmatic approach to solving design problems. 
::The reason that SE ''seems'' different from other engineering disciplines is that other engineers (pragmatically) use appropriate mathematics and scientific results to understand what their designs will do ''before'' integration and test time, while many self-professed "software engineers" are loathe to use any form of mathematics and restrict their use of science to experimentation with different implementations to find something that will work. Which is not to say that there aren't developers that actually "engineer" their software (e.g. by using [[Communicating sequential processes|CSP]] to evaluate a design for deadlock prior to committing to implementation, or performing some prototyping so that they can make throughput measurements that can be extrapolated to a finished system, or using relational database theory to help them develop a good design). They're apparently just somewhat rare. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 22:19, 2 March 2006 (UTC)
:::If software engineering was so close to traditional engineering, like you say, then companies would gladly hire civil engineers or mechanical engineers to do their programming and software project management. But, companies don't, because software has almost nothing to do with engineering. Rather, companies hire computer science and IT and all sorts of other professions to do programming and project management, because that is what software engineering really is.
:::The reason software engineering don't use a lot of math, is because the logic and deduction that they use every day is not considered real math by engineering snobs. And software engineers don't use calculus or physics, like engineering snobs. -- The Phantom Avenger for SE

::::By your logic, electrical engineering apparently isn't engineering either, since few companies are likely to hire a civil engineer to do analog circuit design and microprocessor design project management. Yet EE ''is'' engineering, jsut as SE is engineering. What makes all of these things engineering are shared underlying principles related to how to solve problems and how to design things. What separates them is domain knowledge. 
::::There are a number of reasons that companies hire people other than software engineers to do their programming. Among those reasons are: CS grads have the requisite domain knowledge, and nominally learn some engineering design principles; engineering encompasses more than just programming and all the company needs is programming; some companies don't need (or don't realize that they need) software to be engineered &ndash; any random hack that works will be acceptable.
::::Any "engineering snob" that thinks that the math behind software engineering isn't "real math" has apparently never encountered [[category theory]], [[type theory]], [[process calculi|process calculus]], or [[algebraic specification]]. And I say that as a trained engineer (EE and Aerospace Eng. degrees). --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 21:23, 5 March 2006 (UTC)
:::::I have spent almost my entire life in software and software engineering, and I am still amazed at how often EE and aerospace engineers try to tell me what my job is. Usually, it is related to a statement about "engineers do this, so software engineers should do it to." For example, the CACM published an article recently about how when software engineers finally get "real engineering practices" there will be no more cost overruns in software projects. Also, the Tau Beta Pi passed a constitional ammendment stating clearly that CS is not adequate to join their engineering honor society. This says as a loud as possible that I am not an engineer, even though I am an SE. The Tau Beta Pi is full of engineering snobs. <small><span class="autosigned">Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[User:204.134.9.4|204.134.9.4]] ([[User talk:204.134.9.4|talk]]  [[Special:Contributions/204.134.9.4|contribs]]) </span></small><!-- Template:Unsigned -->

:::::: Well, I'm sorry if you've had bad experiences with engineers from other disciplines who do not understand sofwtare engineering. All I can tell you is that, having been educated as an engineer, and worked in both software engineering and other engineering fields, I see a lot of similarities in approach but an obvious need for differences in analysis tools. IMHO software engineering is as much engineering as any other engineering discipline (whether or not every "software engineer" uses good engineering practices is a separate question). I'm not alone in this: software engineering luminaries such as [[David Parnas]] and [[Steve McConnell]] also hold this view. The fact that the IEEE publishes a ''Transactions on Software Engineering'' would seem to indicate that the IEEE feels the same way.
:::::: I've recently been working my way through [[The Pragmatic Programmer]] again, and am constantly struck by how much of the content is great advice for practicing engineers in any discipline (I wish someone would write ''The Pragmatic Electrical Engineer'' in the same style and with similar content). But then I guess that shouldn't be surprising, since engineering is fundamentally just "pragmatic design of useful products". --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 21:33, 9 March 2006 (UTC)
::::::: The question is not whether there are similarities, of course there are. There are also many differences. There are also similarities to creative writing.
::::::: The more interesting thing is that there are almost as many software engineers as there are traditional engineers combined. Software engineering is a big, important, long-lived pofession, that does not need to be defined in terms of traditional engineering. The people who seem to claim SE as engineering mostly seem to be wannabes, who disrespect the legacy of software engineering. There are over 10 times as many software engineers as computer engineers. We don't need CEs or EEs telling us what SE is all about. We don't need your condescension. - Phantom Avenger for SE

:::::::: Sure. But there are also differences between other engineering disciplines. It's the similarities that make them all "engineering". And yes, there are undoubtedly, at a more abstract level, similarities between every kind of creative endeavour.  That doesn't change the fact that "engineering" (regardless of the discipline) has [http://www.tcnj.edu/~rgraham/whatare.html certain common concerns] that are not shared with other creative endeavours.
:::::::: I wouldn't call David Parnas a "wannabe" who "disrespects the legacy of software engineering" &mdash; he helped create a lot of the legacy to which you are referring. So I'm not quite sure what you're trying to get at there. 
:::::::: I'm also not sure why you are trying to create some kind of artificial dichotomy between "software engineering" and "traditional engineering". For starters, there isn't really any such thing as "traditional engineering". There are some traditional disciplinary divisions, but even those are hazy (many control engineers come from an ME background, many others come from an EE background), and the field is constantly evolving (disciplines like aerospace engineering and computer engineering are not all that much older than software engineering, and disciplines like [[biomedical engineering]] and [[nanoengineering]] certainly post-date SE). As I've said several times now, it is the commonalities between all of these disciplines that makes them all "engineering", and suggests that there may be knowledge and principles that can be usefully shared between them. That was certainly the rationale for the naming of the [[List_of_publications_in_computer_science#Software_engineering:_Report_of_a_conference_sponsored_by_the_NATO_Science_Committee|1968 NATO Software Engineering conference]] that helped popularize the term "software engineering". If you don't believe that SE has anything in common with other engineering disciplines then I have to wonder why you insist on calling it software ''engineering'' (as opposed to software development or some other term that doesn't connote a relationship with engineering).
:::::::: Having said all of that: the debate about what SE actually is has been going on for decades (as this article makes quite clear), and the odds of us resolving the argument here seem pretty minimal. Not to mention taht it's not really what talk pages are meant to be used for. So, thank you for discussing this issue with me, and please don't be offended if I don't participate any further in the discussion. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 01:27, 10 March 2006 (UTC)
::::::::: There are similarities and differences. However, I did not choose the word engineering, nor did I choose the things I actually do on the job. These things emerged on their own. But, software engineering is still completely from engineering, as the Tau Beta Pi, the National Academy of Engineering, and other traditional engineering organization prove everyday, by deliberately slandering computer science and software engineering. I did not start this. Traditional engineers did.
::::::::: I note that you end up by saying "If you don't believe that SE has anything in common with other engineering disciplines then I have to wonder why you insist on calling it software engineering" which is analyzing a field by the words, and not by the reality. This is typical for engineering, but poor analysis. -- The Phantom Avenger for SE

I noticed that the article argues that Dijkstra considered software engineering to be a branch of mathematics.  I disagree.  In 1989 Dijkstra called SE "The Doomed Discipline", and he wrote that SE has accepted as its charter, "how to program if you cannot" (Dijkstra, Edsger W. (1989) On the Cruelty of Really Teaching Computer Science. Communications of the ACM 32(12): pp.1398-1404). Dijkstra considered comput''ing'' science to be a branch of mathematics  --[[User:Mmeri|Matti]] 10:02, 10 July 2006 (UTC)

== Software engineering vs software architecture vs software design? ==
I hate to sound like a pedant, but can anyone shed light on the relationship (if any) between the following disciplines (or are they practices?):
* [[Software engineering]]
* [[Software architecture]]
* [[Software design]]
--[[User:Richard@lbrc.org|Richard@lbrc.org]] 17:07, 3 January 2006 (UTC)
===Answers to questions of life, the universe, and software engineering===
Sure, at the risk of near certain critique, I'll give it a whirl - but from a bottom up perspective, and including the more foundational term you avoided in this recurring list.
*'''"Software programming"''' indicates an activity of forming a software program which means producing at least some piece of a special syntax language (code) that can provide instructions to a computer. Several different languages and techniques are available.
*'''"Software design"''', in contrast, indicates an activity of designing, which means forming an arrangement of software components that fulfils some specific purposes. It implies that the software program has achieved a degree of complexity that warrants decomposition into smaller "blocks" or "modules" that require arrangement. This deliberate arrangement attempts to achieve some of its own purposes that are commonly known as design criteria or non-functional requirements, such as safety, performance, maintainability, or simply aesthetics. Preferably there is a documented artefact that describes the "arrangement" and how well it meets its design criteria.
*'''"Software architecture'''" is often misunderstood as high level software design, but it actually represents the overall approach taken to the design activity (for example following a multi-threaded distributed task architecture with priority pre-emptive scheduling). These top-level architectural decisions inform the design at every layer of abstraction and must be consistently applied within the intended scope in order to achieve the desired end-results. For example "Baroque" is quite a different building architecture than "Multi-unit efficiency", although each has its own merits and schools of designers. Designs are specific manifestations of those architectures. I can speak about a software architecture without pointing to a particular design.
*'''"Software engineering"''' is an engineering discipline that seeks to study the sciences and technologies involved with the practical development of software in order to better apply those sciences and technologies towards greater success. Software engineering includes the practice of defining important terms and relationships between terms (forming relevent ontologies), as well as discussing the merits of the various architectures, designs, and programming languages and techniques that are available. The idea is to form a publically available Body of Knowledge (BOK) about the discipline. There are of course various schools of thought within this BOK. Correct application of software engineering generally depends on possessing detailed knowledge about both the available techniques and the domain area under consideration. The debate about the nature of the SWE BOK (software engineering body of knowledge) is part of the BOK itself. This is also the case for any discipline including philosophy and history.

[[User:ThreePD|ThreePD]] 21:24, 4 February 2006 (UTC)

My over-simplified perspective: 
*'''Software programming''' - Writing code. Flow-charting would not be considered programming, but programmers may develop and use flow-charts. 
*'''Software design''' - Developing specs, planning and problem-solving for artistic form and user-interface experience (both predictable and subjective). [[Design]]s may or may not include engineering.
*'''Software architecture''' - Planning and problem-solving (including flowcharts) for the '''''broader computing structure''''' of code-driven functions based on design specs.
*'''Software engineering''' - Planning and problem-solving (including flowcharts and code) for '''''all computing structure''''', code-driven functions and scientifically predictable user-interface experience based on design specs.
That's just my take. But since I'm none of the above, I may be wrong. I'm only posting this because anyone concerned needs to know how it may appear from the outside looking in. It is just one perspective. [[User:Oicumayberight|Oicumayberight]] 22:23, 26 October 2006 (UTC)




Hello i'm a master in Computer Science and i would say:
Software engineering is a problem solving activity that solves problems with software.
This will result in a software architecture, or if you would like: the software design.
( design of the system en the architecture of the system are just equal, only in the
cs community we are using the term 'architecture' more often ).
Software programming is the actual work that implements your architecture/design.

Just like laying the bricks to build a building ( the bricks must follow the architecture of that building).

[[User:TjerkWol|TjerkWol]] 22:20, 14 February 2007 (UTC)

:Since design is a process as well as a product of that process, where do you make distinction between design and engineering? [[User:Oicumayberight|Oicumayberight]] 22:28, 14 February 2007 (UTC)

:: well i see design only as a product. Software engineering also involves design ( as a process) but it involves more, like requiremetns gathering and software testing. [[User:TjerkWol|TjerkWol]] 14:19, 27 March 2007 (UTC)14:19, 27 March 2007 (UTC)

:::Designers gather requirements and test solutions too, just not in every case. [[User:Oicumayberight|Oicumayberight]] 18:19, 27 March 2007 (UTC)

== State of the ART ==
I would like to give a presentation on a new topic in SE , any suggestions ? Thanks

== Education ==

Someone keeps modifying the description of '''Software degrees''' in the education section to say that 
:''About half of all practitioners today have computer science degrees '''with detailed knowledge of hardware.''''' 

AFAIK, the majority of CS programs do not teach "detailed knowledge of hardware" - hence the term "software degree". Can whoever keeps making this modification provide some kind of evidence that 
# There are a significant number of CS degrees that teach "detailed knowledge of hardware".
# That about half of all SE practitioners have received such degrees.
--[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 14:49, 12 April 2006 (UTC)

== Reference, please? ==
I would really appreciate a citation for the statistic stating that the Boeing 777 has X many processors and 5 million lines of code.  I happened to find the statistic "2.5 million lines of code" in a CMU article (http://www.sei.cmu.edu/str/descriptions/ada83_body.html), but that author was citing someone else, using URLs that (when I checked) were dead.  Anyway, it would be nice to have a source for this quote, because I'd like to believe it and I'd like to use it in some presentations.
-- [[User:LandruBek|LandruBek]] 11:09, 20 April 2006 (UTC)

:I don't know where the previous material came from. Unfortunately I mistook the reason for your query. In the context of the article, believing that facts should be sourced, I replaced the unsourced statement with a different one--properly sourced--to the effect that an airliner has several million parts, and the space shuttle has ten million. The two point here is that software is ''roughly comparable'' in complexity to the most complex physical objects.

:The unsourced sentence I removed was:

:(The Boeing 777-200 has about 132,500 engineered and unique parts. Including rivets, bolts and other fasteners, the airplane has more than 3 million parts. Included are approximately 1400 data processing units and 5 million lines of code.)

:[[User:Dpbsmith|Dpbsmith]] [[User_talk:dpbsmith|(talk)]] 15:22, 20 April 2006 (UTC)

::I too have no idea where the previous data came from. However, I've added a sourced SLOC count of 4 million lines of code for the Boeing 777. This comes from a [http://www.stsc.hill.af.mil/crosstalk/2006/04/index.html CrossTalk] article written by Boeing's Manager of Embedded SE for the Commercial Airplane Group. The actual breakout is (from [http://www.stsc.hill.af.mil/crosstalk/1996/01/Boein777.asp the article]) ~2.5 MSLOC of new code, and ~4 MSLOC inclduing COTS and optional software. I have no idea how many processors the 777 has though.  --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 17:11, 20 April 2006 (UTC)

== Unsourced material about economic impact ==

The material below has been unsourced for a long time. It shouldn't be in the article unless there is a source. (And, saying "reliable statistics are hard to find" is not a substitute for finding them!) [[User:Dpbsmith|Dpbsmith]] [[User_talk:dpbsmith|(talk)]] 16:27, 16 May 2006 (UTC)

Material removed:

:Economic: In the U.S., software drove about one quarter of all [[Economic growth|increase in GDP]] during the [[1990s]] (about $90 billion per year), and one sixth of all productivity growth (efficiency within GDP) during the late 1990s (about $33 billion per year). Software engineering drove $1 trillion of economic and productivity growth over the last decade. Around the world, software drives economic growth in similar ways, though reliable statistics are hard to find.

An anonymous user reinserted the above text, and added a "source" for the statistics. However, after looking at the source in question (Raccoon, L. B. 2001. Definitions and demographics. SIGSOFT Softw. Eng. Notes 26, 1 (Jan. 2001), 82-91. DOI= http://doi.acm.org/10.1145/505894.505914), I have again removed the text in question. The article by Raccoon does not support the text in any way, and in fact does not appear to contain ''any'' mention of GDP or economic growth. 

I have also again removed the "peacock statement" on social impact that was reinserted after [[User:Dpbsmith|Dpbsmith]] removed it. [[User:Dpbsmith|Dpbsmith]] is right: this is a vacuous "peacock statement". Nor has any [[WP:CITE|source]] been provided for this statement. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 19:13, 17 May 2006 (UTC)


== #1 on Google ==

Wikipedia is now (finally) the standard authority for information on software engineering. I just searched on Google for "Software engineering" and this page for the first time (that I have ever noticed) came up in the #1 slot. Note that most other search engines did this long ago. <small><span class="autosigned">Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[User:216.184.31.126|216.184.31.126]] ([[User talk:216.184.31.126|talk]]  [[Special:Contributions/216.184.31.126|contribs]]) </span></small><!-- Template:Unsigned -->

== Applications or Systems? ==

The first sentence says that SEs write "systems" when it used to say "applications". I find that system is a blah word that refers to complex things of unspecified nature. Application is far more concrete. SEs write word processors, but are word processors systems? Is a video game a system? Is a flight control application a system? The answer is partly yes, but seems so unsatisfactory. I think it should be reverted. -- Phantom Avenger for SE

:Are you suggesting that SEs don't write, for example, operating systems? Or is it your contention that an OS is an application? --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 17:21, 14 July 2006 (UTC)

::For my money, dump the word system and leave it as "... create and maintain software by applying ...". A software engineer can engineer software components without ever producing something that would be called a system. For example, a library developer, etc. -- [[User:Munchtipq|Munchtipq]]

:::Works for me. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 14:36, 7 August 2006 (UTC)

== Pervasiveness in missions requiring 'absolute' reliability ==

Re that statement, I meant not that software is often found -- as an essential component-- in missions requiring high reliability (my claw hammer has no software), but rather that software often finds itself in such situations.  That idea is so pervasive that I would think a citation is not needed.  Providing one would be low priority for me (unless I come across one by good chance). Anyone feel free to revise, revert or provide cite. [[User:Vincehk|Vincehk]] 03:09, 27 August 2006 (UTC)

:If the idea is so pervasive, then it should be easily [[WP:V|verifiable]] :-) --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 14:57, 27 August 2006 (UTC)
== add'l comments ==
It might be useful to reference the SWEBOK effort, including Notkin, Gorlick, and Shaw's dissent:

  http://www.acm.org/serving/se_policy/bok_assessment.pdf#search=%22swebok%20shaw%22


gotta mention CMU SEI's CMM.

== Advocacy definition ==

It looks to me as if the "advocacy" definition of software engineering was there before the IEEE definition was added. I thing the IEEE definition should have '''replaced''' the advocacy definition, since it is exactly what was being advocated; i.e. "software engineering" did not refer to the advocacy itself but rather to what was being advocated. I would therefore suggest deleting the advocacy definition, but I didn't want to do that without checking, after someone had gone to the effort of finding a citation.
--[[User:Boson|Boson]] 17:51, 19 October 2006 (UTC)

==Questions from the jury==
Is there any part of the software development process that is neither administrative or engineering? [[User:Oicumayberight|Oicumayberight]] 22:39, 24 October 2006 (UTC)

:The easy answer is that programming is neither "administrative" nor "engineering". (The whole point of "software engineering" is to make programs.) According to people like Dijkstra, writing programs is more like mathematics than anything else. The hard answer is that there is a huge debate over what "engineering" means and how it applies to "software". This page details some of the debates. Then, of course things like "requirements analysis" and "testing" apply to many fields beyond SE and engineering, so depending on point of view, they may not be either. -- Phantom Avenger for SE

Next question: Should everything that attempts to accomplish anything be called engineering? Would it be accurate to call parenting or spousehood, "family engineering?" [[User:Oicumayberight|Oicumayberight]] 21:24, 26 October 2006 (UTC)
:I would say that the term "engineering", in its literal sense, can only be applied when the main product of the process is the result of significant intelligent design by persons, even though the '''process''' may also involve activities involving humans rather than artificial objects. This would apply to machines, computer hardware and software, probably even bridges, roads and buildings,  though all involve '''application''' of theories and methods, project management, definition of processes, getting things to work, etc. It would apply particularly if the product functions or operates in a way that has been specified in detail by humans (like a nuclear reactor or the software used to control it). In an extended sense, the term "engineering" could also be applied to biological systems if they are deliberately manipulated on the basis of defined methods and theories (e.g. "genetic engineering").  --[[User:Boson|Boson]] 23:16, 26 October 2006 (UTC)
::Would this mean that work to achieve indefinite (open-ended) goals and expectations would fall under the category of "art" not engineering? [[User:Oicumayberight|Oicumayberight]] 00:12, 27 October 2006 (UTC)
:::I don't see that the goal (rather than the immediate function) is particularly relevant, but I may have misunderstood. I suppose one might draw a distinction between civil engineering and architecture based on the relative importance of operation or functionaity, rather than aesthetics, if that is what you mean.

:Your question is a good one, which is very, very hard to answer. There are lots of debates over *how* to define "engineering". It might be a tradition, a guild, an ideal, etc. This page details some of the complexities, as far as software is concerned. But, I don't know of any way to give a definative answer. -- Phantom Avenger for SE <small>The preceding [[Wikipedia:Sign your posts on talk pages|unsigned]] comment was added by [[User:216.184.13.211|216.184.13.211]] ([[User talk:216.184.13.211|talk]]  [[Special:Contributions/216.184.13.211|contribs]]) 00:15, 31 October 2006  (UTC{{{3|}}})</small>

== images ==

[[:Image:Software spanner.png]] is a nice picture, but it is not informational and adds no information to the article. It only adds some aesthetic value. Can we find a picture that adds both aethetics and useful information? [[User:NerdyNSK|NerdyNSK]] 21:05, 28 October 2006 (UTC)

=="Very few traditional engineers bother with any form of certification"==
I'm removing
:Others point out that very few traditional engineers bother with any form of certification.
because it's nonsense. See [[Professional Engineer]] and [http://www.nspe.org/ National Society of Professional Engineers]. 

50,000 credentialed professonal engineers in the United States is not "very few." 

In many states in the United States it is not even legal to advertise yourself as an "engineer" unless you hold a PE certificate. [[User:Dpbsmith|Dpbsmith]] [[User_talk:dpbsmith|(talk)]] 18:20, 1 December 2006 (UTC)

:While I'm not defending the statement you removed (it's unreferenced opinion), it's worth noting that the truth of the statement largely depends on what you mean by "traditional engineer" (which IMHO is a worthless term - but that's another argument). While PE certification is certainly popular (or even mandatory) in certain engineering disciplines, it gets hardly any attention in others. I've worked as an engineer in the space industry, and few of the engineers I knew there bothered to become a PE. The same goes for a lot of the electrical and embedded engineers I know in my current line of work. Having a PE is helpful in situations where (a) public safety impacts of the product are a concern (e.g. civil structures) and you need to be able to legally sign off on having met safety requirements, or (b) you want to have legal standing to testify as an expert witness. Things like satellites and consumer electronics generally don't have the kind of public safety requirements that necessitate a PE, and so a lot of engineers in those fields don't bother to get a PE. The [http://www.bls.gov/oes/current/oes_nat.htm#b17-0000 BLS occupational employment stats for 2005] show over 1.4M people employed as engineers in the US, which means that the 50,000 credentialed PEs amount to less than 4% of engineers. Of course, many of those 1.4M engineers may not be "traditional engineers", since I'm not sure if things like biomedical engineering or environmental engineering count as "traditional". Perhaps I'm not a "traditional engineer" either - are satellites or wireless sensor networks "traditional" engineering products? --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 03:25, 2 December 2006 (UTC)

::Good point. Taken. [[User:Dpbsmith|Dpbsmith]] [[User_talk:dpbsmith|(talk)]] 03:03, 3 December 2006 (UTC)

::P. S. Of course, if our article is correct in saying "Software is often found in products and situations where very high reliability is expected, even under demanding conditions, such as monitoring and controlling nuclear power plants, or keeping a modern airliner aloft" then software is "often" found in places where public safety impacts of the product are a concern ... [[User:Dpbsmith|Dpbsmith]] [[User_talk:dpbsmith|(talk)]] 03:03, 3 December 2006 (UTC)

:::Indeed. Yet software is "often" found in a lot of places. I think I understand what the writer was trying to get across with that statement, but it strikes me as a rather poor rationale for software engineering as a whole - the high-reliability, safety-critical side of software development is something of a niche area. Many other kinds of (non-software) products which are not safety-critical are engineered, so I don't think that the safety-critical nature of a product is a necessary condition for engineering the product.
:::The other issue is that PE licensure is (at least in the US) a requirement only in performing work that a state regulates. Safety-critical software does not seem to fall into that category. I assume that things like commercial aircraft and nuclear power plants are subject to federal regulation. Since there's no federal PE license, they presumably have other methods of assigning legal responsibility for the performance of the prodcut (although I haven't worked in those areas, so I don't know for certain). --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 18:26, 3 December 2006 (UTC)

:The statement "very few" is obviously misleading. About 1/3 of all civil engineers  have licenses. But, excluding civil, electical, and mechanical, probably at most 5% of practicing engineers have licenses.

:People talk ad nauseum about "public safety", but only a tiny fraction of aerospace or nuclear or automotive engineers have licenses. And automobiles are the leading preventable cause of death in modern societies. When was the last time you heard about an automobile engineer being sued over a death or global warming? The issues are very complex, but suffice it to say that for most people corporations are the boundaries of responsibility, not licenses. The people who advocate licenses for software engineers too often talk about the mythology the civil engineering rather than the reality of all engineering. -- The Phantom Avenger for SE. <small>The preceding [[Wikipedia:Sign your posts on talk pages|unsigned]] comment was added by [[Special:Contributions/69.49.173.16|69.49.173.16]] ([[User talk:69.49.173.16|talk]]) 20:30, 14 February 2007 (UTC).</small><!-- HagermanBot Auto-Unsigned -->

== [[Criticism of software engineering]] ==

That article doesn't read like an encyclopedia entry, it reads like a promotional pamphlet. I tagged it both for failing to establish notability and lacking any sources for the criticisms. I am not planning to blank it or propose it for deletion, but it really could use a lot of improvement. [[User:CMummert|CMummert]]  <small>[[User talk:CMummert|talk]]</small> 16:52, 26 January 2007 (UTC)

:It seems as if it is a POV fork from this article.  Should they be merged? [[User:Blueboar|Blueboar]] 23:08, 27 January 2007 (UTC)

::If sources can be found for some of the criticisms and responses, then they could (and probably should) be merged into this article. The same could be said for the articles [[Comparison of software engineering and related fields]], and [[Debates within software engineering]], both of which unsourced, and somewhat redundant with material already in this article. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 02:29, 28 January 2007 (UTC)

:::If the article doesn't cite sources, and is duplicative of other articles, then shouldn't it be put up for AfD?  I popped into this article because of a comment at the Village Pump, which calls into question the idea of having "criticisms of... " articles. I tend to agree.  Either merge the material or delet it. [[User:Blueboar|Blueboar]] 03:30, 28 January 2007 (UTC)

::::That article was historical. The original content of the "software engineering" article was a long list of complaints about SE. I added the refutations, because a list of complaints does not make a good article either, and nobody would let any individual complaints be dropped. Later, when the SE article got too large, it was chopped into pieces, and thus was born the criticisms article.

::::The problem remains. Most of the criticisms of SE remain valid, though one can debate forever, how much they matter. Documenting the list is valid, at least for historical reference. But, how much of each side should be represented? Now that the SE article has been stable for a couple years, some of the sub articles (such as criticisms) can probably be dropped. -- The Phantom Avenger for SE. <small>The preceding [[Wikipedia:Sign your posts on talk pages|unsigned]] comment was added by [[Special:Contributions/69.49.173.16|69.49.173.16]] ([[User talk:69.49.173.16|talk]]) 20:20, 14 February 2007 (UTC).</small><!-- HagermanBot Auto-Unsigned -->

== Contradictory leader ==

The leader begins with a (unreferenced) flat assertion that "Software Engineering is..." A little bit further down, it lists four ''different'' interpretations of what "software engineering is". This seems a little contradictory. Any suggestions on how to resolve this contradiction? --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 03:42, 2 February 2007 (UTC)

:'''Longish reply'''
I think we should replace the first sentence with a concise definition based on the IEEE definition. This gives us a verifiable definition by an authoritative body. 
Alternatively, or in addition, we could quote a standard textbook on Software Engineering (e.g. by [[Ian Sommerville]] or Pressman). Another source might be the IEEE "Body of Knowledge". 
I would later give the full IEEE definition as an authoritative definition of what Software engineering is and leave the paragraph about the origin. 

I would add a heading before the competing definitions so that they are not part of the intro.

I would leave out the definition involving advocacy as I think it is based on a misinterpretation of the cited reference. This states  
<blockquote>
We believe that software engineering can only advance as an engineering discipline by moving away from its current dependence upon advocacy and analysis, and by employing more systematic empirically-based approaches to developing an understanding of what works, why, and under what conditions?
</blockquote>
I think "advocacy" is here used as a diplomatic way of saying "telling other people what to do, based on one's unsubstantiated opinion"  as made obvious by contrasting "advocacy" with "more systematic empirically-based approaches to developing an understanding of what works, why, and under what conditions", i.e. '''ascertaining empirically''' what engineering processes work before persuading people to use them.

I would expand or alter the other definitions to more fully reflect what is contained in the cited references, but indicate that they reflect secondary or erroneous usage.  

I would then move the sections discussing the nature and meaning of software engineering to immediately follow (or even be part of,) the definition section (but only if they can be much condensed). While we are at it, we could remove some of the unreferenced stuff. 

Scope and focus could perhaps be largely replaced by the ToC of the IEEE Guide to the Software Engineering Body of Knowledge [http://www.swebok.org/pdfformat.html].

I see someone created a page [[:Software Engineering/Rework]]. I was going to propose delting it, since it doesn't seem to be in use, but perhaps we could use it for the purpose of "refactoring"" the whole article. It seems to be getting rather repetitive and rambling. --[[User:Boson|Boson]] 20:35, 6 February 2007 (UTC)

:: The first sentence is a compromise that has been hashed out over many years. It contains ideas that the general public can understand, such as "SEs make programs or applications," and it references the source ideas that SEs use (computer science, engineering, project management, etc).

:: There are many problems with IEEE definitions. They tend to emphasize government/military applictions and processes. They tend to dismiss non-commerial approaches, sucs as open source). They tend to overlook modern, agile approaches. Also, IEEE members are only a small fraction of the SE community, perhaps 3%. For those who will argue about data (the U.S. BLS says there are 750,000 SE in the U.S. alone, but the IEEE CS has only 60,000 members, at least half of whom are hardware types.) 

:: Many people have offered over the years to say that "SE should be defined by the IEEE" or "SE should be defined by engineers". This appears to be yet another attempt by engineers to tell software people what they do. -- The Phantom Avenger for Software Engineering <small>The preceding [[Wikipedia:Sign your posts on talk pages|unsigned]] comment was added by [[Special:Contributions/69.49.173.16|69.49.173.16]] ([[User talk:69.49.173.16|talk]]) 19:07, 14 February 2007 (UTC).</small><!-- HagermanBot Auto-Unsigned -->
:::It is not about engineers telling software developers what to do, but we need to distinguish between "software engineering" as an engineering discipline and the development of software by any means, including engineering processes, craft practices, cowboy programming, etc. i.e. this is a dispute about linguistic issues, not substance. Perhaps we could just put a disambiguation note at the top of the article: ''This article describes software engineering in the IEEE sense of the application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software. For the development of software in general, see'' [[Software development]]. <small>The preceding [[Wikipedia:Sign your posts on talk pages|unsigned]] comment was added by [[User:Boson|Boson]] ([[User talk:Boson|talk]]  [[Special:Contributions/Boson|contribs]]) 18:38, 15 February 2007 (UTC).</small><!-- HagermanBot Auto-Unsigned -->



==Syntactic methods==
I have added a "{{[[Template:prod|prod]]}}" template to the article [[Syntactic methods]], suggesting that it be deleted according to the [[Wikipedia:Proposed deletion|proposed deletion]] process. All contributions are appreciated, but I don't believe it satisfies Wikipedia's criteria for inclusion, and I've explained why in the deletion notice (see also "[[Wikipedia:What Wikipedia is not|What Wikipedia is not]]" and [[Wikipedia:Deletion policy|Wikipedia's deletion policy]]).  You may contest the proposed deletion by removing the <code><nowiki>{{dated prod}}</nowiki></code> notice, but please explain why you disagree with the proposed deletion in your edit summary or on [[Talk:Syntactic methods|its talk page]]. Also, please consider improving the article to address the issues raised. Even though removing the deletion notice will prevent deletion through the [[WP:PROD|proposed deletion process]], the article may still be deleted if it matches any of the [[Wikipedia:Criteria for speedy deletion|speedy deletion criteria]] or it can be sent to [[Wikipedia:Articles for deletion|Articles for Deletion]], where it may be deleted if consensus to delete is reached. [[User:Jeepday|Jeepday]] <small>([[User talk:Jeepday|talk]])</small> 02:18, 17 May 2007 (UTC)

== Question: What is the main similarity between a Software Engineer and a Programmer? ==

Answer: Neither one graduated from an engineering school

:And thats why I added <nowiki>{{Main article:</nowiki> [[Controversies over the term Engineer]]<nowiki>}}</nowiki> into the "Debate over the term 'engineering'" section. That Article brings many of the different "Engineering Title" debates to 1 single ''well sourced'' article. Professional engineers, Security engineers, Cost engineers, software engineers, and Aircraft Maintenance Engineers are all represented, with much less trolling. <font style="background-color:#ddcef2;font-weight:bold;color:#000;">[[User:Exit2DOS2000|Exit2DOS2000]]</font><small><small><sup>[[User Talk:Exit2DOS2000|T]][[Special:Contributions/Exit2DOS2000|C]]</sup></small></small> 10:57, 5 January 2008 (UTC)

:Sorry, I can call myself a MSc in Software Engineering and I did graduated from an engineering school!  Moreover, I am an ir. MSc, meaning I've completed the toughest kind of study around.  And yes, I've seen loads of Algebra and Mathematical Analysis and Classical Physics and Quantum Physics and a bit of Relativity.  And yes, I've seen how all parts of a computer work, from Electronics, transistors, integrated circuits, telecommunication, assembler, compilers, procedural programming/relational databases, object oriented programming, software architecture.  I don't say that everyone that calls himself a software engineer is worth the name "engineer", but this doesn't mean there are no real engineers between them.  If you are one yourself, you know who are the real ones and who are the fakes.  For others it may be more difficult to tell the difference.
==World perspective on degree courses==
From what I understand/have evidence of the UK had the first software engineering Bachelor's degree courses. I have linked to a reference that shows that Sheffield was one of the pioners and have had a personal communication with the author that confrimed that Imperial was the first, but have yet to find any evidence. Also it should be noted that there were certainly masters courses in the UK prior to 1987 but again I have not found any other evidence.   <small>Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[User:Smogit|Smogit]] ([[User talk:Smogit|talk]]  [[Special:Contributions/Smogit|contribs]]) 11:15, 22 July 2008 (UTC)</small><!-- Template:Unsigned --> <!--Autosigned by SineBot-->




== Category box not appearing ==

<strike>Does anyone know why the Category box isn't showing up? The text is there, but not the usual outline and shading that usually goes along with it.</strike> [[User:Ham Pastrami|Ham Pastrami]] ([[User talk:Ham Pastrami|talk]]) 19:24, 10 March 2008 (UTC) Never mind, looks like it was a problem with the Foundation's advertising banner. [[User:Ham Pastrami|Ham Pastrami]] ([[User talk:Ham Pastrami|talk]]) 19:29, 10 March 2008 (UTC)
{{Automatic archive navigator}}

== Dijkstra and Software Engineering ==

Does anyone understand Dijkstra well enough to know exactly what he had against software engineering?

Quote:
<blockquote>
The required techniques of effective reasoning are pretty formal, but as long as programming is done by people that don't master them, the software crisis will remain with us and will be considered an incurable disease. And you know what incurable diseases do: they invite the quacks and charlatans in, who in this case take the form of Software Engineering gurus.
</blockquote>

[[Special:Contributions/98.31.14.215|98.31.14.215]] ([[User talk:98.31.14.215|talk]]) 01:50, 24 August 2008 (UTC)

:I'm not sure this discussion really belongs here, but I suppose it is relevant to the controversy about the term.  I can't claim to be a Dijkstra expert, but I suspect, asked what he thought of software engineering, Dijkstra's answer might have been similar to Gandhi's when asked what he thought of western civilization: "I think it would be a good idea!". I think Dijkstra would have argued that programming requires effective reasoning and the application of computer science, based on mathematics, and would '''not''' have expected that from the "software engineering gurus", who, he might claim, were misusing the term (see also the Dijkstra quote in footnote 20). In other words, I don't think Dijkstra had anything against "software engineering", as he would have wanted the term to be used, but he had something against "software engineering gurus" and against something inaccurately called "software engineering" by others.  --[[User:Boson|Boson]] ([[User talk:Boson|talk]]) 10:44, 24 August 2008 (UTC)

I think Dijkstra saw computer science as based entirely on mathematics. He once made a statement to the effect that the poorer mathematicians should not go into the field of *computer science*. However, software engineering tends to be a field at a higher level of abstraction than the studies of mathematics esp. algorithms and data structures, and so perhaps most of the mathematical principles would not be relevant in SE, so I don't think he was making a criticism against the emerging discipline at all. But who knows...

== The bigger picture ==
I wonder if the [http://en.wikipedia.org/w/index.php?title=Software_engineering&oldid=246141296 current article] is missing the bigger picture. In the introduction this article mentions the Software development process, but the article itself explains a lot of details about the current situation. It is all well referenced and all. But I keep the feeling this article isn't giving a proper general introduction of the field. It seems to be written for all software engineers to tell them about the current events. 

I think the current article is missing the bigger picture and is at first written for the wrong audience. I think it should at first focuss on all non software engineers. It should at first explain the wifes, childs and school kids about software engineering...!? I have compare this article with the featured [[Electrical engineering]] article, and think that that article is giving much more basic information. 

Now don't get me wrong. I think this article is giving a lot of valuable information. I would like to move most of this info to other data and recreate an article here much more basic, for a larger audience. -- [[User:Mdd|Marcel Douwe Dekker]] ([[User talk:Mdd|talk]]) 00:12, 20 October 2008 (UTC)

:As a start I have moved:
:* The "Ambiguity and controversy" section to [[Debates within software engineering]] article. 
:* The "Current trends in software engineering" and "Software engineering today" to [[History of software engineering]]
:I just noticed most of this work seems to be written by one anominous user User [http://en.wikipedia.org/wiki/Special:Contributions/204.134.9.1 204.134.9.1] around 2004. -- [[User:Mdd|Marcel Douwe Dekker]] ([[User talk:Mdd|talk]]) 15:09, 20 October 2008 (UTC)

== Get this article to featured or good status ==
As you've probably noticed, I'm made a good number of changes to this article lately (hopefully for the better :)  This article will most likely go into the 1.0 Release Version of Wikipedia and it is an important article.  I'd like to work with Wikipedians to improve it substantially.  [[User:Mdd]] pointed out that the [[Electrical Engineering]] article is featured and would be a good guide for our article.  I wholeheartedly agree. [[User:Lwoodyiii|Lwoodyiii]] ([[User talk:Lwoodyiii|talk]]) 01:51, 31 December 2008 (UTC)

:The main photo needs a caption. [[User:Oicumayberight|Oicumayberight]] ([[User talk:Oicumayberight|talk]]) 00:21, 1 January 2009 (UTC)

:All done.  Thank you for the tip. [[User:Lwoodyiii|Lwoodyiii]] ([[User talk:Lwoodyiii|talk]]) 22:44, 1 January 2009 (UTC)

===Electrical Engineering Article===
One thing I noticed in this article is that they don't re-direct users to other wikipedia articles in the main sections.  We tend to do that a lot with this article (e.g. "History" and "Profession").  I think we should merge the good info in these articles into this one.  What do you think? [[User:Lwoodyiii|Lwoodyiii]] ([[User talk:Lwoodyiii|talk]]) 01:51, 31 December 2008 (UTC)

== The use of the word "Engineer" ==

Software Engineers are engineers according to the definition:

"a person trained and skilled in the design, construction, and use of engines or machines, or in any of various branches of engineering: a mechanical engineer; a civil engineer."

http://dictionary.reference.com/browse/engineer

They are also Computer Scientists according to the definition:

"a person with advanced knowledge of one or more sciences"

http://dictionary.reference.com/browse/scientist  <small><span class="autosigned">Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[User:Dprust|Dprust]] ([[User talk:Dprust|talk]]  [[Special:Contributions/Dprust|contribs]]) 20:00, 3 February 2009 (UTC)</span></small><!-- Template:Unsigned --> <!--Autosigned by SineBot-->

== A new Software Engineering template ==
:This discussion started on [[Template talk:Software development process]] and [[Template talk:Software Engineering]]. 
I designed a new [[:Template:Software Engineering]] template here to replace the existing [[:Template:Software development process]]. This new template has more possibilities to give a more detailled view on the field. At the moment some of the parts needs some more work, as always. 
-- [[User:Mdd|Marcel Douwe Dekker]] ([[User talk:Mdd|talk]]) 20:15, 20 October 2008 (UTC)
:I disagree that it should replace that template. That template is about a multidisciplinary process that includes software engineering but is not summed up by software engineering. Software engineering describes a skill that evolves much faster than any one process. You are doing both software engineers and those who work with software engineers a disservice by trying to monopolize all the software development terminology under the umbrella of "software engineering." [[User:Oicumayberight|Oicumayberight]] ([[User talk:Oicumayberight|talk]]) 03:04, 21 October 2008 (UTC)

::You opposition makes no sense to me. The new template is based on the statement, that "the software development process is the central issue in software engineer, and software engineering is the main discipline studying the software development process". You keep denying this. Now I told you I could list a dozend Software Engineering introduction books. I will name two: 
::* P. Naur and B. Randell, (Eds.). [http://homepages.cs.ncl.ac.uk/brian.randell/NATO/nato1968.PDF ''Software Engineering: Report of a conference sponsored by the NATO Science Committee, Garmisch, Germany, 7-11 Oct. 1968, Brussels''], Scientific Affairs Division, NATO (1969) 231pp : 
:::This is this first mayor publications 40 years ago with the central issues: DESIGN, PRODUCTION and SERVICE in the main chapters 4 to 6. Fig 1 on page 11 already gives an overview of the THE SYSTEM DEVELOPMENT PROCESS PHASE AND FUNCTIONS with Some problems in the production of large-scale software systems.  

::* <s>[[Ian Sommerville]]</s> '''[[Ian Sommerville (academic)|Ian Sommerville]]''' (2007). ''Software Engineering'', 8th ed., Harlow, England: Pearson Education. [http://www.cs.st-andrews.ac.uk/~ifs/Books/SE7/SampleChapters/index.html ''Content''], [http://www.cs.st-andrews.ac.uk/~ifs/Books/SE7/Presentations/PDF/ch1.pdf ''Presentation chapter 1''] 
:::Sommervill explains here: 
:::''Software engineering is concerned with theories, methods and tools for professional software development. It is an engineering discipline that is concerned with all aspects of software production. System engineers are involved in system specification, architectural design, integration and deployment.''

::Now I can go on and on. But this is not the point. I think in Wikipedia the [[Systems engineering]] articles and the articles about the [[Software development process]] should be better integrated. Keeping two templates here is only confusing. Now there is still a lot of work here:
::# This article should better express the relation with the [[Software development process]] 
::# The previous (good) article here could maybe be recreated in Wikibooks. 
::# The two [[Software development]] and [[Software development process]] should be better integrated
::# The [[List of basic software engineering topics]] or [[Topic outline of software engineering]] can be improved.
::# There is a needs for a better understanding about the Prominent figures in the history of software engineering. 
::# There is a need for more illustrations in the software engineering articles
::# And last but not least, the [[:Template:Software Engineering|Software Engineering]] template
::The new Software Engineering template is just in first step in improving the field of Software engineering in Wikipedia. I would like to go own, and could use some help and feed back. <br>-- [[User:Mdd|Marcel Douwe Dekker]] ([[User talk:Mdd|talk]]) 12:55, 21 October 2008 (UTC) '''& [[User:Jerzy|Jerzy]][[User talk:Jerzy|t]] 19:26, 9 February 2009 (UTC))''' <sub>(bypassed Dab at former bio title)</sub>

:::You can try to oversimplify it by saying that software engineering is the main discipline. I'm sure there are product developers and project managers that would disagree with you, but that's beside the point. The point is that software development is multidisciplinary. You're trying to pull the disciplines of "software development" that have little to do with engineering under the umbrella of "software engineering" as if those functions are a less important subclass of engineering. [[User:Oicumayberight|Oicumayberight]] ([[User talk:Oicumayberight|talk]]) 00:04, 22 October 2008 (UTC)

::::Yes software development is multidisciplinary, and software engineering is interdisciplinair. Computer scientists from different fields have joint together for over 40 years now and have build the theory about software development under the flag of software engineering. These are the facts. Look for software development in Google books and you find all books which classify as software engineering. 

::::The main problem here is the current representation of software engineering and software development in Wikipedia, which could use some serious improvement. I hope to support this with this template. -- [[User:Mdd|Marcel Douwe Dekker]] ([[User talk:Mdd|talk]]) 09:53, 22 October 2008 (UTC)

:::The other template was better because it laid it out in steps and was highly visible at the top for those who may have only been interested in a particular step. I know that software engineering is not a step-by-step process, so I think it's futile to have software engineering template replace the software development process template. There should be two separate templates, one for the broader software development process and the other for the field or skill of software engineering. Your oversimplifying both subjects by merging the templates. [[User:Oicumayberight|Oicumayberight]] ([[User talk:Oicumayberight|talk]]) 22:38, 22 October 2008 (UTC)

::Now you are simplifying
::* The two templates are different in structure, and number of items, and the placement in the article    
::* I think highly visible at the top should be first of all an image reflecting the subject on hand, not a template to navigate. There should be more images, which is motivation for young ond old. And if there are images, than the old vertical template is getting in the way.
::Your oversimplifying doesn't stand here. The old template is the simplification. And there are no two subjects. There is systems engineering here, and for example [[:de:Softwaretechnik|Softwaretechnik]] in Germany. That is the main umbrella here. And more sophisicated: systems engineering being part of computer science, being related to multiple other sciences involved in software development. But there is not a separate field of "software development process", you keep saying. -- [[User:Mdd|Marcel Douwe Dekker]] ([[User talk:Mdd|talk]]) 23:40, 22 October 2008 (UTC)
::P.S. I have restored the <nowiki>{{software development process}}</nowiki> for now, untill we can find a better solution here.

:::Suggesting that there should be two separate templates is not over-simplifying. I'm not suggesting that the software development process template be a part of this article. I didn't say that the software development process is a field. I said that software engineering is a field, that's why it didn't work to merge it with a template that was about a process. Perhaps the idea of more continuity and flow between the articles is just not possible without over-simplifying some of the articles. [[User:Oicumayberight|Oicumayberight]] ([[User talk:Oicumayberight|talk]]) 00:15, 23 October 2008 (UTC)

::::I agree to keep them both untill there is a better solution. -- [[User:Mdd|Marcel Douwe Dekker]] ([[User talk:Mdd|talk]]) 00:56, 23 October 2008 (UTC)

== Professional Certification ==

I think the paragraphe highlighting the predominance of proprietary certification is relevant. The fact in itself seem to me to be undisputable but I agree that finding the right reference is not straightforward. 
What would constitute a good reference in this case ?<br/>
[[User:Ghaag|Ghaag]] ([[User talk:Ghaag|talk]]) 00:19, 3 March 2009 (UTC)

:Something other than Wikipedia would be a good start. Perhaps you can find an article in a trade magazine that makes an assertion along those lines. The paragraph itself might also be somewhat less controversial if it didn't include the word "successful" (by what metric is "success" being judged?). --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 04:05, 3 March 2009 (UTC)

::I agree that proprietary certification is relevant, but the CSDP[http://www2.computer.org/portal/web/getcertified] is probably the most closely ''aligned'' with Software Engineering.  Unfortunately, it has not become that relevant.  I would think that the Oracle, Sun Java, and Microsoft cert's are the most relevant, but it should be noted that they are aligned with technologies and not software engineering per se. [[User:Lwoodyiii|Lwoodyiii]] ([[User talk:Lwoodyiii|talk]]) 23:00, 4 March 2009 (UTC)

== Merge with Software Engineer ==

I am proposing to merge this article with [[Software engineer]]. The two articles treat the same topic and share several sections verbatim. I Do not see the point of keeping them separate.
[[User:Ghaag|Ghaag]] ([[User talk:Ghaag|talk]]) 13:02, 3 March 2009 (UTC)

:The [[software engineer]] article is the place to give detailled information about the profession. Now in the past some guys added a lot of detailled information about the profession here, instead of there. I copied most of it to that article, and that is why there are several similair sections. 

:Better just remove the double sections and write a new summery here. -- [[User:Mdd|Marcel Douwe Dekker]] ([[User talk:Mdd|talk]]) 13:18, 4 March 2009 (UTC)

::I agree with the merge.  A software engineer does software engineering.  [[Electrical Engineer]] has a re-direct to the FA [[Electrical Engineering]]. [[User:Lwoodyiii|Lwoodyiii]] ([[User talk:Lwoodyiii|talk]]) 22:53, 4 March 2009 (UTC)

:::We both agree the the FA [[Electrical Engineering]] is a good example. In that article about 20% is about the profession of the electrical engineers. If you merge the software engineer article here, about 60 to 80% of that article will be about the profession. And most of that is also US oriented facts about the current situation. 
:::I think an overview article on a subfield of science should introduce what it is all about. A merged article will agian look like a checklist for the junior software engineer. -- [[User:Mdd|Marcel Douwe Dekker]] ([[User talk:Mdd|talk]]) 23:22, 4 March 2009 (UTC)

::::I see this pattern all over wikipedia. One article should be about the [[Process_(engineering)|process]] and [[skill]]s involved. The other article should be about the [[career]] and [[Professional certification|qualification]]s for the [[profession]].  Even if it gets merged, it will probably keep getting split into separate articles. [[User:Oicumayberight|Oicumayberight]] ([[User talk:Oicumayberight|talk]]) 23:41, 4 March 2009 (UTC)

:There is a prior occurrence of a merged practice/practitioner article split again afterward. Do you have a specific example (I'm getting obsessed with refs).
:[[User:Mdd|Marcel Douwe Dekker]], your point about the quality of [[software engineer]] strikes me as good reason to merge as it would make the each article's flaws more obvious and therefore likely to be addressed.
:Could we prototype a merged article somewhere?
:[[User:Ghaag|Ghaag]] ([[User talk:Ghaag|talk]]) 01:29, 5 March 2009 (UTC)
::I don't understand your argument, and I wonder if you have understood mine. But your last question I can answer. Just start a [[User:Ghaag/Software engineering]] sub-userpage article. -- [[User:Mdd|Marcel Douwe Dekker]] ([[User talk:Mdd|talk]]) 01:43, 5 March 2009 (UTC)

:::I did understand something which I hope was what you meant but I don't think that speculations on message integrity are productive in this case. Thanks for the tip. Can other editors contribute to sub-userpage articles ? 

:::Did you notice the redirect on [[Software Engineer]] but not on [[Software engineer]]?
:::[[User:Ghaag|Ghaag]] ([[User talk:Ghaag|talk]]) 04:37, 5 March 2009 (UTC)

::My argument is not about message integrity, but about message composition, article composition in fact. Six months ago, see [http://en.wikipedia.org/w/index.php?title=Software_engineering&oldid=237523546 ''here''], the [[software engineer]] was redirected here and that article was 75% about the software engineer. And here is a huge difference with related overview article like [[Computer science]], [[Electrical engineering]], [[software engineer]], and [[systems engineering]]. 

::On userpage and sub-userpage you are on your own. Other editors are not to edits these user pages, unless to make necessary corrections. These redirects happen all the time, I will correct it. -- [[User:Mdd|Marcel Douwe Dekker]] ([[User talk:Mdd|talk]]) 14:27, 5 March 2009 (UTC)

== First software doctorate claim ==

I think it would be good to investigate this claim in particular with the creation in 1993 of the Software Engineering program at [[Oxford university]] which used to include a Phd ? [http://www.softeng.ox.ac.uk/programme/history.html]<br/>
[[User:Ghaag|Ghaag]] ([[User talk:Ghaag|talk]]) 05:13, 27 February 2009 (UTC)

Sketchy response: the Oxford University Gazette listed an [http://www.ox.ac.uk/gazette/1998-9/weekly/220499/exam.htm#518Ref amendment] to the regulations for the D.Phil in Software Engineering, in April 1999.  Internal records suggest that candidates were being admitted in April 1998, but I cannot find the original Gazette entry establishing the D.Phil programme (and, for information, no students have been admitted since 2004).  
[[User:Apmapmapm|Apmapmapm]] ([[User talk:Apmapmapm|talk]]) 13:48, 27 March 2009 (UTC)

==History section==
I've just stoped by the history section on this arcticle and have to say, from my POV, it discuss a lot of peripheral things, but history of software engineering is not one of them. When the term started to be used? Who where the pioneers in studying and applying engineering practices to software construction? What where the controversies at the time? Who participated, or how traditional engineers reacted? How, exactly, the discipline evolved, and what trends where developed? What is the relationship between the development of software engineering and the so called software crisis at the time? What is the current state of affairs???  <span style="font-size: smaller;" class="autosigned">Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[Special:Contributions/189.70.43.160|189.70.43.160]] ([[User talk:189.70.43.160|talk]]) 03:26, 2 May 2009 (UTC)</span><!-- Template:UnsignedIP --> <!--Autosigned by SineBot-->

== [[Software development methodology]]  ==

Hi, there are two proposals concerning the [[Software development methodology]] article:
* To change the term methodology into method, see ''[[Talk:Software development methodology#Method vs. Methodology|here]]''
* To merge the article ito the [[Software development process]] article. 
Could anybody interested comment on both items. Thank you. -- [[User:Mdd|Marcel Douwe Dekker]] ([[User talk:Mdd|talk]]) 11:10, 18 May 2009 (UTC)

== Caching ==

[[User:Pabitra 777|Pabitra 777]] ([[User talk:Pabitra 777|talk]]) 17:52, 9 August 2009 (UTC)Caching is the technique of storing an in-memory copy of some information thats expensive to create.
For example, you could cache the results of a complex query so that subsequent requests dont need to access the database at all. Instead, they can grab the appropriate object directly from server memory.

'''ASP.NET really has two types of caching'''
'''Output caching:'''
It store a copy of the final rendered HTML page that is sent to the client.
So when next client submit a  request for this page ,It doesnt actually run the page. Instead, the final HTML output is sent automatically.
'''Data caching :'''
Store important pieces of information that are time-consuming to reconstruct (such as a DataSet retrieved from a database) in the cache.

Other pages can check for the existence of this information and use it.
Data caching is conceptually the same as using application state,
But its much more server friendly because items will be removed from the cache automatically when it grows too large and performance could be affected

''Output Caching''
When the same page is requested again, the control objects are not created, the page life cycle doesnt start, and none of  the code executes. Instead, the cached HTML is served.
The rendered contents of the page are cached for every user that requests the page.

== Certification in Israel ==

I can't find any reference to Software Engineering on the [http://www.tamas.gov.il/NR/exeres/DACD5881-70D5-463A-BDF2-AA363197FB2F.htm Architects and Engineers Registrar] website linked to from the article. The assertion that "[in Israel a] software engineer has the right to be written in the engineering registry" should in my opinion either be removed or have a valid citation added.

[[Special:Contributions/87.69.208.92|87.69.208.92]] ([[User talk:87.69.208.92|talk]]) 21:14, 28 April 2010 (UTC)

== Merge discussion ==
I'm proposing that anything that is useful in [[software product lines]] should come in here. There doesn't seem to any point in having a separate article on that topic. Or perhaps some could go into [[software]], or perhaps nothing's salvageable at all? [[User:Itsmejudith|Itsmejudith]] ([[User talk:Itsmejudith|talk]]) 15:41, 24 February 2009 (UTC)

:Hi, I considered your proposal and have three points
:* The concept [[Software product lines]] seems notable enough to have an article of it's own. It seems that article could use some good work.
:* The two articles you consider [[Software engineering]] and [[computer software]] (there is no software article) are kind of "main articles", which should only explain the most important concepts in the field. It should remain only an introduction to the over 250 articles in this field.
:* You could consider merging this articles in the [[software system]] or [[software development]] article, because they seem just as related.
:I personly would prefer the first option. -- [[User:Mdd|Marcel Douwe Dekker]] ([[User talk:Mdd|talk]]) 20:19, 24 February 2009 (UTC)
::I agree that the [[Software product lines]] page should be marked for improvement rather than merge. Software product line development focuses a great deal on product planning and organizational structures, software engineering is one of the disciplines involved in the realization of a software product line. 
::Can we say that if there's no further objection, the article can be tagged as a stub and the merge tag can be removed at the end of May? &ndash; [[User:JWBito|JWBito]] ([[User talk:JWBito|talk]]) 05:01, 4 May 2010 (UTC) (May the 4th be with you!)
:::Support closure of merge discussion (result = no merge), and removal of merge tag.--[[User:Boson|Boson]] ([[User talk:Boson|talk]]) 06:06, 4 May 2010 (UTC)

It appears that the article title and the article content don't match. When I think of software product lines, I think of a [[Software suite]], [[Class (computer science)|software classification]] or an [[application software]] category. [[User:Oicumayberight|Oicumayberight]] ([[User talk:Oicumayberight|talk]]) 18:46, 3 March 2009 (UTC)
:If you read the literature on software product lines (for instance the [http://www.sei.cmu.edu/productlines/ SEI overview]), you'll see that the term is not used to mean a category of application software. &ndash; [[User:JWBito|JWBito]] ([[User talk:JWBito|talk]]) 05:01, 4 May 2010 (UTC)

== New PE exam discipline ==

A new exam in this new discipline is pending (US) [http://www.ncees.org/About_NCEES/News/News_Pages/NCEES_approves_new_PE_exam_in_software_engineering.php Software Engin exam]--[[User:Billymac00|Billymac00]] ([[User talk:Billymac00|talk]]) 04:13, 14 July 2010 (UTC)

== Employment ==

Is it encyclopedic to give bill rates? If so, from an international point of view, we should then give rates in other major markets. Besides which, do we give rates for lawyers, plumbers etc.? --[[User:Boson|Boson]] ([[User talk:Boson|talk]]) 05:00, 31 August 2010 (UTC)

:Probably not. It's likely to fluctuate and rapidly become out of date anyway. --[[User:Allan McInnes|Allan McInnes]] <small>([[User talk:Allan McInnes|talk]])</small> 00:18, 1 September 2010 (UTC)

I would advocate the inclusion of rates as the article spends a great deal of time emphasizing the employment of the Software Engineer, the loss of jobs to off shore components, and the lack of freshers entering this work force. The example rate specified is an IBM rate and has not changed in seven years. Therefore, it cannot be considered in flux. Since Software Engineering profession is a bonafide Global profession, with a Global Service Delivery model, it may be useful to list other markets from around the world to illustrate the diverse compensatory levels. In the 1990s, Indian resources made one-tenth of Western compensation levels, but in the last few years, they now exceed Western compensation levels. --[[User:lancelotlinc|John Green]] <small>([[User talk:lancelotlinc|talk]])</small> 20:42, 9 September 2010 (UTC)

:It doesn't seem to appear typically based on a really quick check. Such info is not normally considered encyclopedic. [[User:AliveFreeHappy|AliveFreeHappy]] ([[User talk:AliveFreeHappy|talk]]) 21:19, 9 September 2010 (UTC)

::Ok, perhaps we can represent the concept without using actual monetary amounts. The theme of the section is about employment of Software Engineers. The theme of the article is about the changes over the last few decades. The concepts that should be represented are (1) freshers can make a decent living as a noob Software Engineer; (2) Veteran Software Engineers, through the magic of remote internet working, can make five to six times what freshers would make in the same calendar year; (3) top-tier consulting firms bill extradinarily high hourly rates, challenging those billed by attorneys or other white-collar professionals (blue-collar are construction workers, assembly line workers and the like; white-collar workers are lawyers, desk-type professional workers, engineers, etc); (4) if employed by a top-tier consulting firm like IBM, the consultant's cut of the hourly rate in the form of direct compensation is only a minority share of the rate, the company absconds with the rest. Can you suggest some creative language that would drive these points out as an alternative to what is currently presented? --[[User:lancelotlinc|John Green]] <small>([[User talk:lancelotlinc|talk]])</small> 12:02, 10 September 2010 (UTC)
:::What sources are you using for this so I can try to read up on it? [[User:AliveFreeHappy|AliveFreeHappy]] ([[User talk:AliveFreeHappy|talk]]) 16:40, 10 September 2010 (UTC)
::::There are sources listed in the article. You might find more information if you want to read extensively at http://www.telework.gov/ . There are lots of individual job reqs you can use to piece together experience and compensation level. dice.com, monster.com, and futurestep.com provide good views of job reqs. Futurestep (by Korn Ferry) is probably the one with the most global emphasis. Over the years, there have been lots and lots and loads of articles about teleworking, IT internships, and high-technology company practices, so you shouldn't have much difficulty googling some articles that talk about that. The IBM employee message board listed in the article is a great source for IBM bill rate info and IBM consultant direct compensation info. If you look at www.indianfresher.com you get a load of what the freshers in India are facing now. In high-tech industrial cities there, lots of inflation over the last decade due to the dramatic rise in fresher compensation. www.thehindubusinessline.com and www.onlinebangalore.com are also great sources. Good luck. Post back with specific questions and I can help you find info. --[[User:lancelotlinc|John Green]] <small>([[User talk:lancelotlinc|talk]])</small> 17:08, 10 September 2010 (UTC)
:::::Ok, that helps. But what I'm trying to avoid is [[WP:OR|original research]]. Namely, if I go and make a bunch of comparisons on my own based on reading pages, and draw some conclusions from it, it's not allowed on wikipedia. So what I'm interested in is sources that say what you say, IE sources that talk about not the pay of a particular job, but actually discuss the comparisons you make. [[User:AliveFreeHappy|AliveFreeHappy]] ([[User talk:AliveFreeHappy|talk]]) 17:11, 10 September 2010 (UTC)
:::::: Here are a couple of related articles. I'll continue researching for articles that highlight this info. http://www.cio.com/article/610635/Outsourcing_Brazil_Blossoms_as_IT_Services_Hub http://www.cio.com/article/512576/The_State_of_IT_Jobs_2010 http://video.cio.com/services/link/bcpid1370868054/bclid1373280988/bctid605949879001?src=rss http://www.cio.com/cio100/2010/1 --[[User:lancelotlinc|John Green]] <small>([[User talk:lancelotlinc|talk]])</small> 18:22, 10 September 2010 (UTC)
:::::::Cool, I'll try and check them out and see what we can do. [[User:AliveFreeHappy|AliveFreeHappy]] ([[User talk:AliveFreeHappy|talk]]) 22:14, 10 September 2010 (UTC)

==This article should be improved a lot==

The 1988 Airbus airshow crash was *not* attributed to software problems, according to the official aircrash investigation report. It is speculation only, and the statement should be removed from image caption.  <span style="font-size: smaller;" class="autosigned">Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[Special:Contributions/27.32.136.240|27.32.136.240]] ([[User talk:27.32.136.240|talk]]) 05:55, 9 October 2010 (UTC)</span><!-- Template:UnsignedIP --> <!--Autosigned by SineBot-->

==Profession==

I suggest a change to the intro.  Depending on the jurisdiction, software engineering is either a '''profession''' or a '''vocation'''.  One of the staples of a profession is licensure to practice (e.g., lawyers, doctors, dentists, etc).  The status of software engineering licensure, and by extension professional status, varies jurisdictionally.  I respectfully suggest we modify the intro to refer to SE as a profession or vocation. [[User:Sawagner201|Sawagner201]] ([[User talk:Sawagner201|talk]]) 04:43, 1 May 2010 (UTC)

:To me that is a rather restricted definition of ''profession'' , i.e. what in Europe would be called a ''liberal profession''. In British English at least, I would say ''profession'' can be used in that sense, but in this context I would understand it to mean [[:wiktionary:profession|profession]] as defined in Wiktionary. --[[User:Boson|Boson]] ([[User talk:Boson|talk]]) 09:17, 1 May 2010 (UTC)

The term Engineer across Canada is a protected professional term similar to Doctor, Dentist etc.  By extension software engineer is also a protected term.  Association of Professional Engineers and Geo-scientists of Saskatchewan (APEGS) controls who can use the term engineer.  It requires the person to have completed an accredited degree in engineering (not computer science).  They must pass the requirements to become a professional engineer (P. eng).  Only then are they able to call themselves an engineer.  This document states ''...however, there is no legal requirement to have these qualifications.''  This couldn't be further from the truth.  Engineering of any type is protected under ''The Engineering and Geoscience Professions Act''.  In this document it outlines the following,
''26(1) No person other than a professional engineer shall use the title Professional
Engineer, Engineer, Consulting Engineer or the abbreviation P.Eng., either
alone or in combination with any other word, title or designation, abbreviated or
otherwise, to imply that he or she is a professional engineer.''  This clearly shows that Software Engineer would be protected under this provincial legislation.  Each province has similar legislation that protects the term.  <span style="font-size: smaller;" class="autosigned"> Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[Special:Contributions/142.3.86.80|142.3.86.80]] ([[User talk:142.3.86.80|talk]]) 19:51, 1 June 2011 (UTC)</span><!-- Template:UnsignedIP --> <!--Autosigned by SineBot-->

Watz it al abt  <span style="font-size: smaller;" class="autosigned">Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[Special:Contributions/41.220.68.18|41.220.68.18]] ([[User talk:41.220.68.18|talk]]) 10:22, 9 July 2010 (UTC)</span><!-- Template:UnsignedIP --> <!--Autosigned by SineBot-->

== Cleaning up the Sub-disciplines Section ==

The Sub-disciplines Section includes disciplines other than the 10 disciplines outlined in the SWEBOK reference.  Some disciplines have different names from those in the SWEBOK reference.  I will clean up this section to conform with the SWEBOK reference.  <small><span class="autosigned"> Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[User:Knowledge Examiner|Knowledge Examiner]] ([[User talk:Knowledge Examiner|talk]]  [[Special:Contributions/Knowledge Examiner|contribs]]) 16:27, 13 October 2011 (UTC)</span></small><!-- Template:Unsigned --> <!--Autosigned by SineBot-->

== Defintion of Software Engineering should be that from SWEBOK ==

The definition of software engineering should that of the IEEE SWEBOK reference because it is a consensus secondary source while any other definitions should be secondary definition.  I will reorganize the definitions.  <small><span class="autosigned"> Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[User:Knowledge Examiner|Knowledge Examiner]] ([[User talk:Knowledge Examiner|talk]]  [[Special:Contributions/Knowledge Examiner|contribs]]) 13:47, 14 October 2011 (UTC)</span></small><!-- Template:Unsigned --> <!--Autosigned by SineBot-->

== Critics ==
The critics paragraph is poorly written. It doesn't make much sense. I propose that it should be removed unless anyone can understand what point is being made. --[[User:KevinBrydon|KevinBrydon]] ([[User talk:KevinBrydon|talk]]) 18:15, 31 October 2011 (UTC)
:'''Support'''.It is also unsourced - or the only source does not support the statements.--[[User:Boson|Boson]] ([[User talk:Boson|talk]]) 19:15, 31 October 2011 (UTC)

== Wrong content for topic ==

The content describes the "software engineer" and not what a "software engineer" does: "software engineering" - <b>it should describe the process involved</b>, not the person.  <span style="font-size: smaller;" class="autosigned"> Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[Special:Contributions/41.174.67.233|41.174.67.233]] ([[User talk:41.174.67.233|talk]]) 09:36, 6 March 2012 (UTC)</span><!-- Template:Unsigned IP --> <!--Autosigned by SineBot-->

== Proposed merge with [[Software engineer]] ==

Essentials the same article [[User:Ecallow|Ecallow]] ([[User talk:Ecallow|talk]]) 11:50, 30 January 2014 (UTC)

: May be worth looking at the inconclusive discussion nearly 5 years ago, at [[#Merge with Software Engineer]]. --[[User:David Biddulph|David Biddulph]] ([[User talk:David Biddulph|talk]]) 11:59, 30 January 2014 (UTC)

: Do not merge:  The two articles do not seem right to merge, and the content if you scroll down does differ.  I think there should be separation between worker and profession here similar to divisions shown between profession/job at [[accounting]]/[[accountant]], [[law]]/[[lawyer]], [[doctor]]/[[medicine]], [[actor]]/[[acting]] and so on.  I think some of the hatnote from engineering (the field) has been inappropriately duped to the engineer (the profession) article and that should be redone but that the two should not be merged.  If you go beyond the first screens the engineer article describes the job, education, professional certification, and question of using the term "engineer"; as distinct from engineering the history, principles, development methods, and related disciplines.  [[User:Markbassett|Markbassett]] ([[User talk:Markbassett|talk]]) 15:07, 11 February 2014 (UTC)

== Do not Change the facts in to opinions ==
* UK Engineering Council grants the title of chartered Engineer to software Engineers. A Fact not opinion
* MSc and BSc in Software Engineering from The University of Oxford & The University of Nottingham. A Fact not opinion
* Job classification of U.S.A., Australia, Japan, UK and Canada about Software Engineer. A Fact not opinion

[[User:Ahmed2galal1981|Ahmed2galal1981]] ([[User talk:Ahmed2galal1981|talk]]) 00:42, 27 June 2014 (UTC)

I'm having a hard deciphering what you are saying. Care to elaborate?--[[User:Lwoodyiii|Lwoodyiii]] ([[User talk:Lwoodyiii|talk]]) 15:15, 27 June 2014 (UTC)

== Not Engineers ==
I see that there is a discussion of this subject in the article.  I just want to weigh in that programmers are not engineers because they do not work with physics.  All engineering disciplines work with physics, such as kinematics, thermodynamics, or electromagnetics.  The naming of this article, as opposed to it simply being a redirect to programmer, is propagating this misuse of the term engineer.  <small>Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[Special:Contributions/69.143.89.174|69.143.89.174]] ([[User talk:69.143.89.174|talk]]) 15:22, 12 June 2008 (UTC)</small><!-- Template:UnsignedIP --> <!--Autosigned by SineBot-->

With this definition, is it even possible to have a Software "Engineering" discipline or title. It is a stretch to say that Software Engineers use physics (or an understanding of physics) in their daily activities to develop software. Granted, the more a software developer gets into electronics, you could argue that they are an engineer, but...
Maybe they ought to call it "Firmware Engineering".  :)
[[User:Srfleckenstein|Srfleckenstein]] ([[User talk:Srfleckenstein|talk]]) 13:06, 13 June 2008 (UTC)

:What's the source for the assertion that "All engineering disciplines work with physics?" One [http://www.bartleby.com/61/54/E0145400.html dictionary definition of engineering] is:
::1a. The application of scientific and mathematical principles to practical ends such as the design, manufacture, and operation of efficient and economical structures, machines, processes, and systems.
:I don't see any restriction in there to physics. Surely [[chemical engineering]] is a discipline, but it is based on applications of chemistry, not physics. MIT, whose opinion ought to count for something, has a department of "biological engineering." A discipline of "agricultural engineering" has existed since the early 1900s. 
:I don't much like the term "software engineering". I think it carries a lot of ideological baggage with it. To my way of thinking, software development is still very much an art and will be for a very long time. But that's beside the point. The first thing is that it is a well-defined term in widespread use. You might as well complain that there is no such thing as an automobile, because they don't really move by themselves... or that the phrase "steep" learning curve should mean something that is learned very quickly... or that "taxpayer dollars" should be "taxpayer's dollars." It's beside the point. The language is what it is.
:And the reason why software engineering is a misnomer is not that software engineering does not involve physics. It is that it is very hard to find any examples of the use of science or mathematics in a software engineering textbook. [[User:Dpbsmith|Dpbsmith]] [[User_talk:dpbsmith|(talk)]] 01:37, 15 June 2008 (UTC)
:: [[Financial engineering]] is another example of an engineering discipline which has nothing to do with physics. Wikipedia has its definition as:
::: Financial engineering is a multidisciplinary field relating to the creation of new financial instruments and strategies, typically exotic options and specialized interest rate derivatives. The field applies engineering methodologies to problems in finance, and employs financial theory and applied mathematics, as well as computation and the practice of programming; see computational finance
::: Ug.  Most software work is like mechanic work.  Parts are put together until they work.  Some is more difficult, but its execution is closer to mathematics.  Art is a better term for this work.[[User:Mlprater|Mlprater]] ([[User talk:Mlprater|talk]]) 23:14, 26 August 2012 (UTC)
:: The term "software engineering" is widely in use and I believe qualifies as an engineering discipline. The key is that software engineering ''does'' apply "engineering methodologies". As a simple and very concrete example, software engineers apply computer science principles to predict the [[Asymptotically_optimal_algorithm|asymptotic performance]] of algorithms, and to design an algorithm which has sufficient performance for its application. [[User:Xiphoris|Xiphoris]] ([[User talk:Xiphoris|talk]]) 01:30, 11 July 2011 (UTC)
:::As a very concrete example, when is the last time you had a warranty concern from a tolerance stack-up because your materials varied over time due to unprecedented meteorological events?  Would a "software engineer" even know what I am talking about?[[User:Mlprater|Mlprater]] ([[User talk:Mlprater|talk]]) 23:18, 26 August 2012 (UTC)
[[Chemical Engineering]] is a discipline of engineering that is based on application of physics, mathematics, and chemistry.  Formal Chemical Engineering curriculum involves only one or two more chemistry courses over what students in other engineering disciplines have to take.  <small>Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[Special:Contributions/198.82.21.161|198.82.21.161]] ([[User talk:198.82.21.161|talk]]) 16:46, 23 July 2008 (UTC)</small><!-- Template:UnsignedIP --> <!--Autosigned by SineBot-->

:This is an old debate.  [[Steve McConnell]] has responded to these types of attacks before:
:*[http://blogs.construx.com/blogs/stevemcc/archive/2007/06/23/quot-engineering-quot-in-software.aspx Software Engineering Ignorance]
:*[http://blogs.construx.com/blogs/stevemcc/archive/2007/06/28/software-engineering-ignorance-part-ii.aspx Rumors of Software Engineering's Death are Greatly Exaggerated (aka Software Engineering Ignorance, Part II)]
:There is no need for this debate.  We are all (''programmers, software developers, architects, software engineers, etc.'') just trying to make the process of creating software better and easier (ie make the world a better place).  Let us do that and not create destructive debates between us. [[User:Lwoodyiii|Lwoodyiii]] ([[User talk:Lwoodyiii|talk]]) 01:58, 31 December 2008 (UTC)
::There is a serious need for this debate.  Engineers add value to tangible objects.  Those who write software do not.  Adding value to tangible objects requires that you employ many people.  Writing software does not.  There is a mountain of difference from the perspective of measuring the behavior of societies.  But, alas, I think that most of the authors of this page are from the US, and it is going to be a long time before folks in the US wake up to this.[[User:Mlprater|Mlprater]] ([[User talk:Mlprater|talk]]) 23:23, 26 August 2012 (UTC)
I think this article must also include the list of the popular books..  <small><span class="autosigned">Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[User:Pranuthi|Pranuthi]] ([[User talk:Pranuthi|talk]]  [[Special:Contributions/Pranuthi|contribs]]) 05:01, 24 April 2009 (UTC)</span></small><!-- Template:Unsigned --> <!--Autosigned by SineBot-->

:Engineering does not have to have anything to do with physics, even if you you are using the most narrow meaning of the word. The term "engineering" is derived from ingeni, meaning to design. That design doesn't require the application of physics. <span style="font-size: smaller;" class="autosigned">Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[Special:Contributions/27.32.136.240|27.32.136.240]] ([[User talk:27.32.136.240|talk]]) 17:42, 5 October 2010 (UTC)</span><!-- Template:UnsignedIP --> <!--Autosigned by SineBot-->
::That's wrong.  Designing does not have physical boundary conditions.  I can draw a pencil-thin building that's 200 stories high.  That's designing.  Applied engineering is bound by physics.[[User:Mlprater|Mlprater]] ([[User talk:Mlprater|talk]]) 23:26, 26 August 2012 (UTC)
The fact is that much work is done to insulate programmers from having to consider hardware, communications, and the constraints they impose. This should not obscure the fact that there are significant trade-offs to be considered, and alternative solutions to be conceived and evaluated at the interface between hardware and software. Why is the hardware side of the line considered engineering and the software side of the line not? At what point in moving away from the hardware are we no longer engaged in engineering? [[Special:Contributions/219.89.193.46|219.89.193.46]] ([[User talk:219.89.193.46|talk]]) 21:23, 17 July 2011 (UTC)
:Is the definition of "engineering" written in stone?! May I ask you to do a little research on the etymology of "Engineering" and "Engineer" words? Let me enlighten you my "religious" friend! Engineer (n.) mid-14c., enginour, "constructor of military engines," from Old French engigneor "engineer, architect, maker of war-engines; schemer" (12c.). Need I say more?! Dijsktra is known for many things, rightfully respected by many, but he is not a saint or prophet, same thing goes for many many famous people throughout the history. Software Engineering is engineering according to the contemporary meaning/definition of the word. Keep your "religion" out of it! [[Special:Contributions/134.134.137.75|134.134.137.75]] ([[User talk:134.134.137.75|talk]]) 21:52, 24 September 2014 (UTC)

== Software Management ==

How/Where does "[[Software management]]" (redirects here) fit in here? In other words: what is ''Software Management''. Does it encompass Software License Management? If yes, I don't think people in a purchasing departement necessary always consider themselves "engineers", although they very well may be going to do license management, asset management and the like. --[[User:Alien4|Alien4]] ([[User talk:Alien4|talk]]) 15:29, 9 October 2013 (UTC)
:Redirected to [[Software project management]] which the original editor of the article was trying to write about before it was turned into a redirect. [[User:StarryGrandma|StarryGrandma]] ([[User talk:StarryGrandma|talk]]) 17:55, 17 May 2015 (UTC)

== External links modified ==

Hello fellow Wikipedians,

I have just added archive links to {{plural:1|one external link|1 external links}} on [[Software engineering]]. Please take a moment to review [https://en.wikipedia.org/w/index.php?diff=prev&oldid=678119913 my edit]. If necessary, add {{tlx|cbignore}} after the link to keep me from modifying it. Alternatively, you can add {{tlx|nobots|deny{{=}}InternetArchiveBot}} to keep me off the page altogether. I made the following changes:
*Added archive https://web.archive.org/20080517201804/http://www.cs.wm.edu/~coppit/csci690-spring2004/papers/selep_main.pdf to http://www.cs.wm.edu/~coppit/csci690-spring2004/papers/selep_main.pdf

When you have finished reviewing my changes, please set the ''checked'' parameter below to '''true''' to let others know.

{{sourcecheck|checked=false}}

Cheers. [[User:Cyberbot II|<sup style="color:green;font-family:Courier">cyberbot II]]<small><sub style="margin-left:-14.9ex;color:green;font-family:Comic Sans MS">[[User talk:Cyberbot II|<span style="color:green">Talk to my owner]]:Online</sub></small> 14:01, 27 August 2015 (UTC)
