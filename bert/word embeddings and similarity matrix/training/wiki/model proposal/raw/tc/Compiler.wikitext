{{Talk header|noarchive=yes}}
{{Vital article|level=4|topic=Technology|class=C}}
{{WikiProjectBannerShell|1=
{{WikiProject Software|class=C|importance=top|computing-importance=top}}
{{WikiProject Computer science|class=C|importance=top}}
}}
{{User:MiszaBot/config
|archiveheader = {{talkarchivenav}}
|maxarchivesize = 31K
|counter = 4
|algo = old(60d)
|archive = Talk:Compiler/Archive %(counter)d
}}{{auto archiving notice|bot=Lowercase sigmabot III|age=60}}
{{archives|search=yes}}

== duplication ==

the "types of compilers" section is a duplication of text at the very top of the page.

== External links modified ==

Hello fellow Wikipedians,

I have just modified one external link on [[Compiler]]. Please take a moment to review [[special:diff/816600245|my edit]]. If you have any questions, or need the bot to ignore the links, or the page altogether, please visit [[User:Cyberpower678/FaQs#InternetArchiveBot|this simple FaQ]] for additional information. I made the following changes:
*Added archive https://web.archive.org/web/20161010221724/https://www.altera.com/products/design-software/fpga-design/quartus-prime/features/spectra-q.html to https://www.altera.com/products/design-software/fpga-design/quartus-prime/features/spectra-q.html

When you have finished reviewing my changes, you may follow the instructions on the template below to fix any issues with the URLs.

{{sourcecheck|checked=false|needhelp=}}

Cheers.—[[User:InternetArchiveBot|'''<span style="color:darkgrey;font-family:monospace">InternetArchiveBot</span>''']] <span style="color:green;font-family:Rockwell">([[User talk:InternetArchiveBot|Report bug]])</span> 11:39, 22 December 2017 (UTC)

== Correct focus in compliance of the page's title expectations. ==

The page is called Compiler but the whole focus of it is about the programming languages and not on the compilers, in fact you learn barely anything (mostly basic stuff) about the compilers themselves, most of them are even hidden inside the programming language sentences, implied, but completely silent about the compilers. I wonder if anyone would agree this should be addressed and fixed, I lack the knowledge to do so, which is why I came to the page on the first place.

Thank you very much, i hope this isn't uncalled for.  <!-- Template:Unsigned IP --><small class="autosigned">—&nbsp;Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[Special:Contributions/190.39.192.31|190.39.192.31]] ([[User talk:190.39.192.31#top|talk]]) 14:17, 2 May 2018 (UTC)</small> <!--Autosigned by SineBot-->

:You can't really separate the idea of a compiler from the idea of a language needing compiling.  Also, many details will be too esoteric for an article.  Still, it might be that some things could be done better. [[User:Gah4|Gah4]] ([[User talk:Gah4|talk]]) 19:35, 9 October 2018 (UTC)

== ''highlighting them in the source code'' ==

There is a dubious/discuss for ''highlighting them in the source code''.  At first I also thought it was dubious, the way it sounds, but compilers from the 1960's and 1970's would normally (optionally) print out a source listing, with error messages at the appropriate point. Then usually with an indication of where in the line the error was, as well as it was known, sometimes with an arrow pointing at the position. I would consider that highlighting.  Some GUI compilers might actually highlight with color or font, or otherwise make obvious in the source.  Some now just indicate the line number, and usually where in the line, which is a less obvious definition of highlight.  [[User:Gah4|Gah4]] ([[User talk:Gah4|talk]]) 18:09, 27 May 2018 (UTC)

I can see both sides of this.  I'm sure it's true that some compilers out there do some kind of highlighting of the source code.  However, I would expect an encyclopedia article describing the different stages of the compiler to describe what they fundamentally and generally do, rather than what all the possibilities are.  The next sentence, which notes that the front-end performs lexical, syntactic, and semantic analysis is much more true to the spirit of what this component does, and that's the thing to focus on.  Unless there's further discussion of this in the near future I'll edit this out.
[[User:Rm9820|Rm9820]] ([[User talk:Rm9820|talk]]) 14:28, 3 December 2018 (UTC)

== interpreted language ==

There are languages that allow dynamic redefinition, such that compilation is not possible.  TeX, for example, allows dynamic changes to character codes, which affects tokenizing.  In Mathematica, it is possible to write self modifying source code.  That is, the back end can modify the input source when using the GUI. [[User:Gah4|Gah4]] ([[User talk:Gah4|talk]]) 18:18, 27 May 2018 (UTC)

== Section with verifiability issues moved from article ==

The following section was moved from the article because I couldn't find sufficient information to verify it fully.

<blockquote>
{{fakeheading|Compilers in education}}
Compiler construction and [[compiler optimization]] are taught at universities and schools as part of a [[computer science]] curriculum.<ref>{{cite journal | author1 = Chakraborty, P. | author2 = Saxena, P. C. | author3 = Katti, C. P. | author4 = Pahwa, G. | author5 = Taneja, S. | date = 2011 | title = A New Practicum in Compiler Construction | journal = Computer Applications in Engineering Education | volume = 22 | issue = 3; 25 July | url = http://onlinelibrary.wiley.com/doi/10.1002/cae.20566/pdf | accessdate = 28 February 2017 | subscription = yes | deadurl = no | archiveurl = https://web.archive.org/web/20161116230553/http://onlinelibrary.wiley.com/doi/10.1002/cae.20566/pdf | archivedate = 16 November 2016 | df = dmy-all }}{{primary source inline|date=March 2017}}</ref>{{primary source inline|date=March 2017}} Such courses are usually supplemented with the implementation of a compiler for an [[educational programming language]]. A well-documented example is [[Niklaus Wirth]]'s [[PL/0]] compiler, which Wirth used to teach compiler construction in the 1970s. In spite of its simplicity, the PL/0 compiler introduced several influential concepts to the field, including uses of:
# akin to the 1971 paper by Wirth, program development by stepwise refinement;
# a [[recursive descent parser]];
# an [[extended Backus–Naur form]] (EBNF) to specify the [[syntax (programming languages)|syntax]] of a language;
# a [[code generation (compiler)|code generator]] producing portable [[Bytecode|P-code]]; and
# [[tombstone diagram]]s in the formal description of the [[bootstrapping (compilers)|bootstrapping]] problem.
</blockquote>
{{reflist-talk}}
Feel free to reinstate it if sources are found. [[User:Enterprisey|Enterprisey]]&nbsp;([[User talk:Enterprisey|talk!]]) 21:42, 10 September 2018 (UTC)

:If you want to find out if it is taught in universities, a look through the catalog of two of them (since it is plural) should be enough.  Those catalogs could even be references.  Also, the existence of textbooks for such courses is a strong hint that courses exist, and could also be references. [[User:Gah4|Gah4]] ([[User talk:Gah4|talk]]) 19:39, 9 October 2018 (UTC)
{{talkarchivenav}}

==where is runtime system/library ?==
I think it is indispensable for some compiler dealing with Fortran 90 and OpenMP.
==Moved from original ''Compilers'' page==

Compilers - Tools for creating machine-readable programs

A compiler is a software programs which takes as its input a set of modules written in a ProgrammingLanguage and creates a machine readable binary executable image file.

Computer hardware can only understand very specific binary machine language instructions.  Each instruction must be written in an extremely precise format and must conform to extremely limited abilities of the computer's CPU (Central Processing Unit). Such binary machine language is too cumbersome for humans to read, write, and understand directly.

Compilers have the ability to understand the more abstract, symbolic, human-friendly programming languages and to generate a low level binary machine language program which executes *exactly* what the programming language specifies.

==Moved from original ''Talk'' page==
test
Right, I forgot about that.  Most of my experience programming was in the mid-80s, tinkering around with BASIC.  Not exactly a powerhouse language.  :-D

Compilers do not always take source code and output executable machine code. The program may have to be processed by a linkage editor and/or loader program first.----

... Steve Gibson (http://grc.com/) releases his programs in machine language.  Not sure how he does it... If he actually writes in it or what.  I would imagine not but haven't asked.  I suppose it's possible, though that would probably make him a certifiable genius.  :-D

Yes he writes in assembler. See [http://grc.com/smgassembly.htm How to write Windows programs in assembler]. There is even an link to a free assembler for 386 Intel processors and beyond (486, Pentium etc.).

It would be nice to have an [[:assembler|assembler]] entry with some example programs.

No. Steve Gibson packs his executables with a custom/obsolete version of [[UPX]] and claims them to be Assembly. Please verify this for yourself. [[User:Goat-see|Goat-see]] 05:00, 8 May 2004 (UTC)

==Moved from ''Compile (computing)''==

In telecommunication, the term compile has the following meanings:

1. To translate a computer program expressed in a high-level language into a program expressed in a lower level language, such as an intermediate language, assembly language, or a machine language.

    * See: Compiler 

2. To prepare a machine language program from a computer program written in another programming language by making use of the overall logic structure of the program or by generating more than one computer instruction for each symbolic statement as well as performing the function of an assembler.

''Source: from Federal Standard 1037C''

==Semantic analysis==

Shouldn't there be anything said abort semantic analysis, thats an important part of the frontend to. Type-checking and such.

==Source code/language==

I changed "source code" to "source language" because a compiler can be pretty anything that translates a language to another one. This includes a lot of translations which are not source code, such as binary-to-binary translations and just-in-time compilation processes. "Source code" in its normal meaning refers to a list of instructions in a language understandable to humans. Source language can be anything that can be griped by formal language definitions (and that is pretty much anything). 

==Compiled vs interpreted==

The article makes a distinction between compiled and interpreted languages.  While most languages are either primarily interpreted, or primarily compiled, any language that can be compiled can be interpreted, and (modulo eval statements and the like) any language that can be interpreted can be compiled.  In practice, there are compilers for normally-interpreted languages such as Perl (which is compiled to bytecode anyway), LISP, and Prolog, and interpreters for such commonly-compiled languages as C and C++. -- [[User:Robert Merkel|Robert Merkel]]

==Definition of "compiler"==

The original definition of compiler is not necessarily bound to generation of executeable/object code. The general definition in the dragon book (which would worth a mention on its own on the compiler main page) goes roughly as "a compiler reads a program written in one language - the source language - and translates it into an equivalent program written in another language - the target language".
Also a rough lineup of the history of compiler development, maybe split from "first FORTRAN compiler to [[dragon book]]" and "dragon book until now" would be nice. -- scut

:From [[language compiler]]: a [[programming language]] compiler is an application that translates text of [[computer program]] written in some human-understandable [[programming language]] into the native code ([[machine code]]) of a particular physical processor, or into some virtual (software) machine code (e.g. [[Java programming language|Java]] compiler). --Anonymous

== Need help in compiler construction ==

Hi,
I need some help in my compiler construction course. I acquire the famous '''Dragon Book''' but it seems to me very difficult as it contains all examples in pascal & I had C/C++ background. So if you know any good book or link then please share with me.
Thanks in advance,
''Iqbal''

:This is not a compiler discussion forum.  It is for discussion of the Compiler entry of Wikipedia. 

:Oh, and the Dragon book is definitely the book you want.  Learn Pascal.  It's not that hard.  -[[User:Doradus|Doradus]] 20:15, 9 Jun 2004 (UTC)

On the other hand, [[Wikibooks:Compiler construction]] *is* a compiler discussion forum.
--[[User:DavidCary|DavidCary]] 04:00, 27 Jun 2005 (UTC)

==[[Pascal (programming language)|Pascal]]==

"The Pascal programming language is well known for this capability, and in fact many Pascal compilers are themselves written in the Pascal language because of the rigid specification of the language and the capability to use a single pass to compile Pascal language programs."

I don't understand the logic here. --[[User:Grouse|Grouse]] 13:37, 10 Jul 2004 (UTC)

:Nor do I. I've heard similar sentiments expressed as an article of faith in Pascal - 20 years ago. Charmingly quaint now, but quaintness is not part of the mission, and it should go away or be rephrased. [[User:Stan Shebs|Stan]] 19:10, 10 Jul 2004 (UTC)

::I suspect the real reason "many Pascal compilers are themselves written in the Pascal language" merely because Pascal is used in the [[Dragon book]]. But the authors picked Pascal because of those above reasons.

::Let me expand on what I *think* that sentence in the article is trying to say:
* If I had to write a compiler for some given language from scratch, I wouldn't implement the compiler in Pascal. I would pick ''some more modern language'' (perhaps using Lex, AWK, Bison, etc.), something incredibly sophisticated and full-featured. However,
* if I had to write a compiler, and I could pick what language it compiled, I'd pick something really simple and easy like [[assembly language]] or [[L00P]]. I'd still try to implement the compiler in ''some more modern language''.
* The idea of a "self-hosted compiler" is intellectually challenging[http://www.catb.org/~esr/jargon/html/M/MFTL.html]. If a language is really great, wouldn't it make it easy to write ''everything'' in it ? Even compilers ? Even ''it's own'' compiler ? But if I get to pick the language, I would never pick ''some more modern language'' -- there's far too much stuff to implement. But I wouldn't write such a thing for [[L00P]], either -- there's only a few things to implement, but the code is so difficult to read, write, and test. I think Pascal is close to the "sweet spot", and [[Dragon book]] seems to agree. If I had to rank languages from "easiest to write a self-hosted compiler" to "most difficult", I would guess something like Forth, Pascal, Lisp, assembly language, BASIC, Small C ...
::Does that make sense ? Of course, I'm far too long-winded -- is there a better way to rephrase this ?
::--[[User:DavidCary|DavidCary]] 04:00, 27 Jun 2005 (UTC)

I would disagree with your assessment.  There are two very good reasons for a language compiler to be self-hosted
# You do not have to have two code bases, one consisting of the test packages for the compiler (in the language the compiler processes) and a second code base consisting of the compiler source itself.  You can even use the compiler as a test case for itself.
# If the compiler is open source, the users of that compiler can (theoretically) submit bug fixes and updates, since they can actually read the source code.
And some good reasons to use Pascal or Basic for a compiler as opposed to C
# Unless you're writing an assembler or you can write the compiler's its own run-time library 100% in itself, there is going to be some assembly language used in the compiler, but usually you want this as small as possible.  So it means that ''every'' language has some assembler in it, at least at the run-time library level (I'm not counting the assembly or object code generated by the compiler.)  Now, if you can find a way to do run-time startup and setup code in the target language then it is theoretically possible not to have to use it, but I suspect sooner or later there's going to be "some assembly required." :)
#I have actually looked at the code involved in at least two self-hosted basic compilers, and I've written a Fortran to Visual Basic translator (using Visual Basic) and I think, if the level of strength of the compiler is good, it is no more difficult to write a compiler using Basic than Pascal or any other language, and probably easier than C because Basic (and Pascal) have built-in string types which C lacks.  (C's strings are an ''abstraction'', and they don't allow trailing zero bytes, and to know the length of a string you have to count it every time; Basic and Pascal use strings with a length prefix and you can store anything in them.) [[User:Rfc1394|Paul Robinson (Rfc1394)]] 16:00, 3 April 2007 (UTC)

::On the other hand, perhaps my understanding is ''quaint'' and out of date. Please bring me up-to-date. Perhaps there is some *other* language that is now considered better for learning about self-hosting? Perhaps the idea of "self-hosting" is now considered unimportant?
::--[[User:DavidCary|DavidCary]] 04:00, 27 Jun 2005 (UTC)

I mostly agree with David. Also keep in mind that in the old days, a language that was not self hosting was considered a failure, or at best not truely a general purpose language. (since if GP, one could implement a compiler in it). Pascal is fairly nice to create a compiler for imperative languages.  

Writing compilers in assembler is insane, since the refactoring for each new iteration (e.g. with better optimizations) would kill you. I know, since I tried :-)  

The *nix LALR parser tools (Yacc and its GNU variant Bison and Lex) IMHO have as problem that they don't really simplify relative clean languages, also the quality of errormessages is often quite bad. This is one of the reasons why most commercial compilers (including GCC since either 4.0 or one of the later 3.x releases) are recursive descent.

I'm not a OOP purist, but OOP (read basic inheritance) does help when writing a compiler, so for that original Pascal disqualifies, and I wouldn't use it today. A modernised dialect like [[Delphi]] or [[Free Pascal]] are quite ok though. (Unsigned comment)

*If you want to check out [ftp://pdp-10.trailing-edge.com/pub/pdp10freewarev2/lib20/0003/pascmp.pas this link] what you'll find is a 350K, 12,537 line listing of the source to a Pascal Compiler for the PDP-10.  It's not OOP, and it is self-compiling.  Probably something for people who are very masochistic.   :)  Speaking of Masochism, Nicklaus Worth reported that (and if you'd ever written programs on a CDC Mainframe, as I have, you'd understand why he did) the original Pascal compiler was written in Fortran.  [[User:Rfc1394|Paul Robinson (Rfc1394)]] 04:45, 26 March 2007 (UTC)

Self Hosted vs. not being self-hosted is a lot like making a choice between a motorcycle, a John Deer Tractor, or a pick up truck.  If you need great gas mileage and want to be able to slip into spots with little space grab a motorcycle.  If your wanting to plow your field, I wouldn't try to hook up a plow to a motorcycle!  And neither a motorcycle or tractor's really good for carrying all your furniture to a new house, unless you have a trailor attached to it....  Not to mention, a tractor's not as good on dates with most women.... Likewise, if your developing an open-source compiler whose goal is to allow others to modify it, then by far self-hosted is the way to go!  If on the other hand, your wanting to sell your compiler, and wish to gain an edge by having your own optimized routines, or routines that perform task that no other compilers can do, then it makes no sense to demand that the compiler be able to compile its own self.  --[[User:Johng1970|Johng1970]] ([[User talk:Johng1970|talk]]) 22:17, 9 June 2008 (UTC)

If I remember right, Wirth originally set out to write Pascal in Fortran, but the attempt failed.  So instead he (and others) wrote the Pascal compiler in Pascal itself. --anonymous 16 Jan 2008  <span style="font-size: smaller;" class="autosigned">—Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[Special:Contributions/68.222.42.172|68.222.42.172]] ([[User talk:68.222.42.172|talk]]) 23:53, 16 January 2009 (UTC)</span><!-- Template:UnsignedIP --> <!--Autosigned by SineBot-->

==Weird, weird, weird==

Normal humans, as opposed to persons knowledgeable in computer science, would expect an article title [[compilation]] to be about what that word meant until last week.  But those who have studied computer science (most of them, anyway) deny as a matter of religious dogma that the world existed before last week. [[User:Michael Hardy|Michael Hardy]] 20:45, 19 Jul 2004 (UTC)

::??? [[User:Stan Shebs|Stan]] 01:00, 20 Jul 2004 (UTC)

:Um... there is no article named [[compilation]]. When I try to find one, I only hit a redirect to [[compiler]].
:What do you really want ? --[[User:DavidCary|DavidCary]] 06:00, 26 Jul 2004 (UTC)

: Michael, if you're unhappy with the redirect and have better ideas for it, disambiguate and break the redirect yourself. I don't think there's much room for something other than a dictionary definition, if I understand you correctly... [[User:Dysprosia|Dysprosia]] 07:24, 26 Jul 2004 (UTC)

For the record compilers have been around since at least the 1960s.

:It would be nice to have a discussion of the origins of the words "compiler" and "to compile" as it applies to computers. Who used the term first? Before there were computers these words were in use, usually associated with "compile a list". The first computer programmers were very literate folks. While defining this new field they made very creative use of the English language.  --- And by the way, for the record compilers have been around since at least the late 1950's.  --[[User:Rchrd|rchrd]] 01:50, 11 July 2006 (UTC)

==Aren't compilers system software?==

*Until quite recently, I lived under the impression that assemblers, compilers, linkers, etc, belonged to the category of ''system software''. But the wikipedia [[:Category:System software|category]] of the same name seems to indicate otherwise (only OSs, drivers, and related SW are included). Could someone enlighten me as to this matter? I just haven't been used to think of compilers etc as ''applications'' (implying that apps are for -eh- "end users", as opposed to programmers/hackers). At the [[Norwegian Institute of Technology|university]] where I got my CEng degree, we even had a course called ''System programming'' which specifically addressed compiler writing and connected topics (no wonder I'm confused...). --[[User:Wernher|Wernher]] 23:36, 24 Jul 2004 (UTC)

:(What the &^%$! was that last edit all about? I think some of the discussion materal got deleted) Anyway, yes, it's usual to put compilers in system software if you're only allowed to have app and system software categories, otherwise you'd finesse the question by putting it in programming tools and not asking too many questions. :-) [[User:Stan Shebs|Stan]] 03:32, 25 Jul 2004 (UTC)

:: On the top level Software is devided to '''only two''' categories: system and application. All other categories are subcategories of this two. [[User:Kenny sh|Kenny]] 10:11, 2004 Aug 8 (UTC)

::Yep, no problem. I did. BTW, I've made a major effort today/night in (sub)categorizing all the stuff in [[:Category:Software]] (too much was lying around in the Software 'root directory'; in my opinion the subcategories should at least be used if we create them in the first place...). I hope my work led to a more logical and easily navigable sw information collection than before. --[[User:Wernher|Wernher]] 03:30, 26 Jul 2004 (UTC)

*I'd disagree strongly that compilers should be counted as ''system software''. I would expect that category to contain the software that keeps the 'system' running, ie. mainly the OS functionality. A compiler, while creating code which may perform that function, is not necessary in any way to operate a 'system' (although it may make system calls during operation, etc). --[[User:VampWillow|[[User:VampWillow|Vamp]][[User talk:VampWillow|Willow]]]] 21:44, 7 Aug 2004 (UTC)

::: Excuse me, IMHO, VampWillow is not accuanted enougth with CS. In CS compilers etc are under system software. [[User:Kenny sh|Kenny]] 10:11, 2004 Aug 8 (UTC)

*Compilers can be system software (typical case:Unix). However they don't need to be. E.g. something like Delphi doesn't have any direct connection to the OS builders. I'd rather put them under apps myself too.  Kenny, could you produce a reference for your argumentation? That is more useful than yes/no fights.  (unsigned entry)

*I think I can add some light (and less heat) to this discussion by adding the following.  Originally, when large computers were sold, they came with a base set of system software to be able to use them, including an assembler, Fortran, Cobol, Basic (interpreted or compiled or both) and RPG III compilers, or you bought them as add-ons from the manufacturer of your computer and operating system.  At that time you could classify compilers as system software because they were either sold as a package as part of the operating system or were sold to sophisticated, technical users. 
 
*Compilers help convert high level programs developed in languages like C, C++, Basic to lower level programs expressed in assembly or machine language for a specific processor. As such a computer or microprocessor hardware is completely useless without a compiler that can convert significant amount of code to that computer's instruction set architecture. A modern day computer has one or more physical processors and several virtual processors or virtual machines. A Java Virtual Machine (JVM) is one example of a virtual processor. A JIT compiler can and does at run time, compiling the byte-code to underlying machines ISA. Often, compiler designers work closely with processor architects even before a processor is developed at the architecture and design stage. Ability to purchase some thing at a specific location has nothing to do with the category for that thing. A compiler often produces object code in a standard format like COFF or ELF which is then loaded by the operating system. A compiler often links in standard run-time libraries to executables. In languages like the C++, the working of something like exception handling is a complex puzzle pieces of which are done at compilation and others at run-time without the programmers knowledge. Just as an operating system increases the abstraction of the system services available to a user (programmer), a compiler increases the abstraction of the system processing architecture available to a programmer. In fact, a compiler is more fundamental system software than the operating system itself, because most of the times the operating system developers depend on the capabilities of the compiler. There are interesting ways in which compilers are bootstrapped for new processors that don't yet have an operating system. With that argument, I rest my case that compilers are in theory and practice the core part of system software. Time some one proficient in the ways of wikipedia takes the effort to relook at this categorization. 

:Today, compilers are sold over the counter in retail stores - or downloadable for free - by third parties who make them and have nothing to do with the computer manufacturer or operating system vendor and in some cases are available for multiple operating systems (Free Pascal, Free Basic and Java, among others), and thus would no longer qualify as "system software."  [[User:Rfc1394|Paul Robinson (Rfc1394)]] 19:29, 26 March 2007 (UTC)

:In the past there have been plenty of examples of operating systems which could be implemented without using a compiler (e.g. any operating system written in assembly language);  but a cross-compiler running on some other architecture can make operating system implementation much easier.  At the extreme you don't even need an assembler. On one occasion, just for the experience, I developed a very small operating system by writing it in assembler using absolute addresses for variables etc., hand-translating it to binary, writing out the 0's and 1's, spliting it in to 5-bit chunks, very carefully punching the equivalent characters on to 5-hole paper tape, and feeding the resulting tape into the built-in bootstrap loader; somewhat to my surprise it actually worked first time. [[User:Murray Langton|Murray Langton]] ([[User talk:Murray Langton|talk]]) 09:19, 16 June 2008 (UTC)

==n-pass vs "n-parse"==
Hmmm, how is it that the [[Dragon Book]] uses ''pass'' rather than ''parse'' in the relevant context? I would like to believe that Aho, Sethi, and Ullman knew what they were writing about. Strange, or what, [[User:VampWillow|VampWillow]]? --[[User:Wernher|Wernher]] 21:15, 7 Aug 2004 (UTC)

:Ah well, these 'Johnny come lately's do get things wrong occasionally, but as I was taight how to write compilers (and the rest) back in the mid-70s, and *the* book on the subject was the 1971 '''Compiler Construction for Digital Computers''' by David Gries which uses 'parse' then, I think, I rest my case! 
:It is, however, a ''very'' common mistake, as with newer compilers repeating their transit through the source code then the original usage of ''parsing the lexical strings to create the output streams/code/etc'' rather than being well-written and just going through the once, then the original spelling got lost somewhat (and some youngsters like to think they invented computer languages! ;-) --[[User:VampWillow|[[User:VampWillow|Vamp]][[User talk:VampWillow|Willow]]]] 21:40, 7 Aug 2004 (UTC)

:: May be somewere it is misstake, but not here. [[User:Kenny sh|Kenny]] 10:19, 2004 Aug 8 (UTC)

:::um, given that you are unable to spell 'mistake' and acknowledge in your userpage that ''I am not fluent in english, so please feel free to edit my comments in wikipedia'' I think it was rather pre-emptive of you to revert the correction made, especially whilst discussion is on-going. As such I have removed the revertion. --[[User:VampWillow|[[User:VampWillow|Vamp]][[User talk:VampWillow|Willow]]]] 11:23, 8 Aug 2004 (UTC)

OK kids, let's hold off on the edit war and finish the discussion please. I think the use of "multi-parse" must be something that died relatively quickly, because I started learning about compilers in 1975 and don't remember hearing of that usage (thought I had a copy of Gries, but can't seem to find it). I suspect that "pass" came to be favored because a step that processes intermediate code into better intermediate is not really "parsing" anymore, plus preprocessing and assembly steps aren't really doing parsing either. Since our usual rule is to use the most common term, I think we should use "pass", but at the same time include a note that some sources use "parse" to mean the same thing (since there's a confusion about this, the WP article can be valuable in clearing it up). [[User:Stan Shebs|Stan]] 13:53, 8 Aug 2004 (UTC)

:I have now entered a comprehensive note about the pass/parse usage, with which I hope we may reach a concensus regarding this question. I find the discussion very interesting, as I had in fact not thought of ''pass'' as emanating from ''parse'' before (quite plausible using English pronounciation). Whether this is the case for all use of ''pass'' in compilers, or whether ''pass'' has also been used independently from the beginning, I think is an open question. Also allow me to admit that I should perhaps have added <nowiki><slightly sarcastic>txt</slightly sarcastic></nowiki> tags around my starting comment of this thread. I did not intent to be 'evil'/sarcastic as such. --[[User:Wernher|Wernher]] 00:37, 9 Aug 2004 (UTC)

::"parse" is the source of the deriviation "pass" as to parse something is to work through it, and the first parse would grab syntatic elements, second parse build tables, etc. as each parse would re-inspect the data. When you try to think carefully about it you can't really make the word "pass" do the same function in an active sense. I suspect there could even be a language (en-us/en-uk) issue in here too, maybe? but. 'Object code generation' btw is done during a parse of the stored data (and again 'pass' doesn't really make sense!). PS. Nothing wrong with being ''evil'' occasionally! --[[User:VampWillow|[[User:VampWillow|Vamp]][[User talk:VampWillow|Willow]]]] 10:24, 9 Aug 2004 (UTC)

:::"Parse" and "pass" have nothing to do with each etymologically, so saith OED. I got an opportunity to look at Gries (via a colleague at Apple even older than I am :-) ) last week and not only does Gries also use "pass" in the "multiple passes" sense, but there is no reference to "multiple parses" that I could find. So I think we need to get a book and page number that justifies this alternate sense of "parse" - don't want this article to become the source of a [[lemming]]-suicide-type legend! [[User:Stan Shebs|Stan]] 21:14, 15 Aug 2004 (UTC)

:::Coming late to this discussion, but I also find the footnote to be fairly tangential and a bit unlikely. I've never heard of parse and pass being conflicted; they seem very distinct to me. To make things more confusing, the Dragon Book (Aho, Sethi, and Ullman) does not refer to <i>either</i> multi-pass <i>or</i> multi-parse. It defines the former, but then discards it as being too narrow for their purposes:
::::"Several phases of compilation are usually implemented in a single <i>pass</i> consisting of reading an input file and writing an output file. In practice, there is great variation in the way the phases of a compiler are grouped into passes, so we prefer to organize our discussion of compiling around phases rather than passes." -- Compilers: Principles, Techniques, and Tools, 1988 edition, page 20.
:::Here, a <i>pass</i> is primarily a means of counting the number of times data is read and written -- it is mainly a way to count the expensive file I/O loops. The dragon book uses "phases" where this wikipedia article uses "passes". Given the importance of this book in the general CS populace, it might even make sense to add a footnote about "phases", to replace the one on "parses"! But anyway, unless someone has references to a book that uses "multi-parse", I'm going to say that the footnote is unnecessary. And since Stan asked for a reference years ago, and it didn't materialize, it seems safe to delete this footnote now. So I did! If that's inappropriate, you can revert it and yell at me. [[User:Captain Wingo|Captain Wingo]] 11:37, 5 December 2006 (UTC) [Edit - changed "1998 edition" to "1988 edition" :-) 

There is a difference; I've never heard the word "parse" used in the context of multiple repetition of source-code processing by a compiler; the term has always been "pass", e.g. a 1-pass compiler, a 2-pass compiler, etc.  Now, on each pass the compiler may - and probably does - ''parse'' the source, but I've never heard of a 1-parse or 2-parse reference.  I mean, I heard the first Fortran compiler had to squeeze into such a small area that it was something like over 50 passes!  [[User:Rfc1394|Paul Robinson (Rfc1394)]] 19:35, 26 March 2007 (UTC)

== threaded and incremental: the same ? ==

The article currently mentions

* [[threaded code]] compiler (or interpreter)
* [[incremental compiler]]

but I'm still a bit fuzzy on the difference between them. I think I understand [[threaded code]], but [[incremental compiler]] is simply a redirect to [[compiler]], which has no more information.

What's the difference ?

--[[User:DavidCary|DavidCary]] 01:57, 6 Nov 2004 (UTC)

A threaded compiler can compile parts in paralel, or parse and do codegeneration/optimization (for previously compiled parts) in paralel. The former is more likely.

An incremental compiler only (re)compiles the needed parts of a source. One could discuss about the granularity of what is the
minimal part that must be recompiled (procedure or whole compilation unit). 

These two things are IMHO not related
{{talkarchivenav}}

== First self-hosting compiler? ==

I'm wondering if anyone knows of a ''self-hosting'' compiler prior to Hart and Levin's 1962 Lisp compiler described in [ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-039.pdf Artificial Intelligence Memo 39, "The New Compiler"] (767 kB scanned PDF). The memo describes this compiler as "the first compiler that has ever compiled itself by being executed interpretively." However, I'm not sure if this is to be taken as meaning that it is the first self-hosting compiler ... or just the first one to combine interpretation and compilation in the way that Lisp systems have ever since.

The only languages for which we have cites for earlier compilers are FORTRAN and COBOL; were there (prior to 1962) any FORTRAN compilers written in FORTRAN, or COBOL compilers in COBOL? I find this question interesting in part because it casts light on just how odd is the misconception many people have, that Lisp languages are interpreted ... :) --[[User:Fubar Obfusco|FOo]] 02:25, 16 Nov 2004 (UTC)

:Probably not any compilers written in Fortran or Cobol around 1960, for one thing it would have been hard to code things like symbol tables. Assembly was how one did system programming back then. However, Backus in HoPL mentions knowing about a Corrado Böhm language ca 1953 for which a self-compiler had been published, don't know any more about that. Some of the earliest languages were not that different from assembly, and certainly self-assembling assemblers go back into the early 50s. [[User:Stan Shebs|Stan]] 04:12, 16 Nov 2004 (UTC)

::Following some citations suggests [http://portal.acm.org/citation.cfm?id=964750.808380&coll=portal&dl=ACM&CFID=11111111&CFTOKEN=2222222 this paper], but it's not publicly available to non-ACM-members. Grumble, grumble. I expect it's probably fair to say that Hart and Levin's Lisp is the first ''recognizable modern'' language with a self-hosting compiler, since the sample code presented in their memo is within a keyword or two of working in Common Lisp or Scheme. If we're going to say ''"the FORTRAN team led by John Backus at IBM is generally credited as having introduced the first complete compiler, in 1957"'' then I feel fair calling Lisp in '62 the first self-hosting one. --[[User:Fubar Obfusco|FOo]] 05:16, 16 Nov 2004 (UTC)

I have heard that there was one [[self-hosting|self-hosted]] [[Cobol]] compiler, supposedly it was about 800,000 lines of code.  But I don't think there's ever been a self-hosted [[Fortran]] compiler, or at least none that was advertised.  Now, the [[Ratfor]] preprocessor, I believe that was written in Fortran.  (I looked it up; according to the article, Ratfor was written in Ratfor, and could translate itself to Fortran).  [[User:Rfc1394|Paul Robinson (Rfc1394)]] 19:40, 26 March 2007 (UTC)

== how is "threaded code compiler" different from any other kind of compiler? ==

''the article currently claims''

* [[Threaded code compiler]] (or interpreter), like most implementations of [[FORTH]]
** This kind of compiler can be thought of as a database lookup program. It just replaces given strings in the source with given [[binary numeral system|binary]] code.

''While this is certainly true for most Forth compilers, how is this any different from any other kind of compiler ? For example, doesn't *every* compiler replace the "while" string in a do{...}while(); loop with the appropriate machine-language binary code for test-and-jump ?''

:The level of this binary code can vary;

''Huh?''

:in fact, some FORTH compilers can compile programs that don't even need an operating system.

''I certainly think it's very interesting that some compilers can create programs that don't need an operating system.. Cross-compilers for microcontrollers produce programs that run "on bare metal"; any [[RTOS]] for those systems is usually re-compiled and mixed with the application. Visual Basic and Java compilers, on the other hand, create programs that require some sort of operating system. What would you call these two kinds of compiler?.''

''I suggest replacing that with:''

* [[Threaded code compiler]] (or interpreter), like most implementations of [[FORTH]], generates [[threaded code]].
** This kind of compiler focuses on producing extremely small output to fit into limited memory systems. Often people make the compiler itself very small, so it also can fit into the target system (as a native compiler). Typically single-pass. Often places output directly into RAM where it can immediately be executed (like a just-in-time compiler) -- this allows programmers to write functions that are executed during the compilation of later functions. (Most other compilers require the entire program to be completely compiled, before any of it is executed).

* '''(some good name here) compiler''' generates "hosted" applications that require some sort of operating system.
* '''(some other good name here) compiler''' generates "freestanding" code that runs "on the bare metal" without any operating system. People who write operating systems use this kind of compiler.

''--[[User:DavidCary|DavidCary]] 04:00, 27 Jun 2005 (UTC)''

I think the freestanding vs hosted discussion is pretty useless. It is only a gradual difference in how much work you must do to create a freestanding app. (iow if I must fix the RTL?)  It seems to me a hosted compiler can become freestanding if the vendor postdelivers a minimal RTL with no OS ties, so a categorisation hosted or not seems only temporarily valid at best.

== Figure 1 should be explained ==

Hi, I am creating an OpenOffice.org source drawing in order to translate the figure to other languages. The draw in spanish and a source file link is going to be put in commons. I realize that the figure is not explained in the article text as the good practice sign to. For example, "target code generator" or "machine code" are not sufficient treat. --[[User:gengiskanhg|GengisKanhg]] ([[User talk:Gengiskanhg|my talk]]) 13:32, 27 September 2005 (UTC)

== WikiProject Efficiency ==

[[Wikipedia:WikiProject Efficiency]] I'm looking at the list of related compiler articles and merging or redirecting the weaker stubs: did 2 already. [[User:Cwolfsheep|Cwolfsheep]] 23:32, 4 June 2006 (UTC)

== Bad Link URL ==

The link to CodePedia needs a www. prefix. It give me a "Host not found" message. I'll fix it.  --[[User:Rchrd|rchrd]] 01:54, 11 July 2006 (UTC)

== The last sentence in the "Compiled vs Interpreted Languages" ==

The last sentence in the "Compiled vs Interpreted languages" section is: ''"To implement these features in a compiled language, programs must usually be shipped with a runtime environment that includes the compiler itself.''"  Shouldn't that be: ''"... shipped with a runtime environment that includes the '''interpreter''' itself?"''  Or am I just splitting hairs?  -[[User:Matt B.|Matt B.]] 03:14, 17 March 2007 (UTC)

:No, "compiler" is correct. An example is [[Steel Bank Common Lisp]], or many other Lisp systems. The runtime environment includes a compiler, which programs can use to compose and compile functions.

:(For clarification, current versions of SBCL ''also'' include an interpreter. But the <code>COMPILE</code> function is most definitely part of the runtime, and that function ''is'' a compiler.) --[[User:Fubar Obfusco|FOo]] 04:25, 17 March 2007 (UTC)

== Link vandalized ==

I'll restore the link to my book "Build Your Own .Net Language and Compiler", since it has been recognized by several Amazon reviewers as a useful way for non-computer-scientists to learn compilers at an entry level, and many Wikipedia visitors need this information. Please do not vandalize it again. Thank you. <small>—Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[Special:Contributions/{{{IP|{{{User|202.82.33.202}}}}}}|{{{IP|{{{User|202.82.33.202}}}}}}]] ([[User talk:{{{IP|{{{User|202.82.33.202}}}}}}|talk]]) {{{Time|06:34, 26 June 2007}}}</small><!-- Template:UnsignedIP -->

:You have a clear conflict of interest here and shouldn't add your own book at all.--[[User:Atlan|Atlan]] ([[User talk:Atlan|talk]]) 10:51, 26 June 2007 (UTC)

:: Nonsense. Just because some authors are dishonest and have conflicts of interest don't mean that all are dishonest and conflicted. The question as to whether the book is a useful link is logically independent of my interest in the book. As in the case of the logical fallacy of ad hominem, the question isn't solely "material": mere insulting text doesn't indicate the ad hominem fallacy of invalidly inferring from character, and here, the fact that I am the author doesn't in any way imply that I would add an irrevelant link to a book that isn't about compilers, or that is not useful to people curious about the topic. This utility has been confirmed by Amazon reviewers who have read the book.
:: By your logic, a scholar or field expert would never, on wikipedia or anywhere else, be able to self-cite. This is of course nonsense. 
:: I will restore the link. Do not vandalize it again. <small>—Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[Special:Contributions/{{{IP|{{{User|202.82.33.202}}}}}}|{{{IP|{{{User|202.82.33.202}}}}}}]] ([[User talk:{{{IP|{{{User|202.82.33.202}}}}}}|talk]]) {{{Time|11:31, 27 June 2007}}}</small><!-- Template:UnsignedIP -->

::: I'm sorry, but due to the self-editing and self-publishing nature of the Wikipedia that is against Wikipedia's policies: see [[Wikipedia:Conflict of interest]] and [[Wikipedia:No_original_research#Citing_oneself]].[[User:Wolfkeeper|WolfKeeper]] 12:52, 27 June 2007 (UTC)
::: In such situations you should post the link here and other editors can add it ''if'' it is judged appropriate.[[User:Wolfkeeper|WolfKeeper]] 12:52, 27 June 2007 (UTC)

:::: I posted the link and I said "fair enough" as to your suggestion, and then some vandal removed it. Here is the link, again.
:::: ''(link removed)'' <small>—Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[Special:Contributions/{{{IP|{{{User|202.82.33.202}}}}}}|{{{IP|{{{User|202.82.33.202}}}}}}]] ([[User talk:{{{IP|{{{User|202.82.33.202}}}}}}|talk]]) {{{Time|05:13, 30 June 2007}}}</small><!-- Template:UnsignedIP -->

::::: That's a link to buy the book. No one is ever going to add that to the article, because that's against Wikipedia policy for external links. Read [http://en.wikipedia.org/wiki/Wikipedia:External_links#Links_normally_to_be_avoided this], especially point 4.--[[User:Atlan|Atlan]] ([[User talk:Atlan|talk]]) 10:26, 30 June 2007 (UTC)

== Compiled vs interpreted ==

This maybe warrants a whole sentence to itself to note that the act of interpretation is unavoidable in the course of execution, but certainly not a whole section. The sentence "many people believe there is a distinction between compiled and interpreted languages" lends undue weight in the same was as "many people believe the sun rises every day" does. [[User:Thumperward|Chris Cunningham]] 11:24, 11 July 2007 (UTC)

Of course there is a difference. Those who don't believe that don't know compilers. [[User:History2007|History2007]] ([[User talk:History2007|talk]]) 15:03, 25 November 2008 (UTC)

Phrases such as "many people believe" are classified as [[WP:AWW|weasel words]], and should be avoided. [[User:SlowJog|SlowJog]] ([[User talk:SlowJog|talk]]) 17:23, 29 April 2009 (UTC)

== Article Quality ==

I came across this article by pure chance and think it is laden with errors, half-baked thoughts and misclassified ideas, all gathered at random. Whoever has a claim to authorship here should start a discussion to improve this page, or let us just mark this page as low quality. An example is the whole (missing) discussion on byte-coded systems such as Java, Prolog, Smalltalk etc. The fact that the WAM is referenced in passing maybe ok, given that Prolog is not that hot any more, but the relationship and comparison of Java and the other Byte-coded systems is really missing and mostly haphazrad - in effect incorrect. And the history byte-coded and threaded interpreted things (going back to ancient systems) would help develop a discussion thread (pun intended). I am too busy to work on this page now, but please comment here to see what happens. Thanks. [[User:History2007|History2007]] ([[User talk:History2007|talk]]) 15:03, 25 November 2008 (UTC)

:PS Regarding the incorrect discussions here on interpreted and compiled systems, think of it this way: If a program is self-modifying, how can an interpreter and compiler work the same way? They can not. [[User:History2007|History2007]] ([[User talk:History2007|talk]]) 15:34, 25 November 2008 (UTC)

== Compilation as a means of protecting software intellectual property ==

The article doesn't seem to mention that compilation and distributing only executables allows the proprietor to conceal implementation details.  So compilation can be used as a means of protecting software intellectual property.  [[User:Pgr94|pgr94]] ([[User talk:Pgr94|talk]]) 19:42, 16 December 2008 (UTC)

:You are assuming that the distributor of the software has a choice.  For many languages compilation is the only option.  Also compiled code can be [[disassembler|disassembled]], so implementation details are not concealed but have a reduced information content (eg, no comments, assuming that the source had them in the first place). [[User:Derek farn|Derek farn]] ([[User talk:Derek farn|talk]]) 00:16, 17 December 2008 (UTC)

::The only option?  I don't think so, the distributor can supply source if s/he wishes, and some do.  Compilation produces output that is hard to understand (for humans) and this can be used for business purposes.  Just consider the damage to major software house if the executable was as intelligible as the source.   I think this is an important aspect of compilation and suggest it be mentioned in the article. [[User:Pgr94|pgr94]] ([[User talk:Pgr94|talk]]) 13:21, 19 December 2008 (UTC)

:::By only option I meant that the only option for producing an executable is to use a compiler.  Source code execution of the kind often supported by implementations of the [[Basic programming language]] is rarely available.  With regard to intelligibility, this is really a side effect of compilation and is only a minor issue (but one that could still be mentioned). [[User:Derek farn|Derek farn]] ([[User talk:Derek farn|talk]]) 22:25, 21 December 2008 (UTC)

== Compiler article errors ==

This article is still pretty low quality and full of errors, and some of my attempts at improving it are getting reverted - hence maintaining the low quality. The ''very'' first sentence of the article used to use the word ''translate'' which showed a major misunderstanding of the topic. Fortunately that correction has been left alone. But there is no mention of, and direct comparison with translators and interpreters on this page and the term ''translate'' is freely used throughout, in confusing contexts. Shall I bother to correct that?

I added a sentence about [[compiler-compiler]]s and it was reverted. How on earth can you have an article on compilers and not have a sentence about compiler-compilers. There needs to be a discussion of that, and more in depth!

Moreover, this article has ''totally'' missed the point about theoretical and practical differences between compilers, interpreters, and translators - as was perhaps evident from the very first sentence. At some point the article used to say that "all languages are interpreted".... a gem of an error. I had a hard time keeping that correction in. There are passing references to byte-code interpreters, but the discussion is amateur at the very best. I deleted a few really incorrect sentences (and thank you for not putting those errors back) but I seem to be running against a wall of lack of overall knowledge. This article is in poor shape, please let it be improved. Thank you. [[User:History2007|History2007]] ([[User talk:History2007|talk]]) 13:37, 27 December 2008 (UTC)

PS: While pondering these errors, and how to fix them, I clicked on [[Translator (computing)]] and someone else had correctly pointed out that it was also in poor shape. I think these two articles need to get fixed together and refer to each other. [[User:History2007|History2007]] ([[User talk:History2007|talk]]) 16:30, 27 December 2008 (UTC)

PS2: Reverts again and new errors are introduced! The sentence "The term compiler-compiler is sometimes used to refer to a parser generator, a tool often used to help create a compiler." is incorrect. My friend, I am getting tired of teaching remedial computer science here. Parser generation is one piece of compiler generation. That should be obvious. And please do NOT remove the low quality tags without discussion. Thank you. [[User:History2007|History2007]] ([[User talk:History2007|talk]]) 19:03, 27 December 2008 (UTC)

== On classic texts added to further reading ==

[[User:Derek farn]], without discussion, removed some classical references to Compiler construction which I inserted in the Compiler article. It's not quite out-of-date. He wrote in his editing comment: "Only contained very old and hard to obtain material." They are considered classics and timeless, so I've added them in as '''historical''' in case of someone's arguing modernity. I am re-inserting them. Consider just one, the Cocke and Schwartz book. It's been written: "''Programming Languages and their Compilers [44], published early in 1970, devoted more than 200 pages to optimization algorithms. It included many of the now familiar techniques such as redundant code elimination and strength reduction, dealt extensively with graphs of control flow and their partitioning into 'intervals', and showed how to split nodes in an irreducible flow graph to obtain a reducible one.''" The items referenced:

* [[John Cocke|Cocke, John]]; [[Jack Schwartz|Schwartz, Jacob T.]], ''Programming Languages and their Compilers: Preliminary Notes'', [[Courant Institute of Mathematical Sciences]] technical report, [[New York University]], 1969.
* Fritzson, Peter A. (editor), [http://books.google.com/books?id=xuoOGxK-EPoC&printsec=frontcover ''Compiler Construction: 5th International Conference, CC '94''], Edinburgh, U.K., April 7-9, 1994 : Proceedings, Published by Springer, 1994. {{ISBN|3540578773}}
* [[David Gries|Gries, David]], ''Compiler Construction for Digital Computers'', New York : Wiley, 1971. {{ISBN|047132776X}}
* McKeeman, William Marshall; [[Jim Horning|Horning, James J.]]; Wortman, David B., [http://www.cs.toronto.edu/XPL/ ''A Compiler Generator''], Englewood Cliffs, N.J. : Prentice-Hall, 1970. {{ISBN|0131550772}}

The authors are very well known in the field, to boot. And the materials are available in libraries if not online. They are old, but not stale. Cheers. --- (Bob) [[User:Wikiklrsc|Wikiklrsc]] ([[User talk:Wikiklrsc|talk]]) 20:54, 28 January 2009 (UTC)

:The article is lacking in-line references and if these further-reading sources could be incorporated to substantiate the text of the article it would be a great improvement. Cheers. [[User:Pgr94|pgr94]] ([[User talk:Pgr94|talk]]) 09:20, 29 January 2009 (UTC)

:: Hello. Well [[User:Derek farn]] has removed them from the article again and put them into a near-orphaned article which I think you may have been involved in as well. It's academically sad, such important works being removed. They are quite relevant to the topic and are the basis for many modern texts and compiler technologies. Most were pre-sagacious for their time and considered classic to still read and understand today. I could write them into the article but I am reluctant to spend hours writing to have it removed unilaterally by someone else. This is all very off-putting. Thanks, anyway. --- (Bob) [[User:Wikiklrsc|Wikiklrsc]] ([[User talk:Wikiklrsc|talk]]) 15:04, 29 January 2009 (UTC)
:::Hello Bob.  If the books are reliable sources for specific statements in the text then by all means add them as inline references.  That would be good as it would kill two birds with one stone: 1) supplying inline references for unsourced statements and 2) getting important references included (although I can't judge if they are the best sources because I don't know the field well enough).  If the references are not inline then I too think that don't help the reader much because the sources don't connect to the contents of the article and readers won't appreciate their significance.  If you need help with inline references don't hesitate to ask.  Please don't be disheartened.  [[User:Pgr94|pgr94]] ([[User talk:Pgr94|talk]]) 16:49, 29 January 2009 (UTC)
:::: Many thanks for your comment. Inline references are not always the answer, [[Edward Gibbon|Gibbon]] notwithstanding. Sometimes there is an annotated bibliography in scholarly books. Well, there is an academic chicken and egg problem: do the citations write the article or does the article reference the citations? A classic conundrum. Your kindness  and suggestions are appreciated. Cheers. --- (Bob) [[User:Wikiklrsc|Wikiklrsc]] ([[User talk:Wikiklrsc|talk]]) 17:42, 29 January 2009 (UTC)

While the books might be classics they are not of much use to modern day readers of the article. References to these book would be useful in a history of compilers article but they only serve to clutter the compiler article. The fact that a book devoted more than 200 pages to optimization is only of interest if nothing better has been written since, and there are now longer books that discuss many more algorithms in a lot more depth. [[User:Derek farn]] 13:01, 29 January 2009 (UTC) 
:Hello. I respectfully disagree with you, having been in the field for decades. You also moved the book and article references into a near-orphaned article on the History of Compilers, which was seemingly awkward. All the more recently published books rely on the critical seminal aspects and breakthroughs of the books I cited. You likely haven't read them, so you don't know. A real disruption has been created, and hours of work on the article by me has been brushed away by you unilaterally. This is not good form. --- (Bob) [[User:Wikiklrsc|Wikiklrsc]] ([[User talk:Wikiklrsc|talk]]) 15:04, 29 January 2009 (UTC)

: But, Derek, thanks for starting the ball rolling on the [[History of compiler writing]]. I'll be adding to it. Best Wishes. --- (Bob)

Also, [[User:Derek farn]] removed carefully placed references and links to a very significant annual international conference on Compiler Construction without discussion writing in his edit comment that they were references to proceedings of one conference, even though the conference is considered quite important and I had looked for the published proceedings with papers and inserted them in the article for perusal. Methinks, [[User:Derek farn]], based on looking at [[User_talk:Derek_farn|his talk page]] and others' comments to him, has a penchant and a happy trigger finger for subjective reverts. At the top of the article, there is a banner asking for expert handling in the artcle, and I volunteered. But Derek Farn has gone beyond reasonableness it appears in his speedy and unilateral reversions. There was a better way to have handled this all. It's called co-operation. --- (Bob) [[User:Wikiklrsc|Wikiklrsc]] ([[User talk:Wikiklrsc|talk]]) 17:42, 29 January 2009 (UTC)

:Certainly in such field works are seminal or critical. For example Aho, Hopcroft and Ullman.  In related areas Horowitz and Sahni, Knuth, etc..  ''[[User:Rich Farmbrough|Rich]] [[User talk:Rich Farmbrough|Farmbrough]]'', 19:46 29 January 2009 (UTC).

== Compiler testing ==

Conflict of Interest Declaration:

I've tried to comply with
[[Wikipedia:Conflict_of_interest]]
and
[[Wikipedia:No_original_research#Citing_oneself]]. 
([[Wikipedia:No_original_research]]
doesn't apply in general, since my article was published in
''[http://www3.interscience.wiley.com/cgi-bin/jabout/1752/EditorialBoard.html Software: Practice and Experience],'' which is
peer-reviewed.)
I don't think [[Wikipedia:Conflict_of_interest]] applies.  Although I wrote the article when
employed by PalmSource, I no longer work for PalmSource, and
PalmSource is no longer in the compiler business.
I'm covered by a non-disclosure agreement between my former
employer and one of the commercial conformance suite vendors
I cite, but it's clearly one of the notable products
available, and I also mentioned its chief competitor.  My
citation of it should not be construed as a recommendation.  

—[[User:FlashSheridan|FlashSheridan]] ([[User talk:FlashSheridan|talk]]) 05:01, 13 March 2009 (UTC)
== Compilers in education ==

I know of no university courses that teach "Compiler construction and compiler optimization" at all, does anyone else? I believe some universities may offer it as a specialisation at post graduate level but even then to my knowledge most of the theory is based on finite state automata rather than actual compiler construction.  <span style="font-size: smaller;" class="autosigned">—Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[Special:Contributions/93.97.20.167|93.97.20.167]] ([[User talk:93.97.20.167|talk]]) 19:42, 25 December 2008 (UTC)</span><!-- Template:UnsignedIP --> <!--Autosigned by SineBot-->

:In my student days, I did take a grad course called ''Compiler Construction'', but that was years ago. Just do a web search and I guess it will show up. [[User:History2007|History2007]] ([[User talk:History2007|talk]]) 12:06, 26 December 2008 (UTC)
:I was taught an undergraduate course on compiler construction at a leading UK uni in the early 90s. The textbook was "Crafting a compiler" by Fischer and Leblanc.[[User:Pgr94|pgr94]] ([[User talk:Pgr94|talk]]) 20:01, 27 December 2008 (UTC)

::Actually if you are looking for textbooks, [[Compilers: Principles, Techniques, and Tools]] is/was a basic book. It gives the basic ideas, and is written by well known people. And afterwards I clicked on it and [[Jeffrey Ullman]] is teaching a course with it at [[Stanford University]][http://dragonbook.stanford.edu/]. [[Alfred Aho]] is using it at a course in [[Columbia University]] as well. So the topic is not dead, and some of those wrote this Wikipedia page would be probably well served to take one of those two courses, then correct the errors herein. [[User:History2007|History2007]] ([[User talk:History2007|talk]]) 20:20, 27 December 2008 (UTC)

::It was taught at the University of Miami. [[User:Kernel.package|Kernel.package]] ([[User talk:Kernel.package|talk]]) 17:21, 30 June 2009 (UTC)

:Just thought I would add that, I'm currently studying an undergraduate course on compilers at the University of Manchester. [[User:KingSimonIV|KingSimonIV]] ([[User talk:KingSimonIV|talk]]) 14:54, 6 January 2009 (UTC)

== Archive? ==

Hey everybody... so this talk page is getting pretty long, and only the last 4 sections have comments from 2009. How do you all feel about [[Help:Archiving a talk page|archiving the old discussions]]? I can probably figure out how to set up a bot to do it, but I'd like a consensus. Anyone object? [[User:Indeterminate|Indeterminate]] ([[User talk:Indeterminate|talk]]) 08:48, 30 July 2009 (UTC)

: I've gone ahead and manually archived half of it, and set up archiving for the rest. You're right that it was silly still having live topics here from over five years ago. [[user:thumperward|Chris Cunningham (not at work)]] - [[user talk:thumperward|talk]] 10:09, 31 July 2009 (UTC)

::Thanks, looks good! [[User:Indeterminate|Indeterminate]] ([[User talk:Indeterminate|talk]]) 10:19, 31 July 2009 (UTC)
== Compilation section has been added ==

I thought the page needed more focused explanation about compilation so I added a section called 'Compilation'.  [[User:Lseongjoo|Lseongjoo]] ([[User talk:Lseongjoo|talk]]) 02:14, 19 April 2010 (UTC)

:Practically everything you've said in that section is already in the Compiler design section as far as I can see. What's the point? [[User:Dmcq|Dmcq]] ([[User talk:Dmcq|talk]]) 13:06, 19 April 2010 (UTC)

== Compiling tools ==

[[Compiling tools]] redirects to here. I would wish some more about compiling tools, or maybe a separate overview article for compiling tools, f.ex. preprocessors, compiler-compilers, some certain "metaprogramming" and such. [[User:Rursus|Rursus]] dixit. ([[User talk:Rursus|<span style="color: red; background: #FFFF80"><sup>m</sup><u>bork<sup>3</sup></u></span>]]!) 08:55, 27 April 2010 (UTC)

:I agree. It shouldn't redirect. It would be a important article in it's own right. scope_creep 19:38, 4 May 2010 (UTC)

== Semantic Analysis ==

The doesn't seem to be a semantic analysis article anywhere. Does it need to be created. scope_creep 19:38, 4 May 2010 (UTC)
== Compiled vs Interpreted Language ==

It needs to be made clear that this whole concept is incoherent and stems from confusion between implementation and specification. If you say "Interpreted language" you are making a fundamental category error.  <span style="font-size: smaller;" class="autosigned">—Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[Special:Contributions/203.222.167.145|203.222.167.145]] ([[User talk:203.222.167.145|talk]]) 05:44, 25 February 2010 (UTC)</span><!-- Template:UnsignedIP --> <!--Autosigned by SineBot-->

:There is no need for it to do anything more than it already does that I can see never mind talking about 'a fundamental category error'. You'd need a citation if you think that needs even more emphasis than it is already given. [[User:Dmcq|Dmcq]] ([[User talk:Dmcq|talk]])

::Actually my friend the IP is partly right and in my view this whole page shows a ''serious lack of understanding'' of the key concepts. I fixed a few things a year or so ago, but I feel that fixing the fundamental problems needs ongoing attention. I can fix it, but some would be semi-expert may show up and change it again. And we would need to go through "consensus" to discuss it, i.e. I would need to teach a class on line. This type of topic just may not work in Wikipedi as is. So let me just say to the new readers: "Do NOT rely on this page". Take a class somewhere. [[User:History2007|History2007]] ([[User talk:History2007|talk]]) 10:43, 28 February 2010 (UTC)

:::I see no serious lack of understanding, never mind in italics or fundamental problems. The main bits I can see missing in the article is there is no talk about generating debug data or the  constraints from the requirement to handle exceptions or about using libraries or gathering information from a run for optimisation or optimizaton at link time, a number of things like that. [[User:Dmcq|Dmcq]] ([[User talk:Dmcq|talk]]) 11:20, 28 February 2010 (UTC)

::::You got it. You don't see it: that was my point. Think of this: the current descriptions can never fit self modifying languages, or a whole pile of extensible languages. And the concept of program structure equivalence between the different modes clearly fails here, e.g. read Theory of Program Structures by Greibach from decades ago (Lecture Notes in Computer Science #36) as a starter for how mapping between code schems fails in the discussions here. And this article on compilers does not even mention the term "formal semantics". Hello? Who wrote all this? Anyway, I am not going to teach a class on this right now. Good luck. [[User:History2007|History2007]] ([[User talk:History2007|talk]]) 07:49, 1 March 2010 (UTC)

:::::So all these vague and unnecessarily acidic criticisms can be concluded to one somewhat precise point: ''something in the term "interpreted language"'' (used by other articles) ''is a categorical error'' (maybe something like a set error) ''that makes self modifying languages fall outside the set of language types {interpreted, compiled}''. How? Isn't it just possible that a compiling process and an interpreting process can coexist in a language, and that languages are merely classified as ''mostly'' compiled or ''mostly'' interpreted? "Compiled" is when as many "as possible" type checks and program structure checks are resolved ''before'' running the program, and "interpreting" is when many type checks and all program structure checks are left for runtime checking. [[User:Rursus|Rursus]] dixit. ([[User talk:Rursus|<span style="color: red; background: #FFFF80"><sup>m</sup><u>bork<sup>3</sup></u></span>]]!) 08:38, 27 April 2010 (UTC)

Regarding: "Compiled" is when as many "as possible" type checks and program structure checks are resolved before running the program, and "interpreting" is when many type checks and all program structure checks are left for runtime checking." That is not true. You need to first read Greibach's book as I said above to understand transformational issues. [[User:History2007|History2007]] ([[User talk:History2007|talk]]) 01:44, 14 June 2010 (UTC)

:Thanks but I think it would be much more constructive if you actually stated your summary of the difference rather than pointing to a whole book to read. [[User:Dmcq|Dmcq]] ([[User talk:Dmcq|talk]]) 11:44, 14 June 2010 (UTC)

::Ok, ok guys I will give some examples below. [[User:History2007|History2007]] ([[User talk:History2007|talk]]) 12:35, 14 June 2010 (UTC)
{{talkarchivenav}}

== compilers and interpreters as translators ==

Somebody please make clear the difference between the two?  <small><span class="autosigned">—Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[User:Sinedlebo|Sinedlebo]] ([[User talk:Sinedlebo|talk]] • [[Special:Contributions/Sinedlebo|contribs]]) 19:38, 10 May 2010 (UTC)</span></small><!-- Template:Unsigned --> <!--Autosigned by SineBot-->
== On Flow ==

Based on the request above, here is am brief intro to flow. First, let me say that I will just give examples here, instead of editing the article because Wikipedia policies do not encourage me to fix the article overall, not knowing how long the edits will survive. I tried to correct the errors before, but some were changed and were made incorrect again and I can not be bothered to re-correct them. Now for fun, let me give some examples about simple translations that give some ideas.

Assume you have an old program in [[FORTRAN]] (yes, that language) and want to make a similar program in [[C (programming language)]] to use now. You can "translate" FORTRAN to C in a simple way, by just changing syntax of the For-loops, etc. They are both assignment-based languages so there is no big deal. And whenever FORTRAN has an array you will make an array in C, so data structures map accordingly.

Now assume you have a set of wires and Christmas lights that represent the flow of your FORTRAN programs and another set that represent the C program. Give each light a name, say A, B, C D and just use a few of them. Then for any given input X, there is a sequence in which teh lights will flash, e.g. ABBBCAADEE for one case and ACCCAAADEEA for another but the sequences will be the same. So far, very simple. This is a simple translation and the sequence of flashes is in effect like the DNA sequence of the flowchart "with respect to" that input. The set of all such sequences with respect to all inputs is in effect a representation of your program. But note that the FORTRAN may still need to be "compiled" itself before it can run. 

Now to make things interesting, try to translate a C program to FORTRAN the same way. But given that FORTRAN has no recursion and no pointers, the situation is not as simple. You will need some mechanism to handle recursion in the FORTRAN code and manage to represent pointers as arrays etc. The AABBCADDFEE type mapping is no longer that simple. And here comes the issue of "Formal semantics", but that is another story. Now, as you keep executing the FORTRAN code after it has been compiled itself, you no longer have any idea what the C code looked like. But if you want a simple interpreter for FORTRAN in C, you coul din effect just read the FORTRAN one line at a time and execute teh equivalent C code.

Now with apologies to the iPhone generation, let us talk about [[APL (programming language)]] and [[Common Lisp]] programs that use [[mapcar]]. As they say, anything is one line of PAL, so any simple flow mapping from APL to FORTRAN will have serious challenges. And you guys can guuess the flow representation of mapcars on nested lists etc. And if you want really interesting, think of the flow in [[OPS5]] and try translating that into FORTRAN - remember that the order of statements in OPS can change without changing program behavor!

So if you think of these issues, and lights flashing as sequences, you get the idea. Now think of a set of byte code generated from Java or Smalltalk, etc. While you can have a program that interprets those bytes codes, the translation from the higher level to byte codes is not teh simple sequence type of light flashes. Anyway, that is enough for now. Cheers. [[User:History2007|History2007]] ([[User talk:History2007|talk]]) 13:02, 14 June 2010 (UTC)

:This is an [[encyclopaedia]], not a class. I'm sure it is wonderful to see the dawning light of comprehension as they figure it out and have their theories knocked down and try again and so get an inner knowledge - but that's not what Wikipedia is about. What should be here is straightforward statements backed up by citations. [[User:Dmcq|Dmcq]] ([[User talk:Dmcq|talk]]) 10:34, 15 June 2010 (UTC)

::I was trying to do you guys a favor by clarifying the concepts for you - that was why I typed on the talk page, not the article. Now, that will stop. I typed that because without it you guys do not seem to be able to follow the logic of the topic, but insist on debating it, like the ''totally incorrect'' statements you and Rursus made above. And correct statements can be change or deleted by students who do not grasp the concepts: it is a problem with Wkipedia policy really. Let us do this. I will no watch or edit this page any more, ever again. Since you are the self-appointed expert here, go and take a few classes, then fix the page. You can not just fix it by looking up on line references. That is why universities are there: at some point topic are too complicated for the average person without the technical background. And believe me, this is NOT a complicated issue: most undergraduates should know this. But anyway, that is the last I will type here. [[User:History2007|History2007]] ([[User talk:History2007|talk]]) 12:42, 15 June 2010 (UTC)

:::Somebody else might be able to find something there. The above editor has actually produced a number of good articles which is why I bothered to talk to them in the first place instead of just dismissing them as bullshitting. [[User:Dmcq|Dmcq]] ([[User talk:Dmcq|talk]]) 13:02, 15 June 2010 (UTC)

== Compiler Hinting ==

I thought this article would mention [[compiler hinting]], but I didn't find it here.  Should it?  Where would I find this information?  [[Special:Contributions/192.91.172.36|192.91.172.36]] ([[User talk:192.91.172.36|talk]]) 20:21, 7 October 2010 (UTC)
== compiler nedir ? ==

compiler kısaca herhenagi bir programlama diliyle yazılmış olan verileri bilgisayarın anlıyacağı hale çeviren programdır. 1950 lerde  grace hopper derleyici programı yazmıştır.  Kendisine makina diliyle aramızdaki tercümanda diyebiliriz.Günümüzde  programlamada  cok önemli bir  yeri  vardır.  <small><span class="autosigned">— Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[User:Fatih80061|Fatih80061]] ([[User talk:Fatih80061|talk]] • [[Special:Contributions/Fatih80061|contribs]]) 22:39, 22 March 2011 (UTC)</span></small><!-- Template:Unsigned --> <!--Autosigned by SineBot-->

:Arfle barfle gloop? This is the English Wikipedia not the Turkish one. [[User:Dmcq|Dmcq]] ([[User talk:Dmcq|talk]]) 23:46, 22 March 2011 (UTC)

== Static and dynamic linking ==

There is no information on Dynamic and static library linking, as well as [[software bundle]]s creation.

:Follow the link to [[Linker (computing)]]. The easiest way to find things is to search for them using te search box on the top right or using a general search engine like google. [[User:Dmcq|Dmcq]] ([[User talk:Dmcq|talk]]) 13:20, 21 August 2011 (UTC)
== Redirect page title typo? ==

"Compiled sofware" redirects here. Should this be "Compiled software"?
[[User:Annoyamouse|Annoyamouse]] ([[User talk:Annoyamouse|talk]]) 04:43, 28 October 2011 (UTC)

:Sofware is definitely wrong and I wouldn't have either. Compiled software doesn't sound like something a person would look up to me. [[User:Dmcq|Dmcq]] ([[User talk:Dmcq|talk]]) 08:00, 28 October 2011 (UTC)

== CL? ==

: Some language specifications spell out that implementations must include a compilation facility; for example, Common Lisp. However, there is nothing inherent in the definition of Common Lisp that stops it from being interpreted.

I'm not sure what this means.  There is a [http://www.lispworks.com/documentation/HyperSpec/Body/f_cmp.htm function called COMPILE] in Common Lisp but it basically is only required to [http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_c.htm#compiled_function expand macros].  Any C compiler is required to do that, too, no?  <span style="font-size: smaller;" class="autosigned">— Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[Special:Contributions/216.163.72.5|216.163.72.5]] ([[User talk:216.163.72.5|talk]]) 19:30, 5 January 2012 (UTC)</span><!-- Template:Unsigned IP --> <!--Autosigned by SineBot-->

== IL vs IR ==

I changed some occurances of IL generation as a compiler phase to "intermediate representation", since that is more correct. The intermediate representation from which code is generated doesn't have to be a language, even in the broadest sense of the word. And 
more important, it often isn't. I kept IL as an example of an IR though, and also mentioned compile graphs and trees.

Maybe I didn't get all occurances though.

: Sounds like a good change. Please don't forget to sign and date your posts with <nowiki>'~~~~'</nowiki>! [[User:CurryMi40|CurryMi40]] ([[User talk:CurryMi40|talk]]) 19:49, 27 November 2014 (UTC)

== incorrect "cross compiler" comment ==

In the introduction section, the phrase "Compilers also exist which translate from one high level language to another (cross compilers), or[...]" is highly inaccurate.  "Cross compiler" refers to something very different, as described in the immediately following section.  Having worked in the industry for many years, I've heard lots of names for a high-level-to-high-level translator, but cross compiler was never one of them.  I've deleted the parenthetical comment.

That still is not quite right. That would put JAVA in the cross-compiler category. I have never head anyone call JAVA a cross compiler. True that it is. But it's output runs on many machines probably most likely including the one it was compiled on. I have written many code generators for cross compilers. There is really nothing special about a cross compiler other than the code produced. And in many cases the same compiler could produce code for the machine it was running on. The target machine was an option at command lime. See Compiler output: "The output of a compiler that produces code for a virtual machine (VM) may or may not be executed on the same platform as the compiler that produced it. For this reason such compilers are not usually classified as native or cross compilers." The first description needs improvement or deletion,
--[[User:Steamerandy|Steamerandy]] ([[User talk:Steamerandy|talk]]) 10:22, 15 September 2014 (UTC)
:Note that it is called Java not JAVA. Java does not produce a high level language. Most people do not look at the output of Java. A cross-compiler produces output that people typically use. Java is not a cross-compiler.  <small><span class="autosigned">—&nbsp;Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[User:Sam Tomato|Sam Tomato]] ([[User talk:Sam Tomato|talk]] • [[Special:Contributions/Sam Tomato|contribs]]) 18:52, 11 January 2015 (UTC)</span></small><!-- Template:Unsigned --> <!--Autosigned by SineBot-->

== Possible grammatical glitch ==

In section ''[[Compiler#Front end|Front end]]'' (item 1, ''line reconstruction''), this sentence seems odd to me (emphasis added): ''«&nbsp;Atlas Autocode (…) are examples of stropped languages '''which''' compilers would have a Line Reconstruction phase.&nbsp;»''
Shouldn’t it be something like ''“whose compilers would (…)”'' or ''“for which compilers would (…)”''?<br/>
With apologies if it seems obvious one way or the other!
<br/>— [[User:Wlgrin|Wlgrin]] 22:20, 8 January 2012 (UTC)

Many people say "which" instead of "that". I am not sure what would be appropriate here but I know that the word "which" is often used too often. Perhaps in that context it could be "of which" instead of "which".  <small><span class="autosigned">—&nbsp;Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[User:Sam Tomato|Sam Tomato]] ([[User talk:Sam Tomato|talk]] • [[Special:Contributions/Sam Tomato|contribs]]) 18:59, 11 January 2015 (UTC)</span></small><!-- Template:Unsigned --> <!--Autosigned by SineBot-->

== What bytecode and JIT has to do with Interpretation vs. Compilation? ==

Article says: "Modern trends toward just-in-time compilation and bytecode interpretation at times blur the traditional categorizations of compilers and interpreters." JIT compiles bytecode into machine language. Bytecode was not intended for compilation (Sun have designed the bytecode as a machine language in mind). It was not intended for translation at all. It is result of compilation. Whether you interpret, compile or directly execute the bytecode, it does not matter at all. The only thing that we were always sure about was the fact that bytecode is produced from java source as result of '''compilation'''. For this reason also, the status of Java as compiled language is not debatable. So, which blurring are you talking about? --[[User:Javalenok|Javalenok]] ([[User talk:Javalenok|talk]]) 20:42, 29 January 2012 (UTC)
:The point I think is that things like JIT compilation and byte code blur the traditional distinctions between compiled and interpreted code. With JIT and bytecode you can get some of the advantages of both such as strong typing (typically with compiled languages) and automatic memory allocation and garbage collection (typically with interpreted languages). It makes perfect sense to me and I've heard the people who designed Java say that was one of their design goals. --[[User:MadScientistX11|MadScientistX11]] ([[User talk:MadScientistX11|talk]]) 04:57, 29 December 2014 (UTC)
:Add to the mix the intermediate language of the Common Language Runtime (Microsoft .Net). Both Java Bytecode and the MSIL are said to do a JIT compilation. The use of the word compilation is quite different from the traditional use. In my opinion at least it should not be called compilation. In the past software that took a language in and then acted upon it was called a translator. Software that acted upon some intermediate code was called an interpreter. The word compiler is now being used to refer to the process of acting upon (executing) an intermediate code, it is blurring the definition of what a compiler is. [[User:Sam Tomato|Sam Tomato]] ([[User talk:Sam Tomato|talk]]) 19:11, 11 January 2015 (UTC)

== Vague comments about "first" in lede ==

The lede combines comments about the first high-level language and first computer which are (a) unsourced and (b) not reflect in the body of the topic.  The apparent intent of the edit was to introduce [[Plankalkül]] as the first high-level language and leave the implication that this led to the first compilers.  As noted in the corresponding topic, Plankalkül was neglected for 45 years before a compiler was finally generated for it. The Plankalkül topic does not contain any information which would lead to a plausible argument that it had any effect on compiler development during the 1950s.  The edit provides less information about the first computer versus the ones which were the basis for the first compilers (and in turn, the first ''implemented'' high-level languages) [[User:Tedickey|TEDickey]] ([[User talk:Tedickey|talk]]) 01:45, 11 February 2015 (UTC)

: Hello!  I agree that {{Diff|Compiler|645608643|638827348|this edit}} made by {{u|Schily}} should be pretty much reverted, while information about [[Plankalkül]] should be briefly incorporated into the {{Section link|Compiler|History}} section.  In other words, [[Plankalkül]] totally deserves to be mentioned there, but it was just an idea/proposal that actually materialized in different forms about ten years later. &mdash;&nbsp;[[User:Dsimic|Dsimic]]&nbsp;([[User talk:Dsimic#nobold|talk]]&nbsp;|&nbsp;[[Special:Contributions/Dsimic|contribs]]) 06:41, 14 February 2015 (UTC)

:::The previous text was full of false claims. If you revert my edit, you would reintroduce those false claims and I thus of course had to revert your edit. As mentioned, the idea of a high level programming language is as old as the first computer and the compiler is just an implementation of this idea. If you don't like my text, you should be able to give good reason why and propose a better wording instead of proposing to go back to false claims. [[User:Schily|Schily]] ([[User talk:Schily|talk]]) 13:33, 15 February 2015 (UTC)

:::: Well, you've just confirmed that ''your'' version is actually to be corrected: it isn't about the concept, but about real-life implementations.  [[Plankalkül]] was just a concept, while implementations came about ten years later; it's pretty much the same as the concept of time machine, for example, which is widely described but has no known implementations.  Anyway, here's the wording I propose:
::::: Software for early computers was primarily written in assembly language, and implementations of higher-level programming languages were not available until the benefits of being able to reuse software on different kinds of [[CPU]]s started to become significantly greater than the costs of writing a compiler. At the same time, although the concept of a high-level language existed nearly since the first computer, the limited [[main memory|memory]] capacity of early computers led to substantial technical challenges when the first compilers were designed.
::::: Although <s>the first</s> an early high-level programming language, called [[Plankalkül]], was proposed by [[Konrad Zuse]] in 1943, actual implementations of machine-independent programming languages were first developed toward the end of the 1950s in form of several experimental compilers.  The first compiler was written by [[Grace Hopper]], in 1952, for the...
:::: Looking good? &mdash;&nbsp;[[User:Dsimic|Dsimic]]&nbsp;([[User talk:Dsimic#nobold|talk]]&nbsp;|&nbsp;[[Special:Contributions/Dsimic|contribs]]) 19:30, 15 February 2015 (UTC)

::::::I did not confirm that my text needs to be worked on, I however cornfirmed that the previous text that claimed compilers have not been invented in early days was wrong.
::::::I am not happy with your text proposal as it does not reflect the situation in 1943 when Konrad Zuse proposed Plankalkül. Note that Konrad Zuse was a construction engineer and he invented both the computer and Plancalkül to make the work of a construction engineer easier. But in 1943, there was no money for this goal. Money was available only for the Gleitbombe HS 293 (the first cruise missile with TV camera and target control - developed to the south of Berlin (Ludwigsfelde)), FLAK control and airfoil calculation. It is obvious that until 1945, there was no way to implement a compiler by Zuse and in the first years after WW II, things have not been better. Grace hopper was in a completely different situation and you create a wrong impression if you do not explain why Plankalkül could not be implemented in 1943.<small><span class="autosigned">—&nbsp;Preceding [[Wikipedia:Signatures|unsigned]] comment added by [[User:Schily|Schily]] ([[User talk:Schily|talk]] • [[Special:Contributions/Schily|contribs]]) 21:28, 15 February 2015‎ (UTC)</span></small><!-- Template:Unsigned -->

::::::: This is nonsense.  Why should we mention some missiles in a compiler-related article? &mdash;&nbsp;[[User:Dsimic|Dsimic]]&nbsp;([[User talk:Dsimic#nobold|talk]]&nbsp;|&nbsp;[[Special:Contributions/Dsimic|contribs]]) 21:38, 15 February 2015 (UTC)

::::::::Ignoring the facts on how the first programmable computer was funded is history forgery. [[User:Schily|Schily]] ([[User talk:Schily|talk]]) 21:44, 15 February 2015 (UTC)

::::::::: Sorry, but that's still only more nonsense.  In a few words, this article ''is not'' the place for describing such historical aspects. &mdash;&nbsp;[[User:Dsimic|Dsimic]]&nbsp;([[User talk:Dsimic#nobold|talk]]&nbsp;|&nbsp;[[Special:Contributions/Dsimic|contribs]]) 21:47, 15 February 2015 (UTC)

::::::::::Then I recommend to stay with my historically correct text, unless you like to introduce nonsense... [[User:Schily|Schily]] ([[User talk:Schily|talk]]) 21:55, 15 February 2015 (UTC)

::::::::::: I still disagree.  However, as this obviously isn't leading us toward a mutually acceptable wording, let's wait for more input from other editors. &mdash;&nbsp;[[User:Dsimic|Dsimic]]&nbsp;([[User talk:Dsimic#nobold|talk]]&nbsp;|&nbsp;[[Special:Contributions/Dsimic|contribs]]) 22:04, 15 February 2015 (UTC)

::::::::::::If you like to continue here, you could e.g. describe what in special you don't like with the current text. As a compiler is no more than the implementation of a high level programming language, Plankalkül of course is important for a compiler article. I recommend you to read the German WP article that is much better than the english one. As I am sure you cannot give a reason why the current text should not be OK, I propose to leave it as it is. [[User:Schily|Schily]] ([[User talk:Schily|talk]]) 10:37, 16 February 2015 (UTC)

::::::::::::: {{Anchor|EXPLANATION1}}The version I've proposed above ties it all much better together.  In other words, my version clearly describes the relation between early high-level lanugages and their actual implementations that were made available later; Plankalkül is still mentioned, of course.  Would you mind re-reading my proposal, available above? &mdash;&nbsp;[[User:Dsimic|Dsimic]]&nbsp;([[User talk:Dsimic#nobold|talk]]&nbsp;|&nbsp;[[Special:Contributions/Dsimic|contribs]]) 01:22, 17 February 2015 (UTC)

::::::::::::::I believe we could easier come to an agreement if you did explain what you don't like with the current text. [[User:Schily|Schily]] ([[User talk:Schily|talk]]) 11:07, 19 February 2015 (UTC)

::::::::::::::: {{Anchor|EXPLANATION2}}Obviously, current version doesn't tie it all together too well.  As already explained, current version doesn't "clearly describe the relation between early high-level lanugages and their actual implementations that were made available later".  Why do I need to repeat what I already wrote a few lines above? &mdash;&nbsp;[[User:Dsimic|Dsimic]]&nbsp;([[User talk:Dsimic#nobold|talk]]&nbsp;|&nbsp;[[Special:Contributions/Dsimic|contribs]]) 21:31, 19 February 2015 (UTC)

{{od|::::::::::::::::}} Any further thoughts on this, please?  {{u|Schily}}, {{u|Tedickey}}? &mdash;&nbsp;[[User:Dsimic|Dsimic]]&nbsp;([[User talk:Dsimic#nobold|talk]]&nbsp;|&nbsp;[[Special:Contributions/Dsimic|contribs]]) 13:24, 7 March 2015 (UTC)

: I believe I already expressed agreement with your proposed changes [[User:Tedickey|TEDickey]] ([[User talk:Tedickey|talk]]) 14:05, 7 March 2015 (UTC)

:: Thanks.  Let's see whether {{u|Schily}} provides additional comments, otherwise I'd say that we should implement the proposed changes. &mdash;&nbsp;[[User:Dsimic|Dsimic]]&nbsp;([[User talk:Dsimic#nobold|talk]]&nbsp;|&nbsp;[[Special:Contributions/Dsimic|contribs]]) 07:13, 12 March 2015 (UTC)

:::I asked you for an explanation what exactly you don't like in my current text. If you give this explanation, I am able to reply. [[User:Schily|Schily]] ([[User talk:Schily|talk]]) 09:57, 12 March 2015 (UTC) 

:::: Please don't get me wrong, Schily, but you sound abrasive and somewhat uncooperative.  Come on, I've explained that already at least twice, please have a look above. &mdash;&nbsp;[[User:Dsimic|Dsimic]]&nbsp;([[User talk:Dsimic#nobold|talk]]&nbsp;|&nbsp;[[Special:Contributions/Dsimic|contribs]]) 10:22, 12 March 2015 (UTC)

:::::I am not aware of such an explanation, so please point me to that text or repeat it. [[User:Schily|Schily]] ([[User talk:Schily|talk]]) 10:50, 12 March 2015 (UTC)

:::::: See [[#EXPLANATION1|here]] and [[#EXPLANATION2|here]]. &mdash;&nbsp;[[User:Dsimic|Dsimic]]&nbsp;([[User talk:Dsimic#nobold|talk]]&nbsp;|&nbsp;[[Special:Contributions/Dsimic|contribs]]) 11:17, 12 March 2015 (UTC)

::::::: The first one does not explain things but just points to a new text. The second one sounds a bit vague. This is why I asked for an explanation. [[User:Schily|Schily]] ([[User talk:Schily|talk]]) 12:25, 12 March 2015 (UTC)

:::::::: Sorry, but if you're unable to understand that those two posts ''are'' explanations, then I really don't know how to make the whole thing more understandable to you. &mdash;&nbsp;[[User:Dsimic|Dsimic]]&nbsp;([[User talk:Dsimic#nobold|talk]]&nbsp;|&nbsp;[[Special:Contributions/Dsimic|contribs]]) 12:39, 12 March 2015 (UTC)

:::::::::Please try it with facts instead of using feelings. The current text explains that the idea of a compiler is much older than the first implementation. What is your problem with this description? [[User:Schily|Schily]] ([[User talk:Schily|talk]]) 14:05, 12 March 2015 (UTC)

:::::::::: Dude, I don't know how to tell you that, but you are clearly not open to a constructive discussion.  This is leading us nowhere, as you have that exact terse wording "welded" in your mind, with no intentions to accept a possibility that it can be made better. &mdash;&nbsp;[[User:Dsimic|Dsimic]]&nbsp;([[User talk:Dsimic#nobold|talk]]&nbsp;|&nbsp;[[Special:Contributions/Dsimic|contribs]]) 14:51, 12 March 2015 (UTC)

:::::::::::Sorry, but the fact that you don't explain your concern is the problem. Send a fact based explanation instead of vague text and we will be able to go somewhere. As long as you don't send the explanation I asked you to send, you are blocking the discussion. I cannot understand your concern as long as you just send vague feelings and forget to send what you really have in mind.[[User:Schily|Schily]] ([[User talk:Schily|talk]]) 10:32, 13 March 2015 (UTC)

:::::::::::: Unfortunately, the problem ''is'' that you don't seem (or want) to understand what I write. &mdash;&nbsp;[[User:Dsimic|Dsimic]]&nbsp;([[User talk:Dsimic#nobold|talk]]&nbsp;|&nbsp;[[Special:Contributions/Dsimic|contribs]]) 12:08, 13 March 2015 (UTC)

:::::::::::::The problem is that you may believe that you expressed some feelings but actually you did not. This is why I asked you to send a fact oriented explanation why you like to change things. Do this and we can advance. [[User:Schily|Schily]] ([[User talk:Schily|talk]]) 13:16, 16 March 2015 (UTC) 

:::::::::::::: I'm no longer wasting my time on this pointless debate in which the other party ignores already expressed arguments.  Let's see if anybody else cares. &mdash;&nbsp;[[User:Dsimic|Dsimic]]&nbsp;([[User talk:Dsimic#nobold|talk]]&nbsp;|&nbsp;[[Special:Contributions/Dsimic|contribs]]) 05:34, 18 March 2015 (UTC)

::::::::::::::I am happy to continue if you send arguments... [[User:Schily|Schily]] ([[User talk:Schily|talk]]) 14:03, 19 March 2015 (UTC)

:::::Actually, the [[Plankalkül]] topic qualifies that by stating "[[Von_Neumann_programming_languages|non-Von Neumann]]" (and the corresponding topic is poorly sourced) but does not give a [[WP:RS|reliable source]] for the "first".  From the sources on that topic, one cannot establish more than the "early" which a previous comment noted. [[User:Tedickey|TEDickey]] ([[User talk:Tedickey|talk]]) 20:00, 15 February 2015 (UTC)

:::::The modified proposal looks fine [[User:Tedickey|TEDickey]] ([[User talk:Tedickey|talk]]) 20:25, 15 February 2015 (UTC)

::Thanks.  Comments stating "first" or "notable" always require a source from a recognized knowledgeable authority in the given field.  In this case, that would be some variety of published historian. [[User:Tedickey|TEDickey]] ([[User talk:Tedickey|talk]]) 13:06, 14 February 2015 (UTC)

::: I'd suggest that we wait a few days for a response from Schily before doing anything, just so we try to establish a consensus first and avoid reverts and whatnot.  Hope you agree. &mdash;&nbsp;[[User:Dsimic|Dsimic]]&nbsp;([[User talk:Dsimic#nobold|talk]]&nbsp;|&nbsp;[[Special:Contributions/Dsimic|contribs]]) 22:19, 14 February 2015 (UTC)

:::Certainly. [[User:Tedickey|TEDickey]] ([[User talk:Tedickey|talk]]) 22:35, 14 February 2015 (UTC)

== External links modified ==

Hello fellow Wikipedians,

I have just added archive links to {{plural:1|one external link|1 external links}} on [[Compiler]]. Please take a moment to review [https://en.wikipedia.org/w/index.php?diff=prev&oldid=708687505 my edit]. If necessary, add {{tlx|cbignore}} after the link to keep me from modifying it. Alternatively, you can add {{tlx|nobots|deny{{=}}InternetArchiveBot}} to keep me off the page altogether. I made the following changes:
*Added archive http://web.archive.org/web/20141010102940/http://www.compdev.net/ to http://www.compdev.net

When you have finished reviewing my changes, please set the ''checked'' parameter below to '''true''' or '''failed''' to let others know (documentation at {{tlx|Sourcecheck}}).

{{sourcecheck|checked=false}}

Cheers.—[[User:Cyberbot II|<sup style="color:green;font-family:Courier">cyberbot II]]<small><sub style="margin-left:-14.9ex;color:green;font-family:Comic Sans MS">[[User talk:Cyberbot II|<span style="color:green">Talk to my owner]]:Online</sub></small> 00:32, 7 March 2016 (UTC)

== External links modified ==

Hello fellow Wikipedians,

I have just modified {{plural:1|one external link|1 external links}} on [[Compiler]]. Please take a moment to review [https://en.wikipedia.org/w/index.php?diff=prev&oldid=738897704 my edit]. If you have any questions, or need the bot to ignore the links, or the page altogether, please visit [[User:Cyberpower678/FaQs#InternetArchiveBot|this simple FaQ]] for additional information. I made the following changes:
*Added archive https://web.archive.org/web/20150103161301/http://www.informatik.uni-trier.de/~ley/db/books/compiler/index.html to http://www.informatik.uni-trier.de/~ley/db/books/compiler/index.html

When you have finished reviewing my changes, please set the ''checked'' parameter below to '''true''' or '''failed''' to let others know (documentation at {{tlx|Sourcecheck}}).

{{sourcecheck|checked=false}}

Cheers.—[[User:InternetArchiveBot|'''<span style="color:darkgrey;font-family:monospace">InternetArchiveBot</span>''']] <span style="color:green;font-family:Rockwell">([[User talk:InternetArchiveBot|Report bug]])</span> 17:46, 11 September 2016 (UTC)

== External links modified ==

Hello fellow Wikipedians,

I have just modified {{plural:1|one external link|1 external links}} on [[Compiler]]. Please take a moment to review [https://en.wikipedia.org/w/index.php?diff=prev&oldid=752045025 my edit]. If you have any questions, or need the bot to ignore the links, or the page altogether, please visit [[User:Cyberpower678/FaQs#InternetArchiveBot|this simple FaQ]] for additional information. I made the following changes:
*Added archive https://web.archive.org/web/20120220002430/http://www.interesting-people.org/archives/interesting-people/199706/msg00011.html to http://www.interesting-people.org/archives/interesting-people/199706/msg00011.html

When you have finished reviewing my changes, please set the ''checked'' parameter below to '''true''' or '''failed''' to let others know (documentation at {{tlx|Sourcecheck}}).

{{sourcecheck|checked=false}}

Cheers.—[[User:InternetArchiveBot|'''<span style="color:darkgrey;font-family:monospace">InternetArchiveBot</span>''']] <span style="color:green;font-family:Rockwell">([[User talk:InternetArchiveBot|Report bug]])</span> 05:25, 29 November 2016 (UTC)

== Dead Links ==

Out of the few links in this article many are not working. The 5th and 6th link for example; the 5th link takes you to a digital library that you need to a subscription to, and the 6th link takes you to a short preview of an academic journal. These links are vital and renewing them could enhances the credentials of the article.
[[User:AdamaS|AdamaS]] ([[User talk:AdamaS|talk]]) 03:10, 28 January 2017 (UTC)Adama Sanoh
{{talkarchivenav}}

== Restructure: Compiler Article  ==

Comments:
A. Introduction could focus and limit topic coverage. Example: The class of specialized programs that transform a Computer Language program into executable Machine Language Programs fall into two major categories: Interpreters and Compilers. ...
B. Table of Contents 
1. Compilation
1.1 Classic Model 
1.1.1 Front End
1.1.2 Optimizer
1.1.3 Back End 
1.2 Other Models 
2. Dependencies 
2.1 Language Architectures
2.2 Standards
2.3 Operating Systems
2.4 Target Architectures
3. Other Compiler Types
4. History
C. See Also (add links to topics such as Linker, Intermediate Representation, DIANA, a Descriptive Intermediate Attributed Notation for Ada ...)
D. Reference updates to include some of the Compiler Books and papers e.g. "Crafting a Compiler" by Fischer/LeBlanc, "The Architecture of Open Source Applications" Chapter 11 by Chris Lattner
 
E. About Models
General model of compilation can be viewed as the front end which that analyzes the input program; the middle section that optimizes the analyzed program; the back end that produces the code for the target architecture. (similar diagram in current article 'Three phases compiler structure'
These phases are supported by constructs such as - 
         Language Architecture formed by the formalized syntax and semantics.    
         Libraries
         Target ISA - Instruction Set Architecture
There are other useful views such as the LLVM project. 
Also Other Compiler types can cover things like programmable arrays, graphic, specification and so on  
P.S. Interpreter Article could benefit from some additional details 
[[User:Nodorf|Nodorf]] ([[User talk:Nodorf|talk]]) 20:29, 13 July 2017 (UTC)nodorf
